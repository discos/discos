// -*- C++ -*-
//
// $Id: XBackendsErrorsC.cpp,v 1.1 2010/06/21 09:08:59 bliliana Exp $

// ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
// TAO and the TAO IDL Compiler have been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// and
//       Distributed Object Computing Laboratory
//       University of California at Irvine
//       Irvine, CA
//       USA
//       http://doc.ece.uci.edu/
// and
//       Institute for Software Integrated Systems
//       Vanderbilt University
//       Nashville, TN
//       USA
//       http://www.isis.vanderbilt.edu/
//
// Information about TAO is available at:
//     http://www.cs.wustl.edu/~schmidt/TAO.html

// TAO_IDL - Generated from
// be/be_codegen.cpp:381


#include "XBackendsErrorsC.h"
#include "tao/AnyTypeCode/Null_RefCount_Policy.h"
#include "tao/AnyTypeCode/TypeCode_Constants.h"
#include "tao/AnyTypeCode/Alias_TypeCode_Static.h"
#include "tao/AnyTypeCode/String_TypeCode_Static.h"
#include "tao/AnyTypeCode/Struct_TypeCode_Static.h"
#include "tao/AnyTypeCode/TypeCode_Struct_Field.h"
#include "tao/CDR.h"
#include "tao/SystemException.h"
#include "tao/CDR.h"
#include "tao/AnyTypeCode/Any_Dual_Impl_T.h"
#include "ace/OS_NS_string.h"

#if !defined (__ACE_INLINE__)
#include "XBackendsErrorsC.inl"
#endif /* !defined INLINE */

// TAO_IDL - Generated from
// be/be_visitor_arg_traits.cpp:73

TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Arg traits specializations.
namespace TAO
{
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_exception/exception_ctor.cpp:66

XBackendsErrors::XBackendsErrorsEx::XBackendsErrorsEx (
    const ACSErr::ErrorTrace & _tao_errorTrace
  )
  : ::CORBA::UserException (
        "IDL:alma/XBackendsErrors/XBackendsErrorsEx:1.0",
        "XBackendsErrorsEx"
      )
{
  this->errorTrace = _tao_errorTrace;
}



// TAO_IDL - Generated from 
// be/be_visitor_exception/exception_cs.cpp:110

XBackendsErrors::XBackendsErrorsEx::XBackendsErrorsEx (void)
  : ::CORBA::UserException (
        "IDL:alma/XBackendsErrors/XBackendsErrorsEx:1.0",
        "XBackendsErrorsEx"
      )
{
}

XBackendsErrors::XBackendsErrorsEx::~XBackendsErrorsEx (void)
{
}

XBackendsErrors::XBackendsErrorsEx::XBackendsErrorsEx (const ::XBackendsErrors::XBackendsErrorsEx &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->errorTrace = _tao_excp.errorTrace;
}

XBackendsErrors::XBackendsErrorsEx&
XBackendsErrors::XBackendsErrorsEx::operator= (const ::XBackendsErrors::XBackendsErrorsEx &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->errorTrace = _tao_excp.errorTrace;
  return *this;
}

void XBackendsErrors::XBackendsErrorsEx::_tao_any_destructor (void *_tao_void_pointer)
{
  XBackendsErrorsEx *_tao_tmp_pointer =
    static_cast<XBackendsErrorsEx *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

XBackendsErrors::XBackendsErrorsEx *
XBackendsErrors::XBackendsErrorsEx::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<XBackendsErrorsEx *> (_tao_excp);
}

const XBackendsErrors::XBackendsErrorsEx *
XBackendsErrors::XBackendsErrorsEx::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const XBackendsErrorsEx *> (_tao_excp);
}

::CORBA::Exception *XBackendsErrors::XBackendsErrorsEx::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::XBackendsErrors::XBackendsErrorsEx, 0);
  return retval;
}

::CORBA::Exception *
XBackendsErrors::XBackendsErrorsEx::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::XBackendsErrors::XBackendsErrorsEx (*this),
      0
    );
  return result;
}

void XBackendsErrors::XBackendsErrorsEx::_raise (void) const
{
  throw *this;
}

void XBackendsErrors::XBackendsErrorsEx::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (cdr << *this)
    {
      return;
    }
  
  throw ::CORBA::MARSHAL ();
}

void XBackendsErrors::XBackendsErrorsEx::_tao_decode (TAO_InputCDR &cdr)
{
  if (cdr >> *this)
    {
      return;
    }
  
  throw ::CORBA::MARSHAL ();
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr XBackendsErrors::XBackendsErrorsEx::_tao_type (void) const
{
  return ::XBackendsErrors::_tc_XBackendsErrorsEx;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/struct_typecode.cpp:84

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_XBackendsErrors_XBackendsErrorsEx[] =
      {
        { "errorTrace", &ACSErr::_tc_ErrorTrace }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_XBackendsErrors_XBackendsErrorsEx (
  ::CORBA::tk_except,
  "IDL:alma/XBackendsErrors/XBackendsErrorsEx:1.0",
  "XBackendsErrorsEx",
  _tao_fields_XBackendsErrors_XBackendsErrorsEx,
  1);

namespace XBackendsErrors
{
  ::CORBA::TypeCode_ptr const _tc_XBackendsErrorsEx =
    &_tao_tc_XBackendsErrors_XBackendsErrorsEx;
}



// TAO_IDL - Generated from
// be/be_visitor_exception/exception_ctor.cpp:66

XBackendsErrors::NoSettingEx::NoSettingEx (
    const ACSErr::ErrorTrace & _tao_errorTrace
  )
  : ::CORBA::UserException (
        "IDL:alma/XBackendsErrors/NoSettingEx:1.0",
        "NoSettingEx"
      )
{
  this->errorTrace = _tao_errorTrace;
}



// TAO_IDL - Generated from 
// be/be_visitor_exception/exception_cs.cpp:110

XBackendsErrors::NoSettingEx::NoSettingEx (void)
  : ::CORBA::UserException (
        "IDL:alma/XBackendsErrors/NoSettingEx:1.0",
        "NoSettingEx"
      )
{
}

XBackendsErrors::NoSettingEx::~NoSettingEx (void)
{
}

XBackendsErrors::NoSettingEx::NoSettingEx (const ::XBackendsErrors::NoSettingEx &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->errorTrace = _tao_excp.errorTrace;
}

XBackendsErrors::NoSettingEx&
XBackendsErrors::NoSettingEx::operator= (const ::XBackendsErrors::NoSettingEx &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->errorTrace = _tao_excp.errorTrace;
  return *this;
}

void XBackendsErrors::NoSettingEx::_tao_any_destructor (void *_tao_void_pointer)
{
  NoSettingEx *_tao_tmp_pointer =
    static_cast<NoSettingEx *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

XBackendsErrors::NoSettingEx *
XBackendsErrors::NoSettingEx::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<NoSettingEx *> (_tao_excp);
}

const XBackendsErrors::NoSettingEx *
XBackendsErrors::NoSettingEx::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const NoSettingEx *> (_tao_excp);
}

::CORBA::Exception *XBackendsErrors::NoSettingEx::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::XBackendsErrors::NoSettingEx, 0);
  return retval;
}

::CORBA::Exception *
XBackendsErrors::NoSettingEx::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::XBackendsErrors::NoSettingEx (*this),
      0
    );
  return result;
}

void XBackendsErrors::NoSettingEx::_raise (void) const
{
  throw *this;
}

void XBackendsErrors::NoSettingEx::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (cdr << *this)
    {
      return;
    }
  
  throw ::CORBA::MARSHAL ();
}

void XBackendsErrors::NoSettingEx::_tao_decode (TAO_InputCDR &cdr)
{
  if (cdr >> *this)
    {
      return;
    }
  
  throw ::CORBA::MARSHAL ();
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr XBackendsErrors::NoSettingEx::_tao_type (void) const
{
  return ::XBackendsErrors::_tc_NoSettingEx;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/struct_typecode.cpp:84

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_XBackendsErrors_NoSettingEx[] =
      {
        { "errorTrace", &ACSErr::_tc_ErrorTrace }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_XBackendsErrors_NoSettingEx (
  ::CORBA::tk_except,
  "IDL:alma/XBackendsErrors/NoSettingEx:1.0",
  "NoSettingEx",
  _tao_fields_XBackendsErrors_NoSettingEx,
  1);

namespace XBackendsErrors
{
  ::CORBA::TypeCode_ptr const _tc_NoSettingEx =
    &_tao_tc_XBackendsErrors_NoSettingEx;
}



// TAO_IDL - Generated from 
// be/be_visitor_exception/any_op_cs.cpp:50
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<XBackendsErrors::XBackendsErrorsEx>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;
    
    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }
    
    return true;
  }
}

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const XBackendsErrors::XBackendsErrorsEx &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<XBackendsErrors::XBackendsErrorsEx>::insert_copy (
      _tao_any,
      XBackendsErrors::XBackendsErrorsEx::_tao_any_destructor,
      XBackendsErrors::_tc_XBackendsErrorsEx,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    XBackendsErrors::XBackendsErrorsEx *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<XBackendsErrors::XBackendsErrorsEx>::insert (
      _tao_any,
      XBackendsErrors::XBackendsErrorsEx::_tao_any_destructor,
      XBackendsErrors::_tc_XBackendsErrorsEx,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    XBackendsErrors::XBackendsErrorsEx *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const XBackendsErrors::XBackendsErrorsEx *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const XBackendsErrors::XBackendsErrorsEx *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<XBackendsErrors::XBackendsErrorsEx>::extract (
        _tao_any,
        XBackendsErrors::XBackendsErrorsEx::_tao_any_destructor,
        XBackendsErrors::_tc_XBackendsErrorsEx,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from 
// be/be_visitor_exception/any_op_cs.cpp:50
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<XBackendsErrors::NoSettingEx>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;
    
    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }
    
    return true;
  }
}

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const XBackendsErrors::NoSettingEx &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<XBackendsErrors::NoSettingEx>::insert_copy (
      _tao_any,
      XBackendsErrors::NoSettingEx::_tao_any_destructor,
      XBackendsErrors::_tc_NoSettingEx,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    XBackendsErrors::NoSettingEx *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<XBackendsErrors::NoSettingEx>::insert (
      _tao_any,
      XBackendsErrors::NoSettingEx::_tao_any_destructor,
      XBackendsErrors::_tc_NoSettingEx,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    XBackendsErrors::NoSettingEx *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const XBackendsErrors::NoSettingEx *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const XBackendsErrors::NoSettingEx *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<XBackendsErrors::NoSettingEx>::extract (
        _tao_any,
        XBackendsErrors::NoSettingEx::_tao_any_destructor,
        XBackendsErrors::_tc_NoSettingEx,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_exception/cdr_op_cs.cpp:60
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const XBackendsErrors::XBackendsErrorsEx &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.errorTrace)
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    XBackendsErrors::XBackendsErrorsEx &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.errorTrace)
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_exception/cdr_op_cs.cpp:60
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const XBackendsErrors::NoSettingEx &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.errorTrace)
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    XBackendsErrors::NoSettingEx &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.errorTrace)
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL



