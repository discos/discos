\chapter{Receiver Control Library}

\section{Introduzione}
La \texttt{ReceiverControl} library definisce una interfaccia di alto livello
tramite la quale comunicare con il ricevitore. Poich\`e, come \`e stato detto, su ogni ricevitore
vengono installate due schede (una per il controllo del dewar\index{dewar} ed un'altra
per alimentare gli LNA\index{LNA} e leggerne i valori di $V_D$, $I_D$ e $V_G$), un oggetto \texttt{ReceiverControl}
istanzier\`a due \texttt{MicroControllerBoard}; questo come tutti gli altri dettagli di basso livello
sar\`a trasparente per l'utilizzatore della classe.

La libreria inoltre \`e \emph{thread-safe}\index{thread safe} in quanto per comunicare con 
le schede si appoggia alla \texttt{MicroControllerBoard}
(come detto nel capitolo precedente, la \texttt{MicroControllerBoard} \`e thread-safe).


\section{Interfaccia}
L'interfaccia della classe espone una serie di metodi che consentono di avere un completo controllo
del ricevitore. 

\subsection{Il Costruttore}
Nel listato~\ref{lst:costruttore}, mostrato di seguito, \`e riportata la dichiarazione del \emph{costruttore}\index{costruttore} 
della classe \texttt{ReceiverControl}.
\lstset{language=C++}
\lstset{numbers=left,numberstyle={\scriptsize},stepnumber=1,firstnumber=1,numbersep=10pt}
\begin{lstlisting}[caption={[Dichiarazione del costruttore di \texttt{ReceiverControl}]
Dichiarazione del costruttore della classe \texttt{ReceiverControl}},
label=lst:costruttore,mathescape]
ReceiverControl(
        const std::string dewar_ip,
        const unsigned short dewar_port, 
        const std::string lna_ip, 
        const unsigned short lna_port, 
        const unsigned short number_of_feeds=1,
        const BYTE dewar_madd=0x7C, // Dewar board master address
        const BYTE dewar_sadd=0x7D, // Dewar board slave address
        const BYTE lna_madd=0x7C,   // LNA board master address
        const BYTE lna_sadd=0x7D,   // LNA board slave address
        bool reliable_comm=true,
        const unsigned int guard_time=250000  // 0.25 seconds
) throw (ReceiverControlEx);
\end{lstlisting}
\lstset{numbers=none}
I parametri hanno il seguente significato:
\begin{itemize}
\item \texttt{dewar\_ip}\index{parametri costruttore!dewar IP}: l'indirizzo IP della scheda per il controllo del dewar;
\item \texttt{dewar\_port}\index{parametri costruttore!dewar port}: la porta utilizzata nella 
connessione verso la scheda per il controllo del dewar;
\item \texttt{lna\_ip}\index{parametri costruttore!LNA IP}: l'indirizzo IP della scheda per il controllo degli LNA;
\item \texttt{lna\_port}\index{parametri costruttore!LNA port}: la porta utilizzata nella 
connessione verso la scheda per il controllo degli LNA;
\item \texttt{number\_of\_feeds}\index{parametri costruttore!numero di feeds}: numero di feed del ricevitore (1 di default);
\item \texttt{dewar\_maddr}\index{parametri costruttore!dewar master address}: l'indirizzo del master della
scheda del dewar (il valore di default \`e 0x7D);
\item \texttt{dewar\_saddr}\index{parametri costruttore!dewar slave address} l'indirizzo dello slave della 
scheda del dewar (il valore di default \`e 0x7F)
\item \texttt{lna\_maddr}\index{parametri costruttore!LNA master address}: l'indirizzo del master della 
scheda degli LNA (il valore di default \`e 0x7D);
\item \texttt{lna\_saddr}\index{parametri costruttore!LNA slave address}: l'indirizzo dello slave della 
scheda degli LNA (il valore di default \`e 0x7F)
\item \texttt{reliable\_comm}\index{parametri costruttore!reliable communication}: 
quando vale  \texttt{true} allora la comunicazione con le schede avviene
con controllo degli errori (checksum)\index{checksum}. Di default \`e \texttt{true};
\item \texttt{guard\_time}\index{parametri costruttore!tempo di guardia}\index{tempo di guardia}: 
quando viene fatta una richiesta di lettura dei dati alla scheda degli LNA,
dobbiamo aspettare un certo lasso di tempo prima di leggere il dato richiesto, in modo tale che le
uscite si stabilizzino. Questo tempo non deve essere inferiore ai 200ms ed \`e impostabile tramite questo
parametro.
\end{itemize}
    
\subsection{Il metodo \texttt{fetValues}}
Il metodo \texttt{fetValues}\index{metodo!fetValues} restituisce la struttura \texttt{FetValues} di un LNA
per un dato stadio e per un dato feed. La struttura \`e definita di seguito:
\lstset{language=C++}
\lstset{numbers=left,numberstyle={\scriptsize},stepnumber=1,firstnumber=1,numbersep=10pt}
\begin{lstlisting}[mathescape]
struct FetValues {
    double VDL; // Drain Voltage, left channel  [V]
    double IDL; // Drain Current, left channel  [mA]
    double VGL; // Gate Voltage, left channel   [V]
    double VDR; // Drain Voltage, right channel [V]
    double IDR; // Drain Current, right channel [mA]
    double VGR; // Gate Voltage, right channel  [V]
};
\end{lstlisting}
\lstset{numbers=none}
Per poter restiture la struttura~\texttt{FetValues} dobbiamo quindi passare al metodo \texttt{fetValues} i seguenti
parametri: 
\begin{itemize}
\item il codice identificativo del feed;
\item il numero dello stadio;
\item un puntatore alla funzione di conversione che, a partire dal valore
in tensione letto, lo converte in un valore di corrente (IDL e IDR);
\item un puntatore alla funzione 
che converte il valore letto nel corretto valore di tensione (VDL, VGL, VDR, VGR).
\end{itemize}
\lstset{language=C++}
\lstset{numbers=left,numberstyle={\scriptsize},stepnumber=1,firstnumber=1,numbersep=10pt}
\begin{lstlisting}[caption={Dichiarazione del metodo \texttt{fetValues}},
label=lst:fetValues,mathescape]
/** return the FetValues (VDL, IDL, VGR, VDR, IDR and VGR) 
 *  of the LNA of the feed `feed_number` and stage `stage_number`. 
 *  The letter L means that the value is referred to the left 
 *  channel, the R if for the right one.
 *  @param feed_number the ID code of the feed (from 0 to 15)
 *  @param stage_number the stage number (from 1 to 5)
 *  @param currentConverter pointer to the function that performs 
 *  the conversion from voltage to mA; default value is NULL, 
 *  and in this case the value of ID is the voltage value (the 
 *  value before conversion).
 *  @param voltageConverter pointer to the function that performs 
 *  the conversion from voltage to voltage; default value is NULL, 
 *  and in this case the values of VD and VG are the voltage values 
 *  before the conversion.
 *  @return the low cryogenic temperature in Kelvin if 
 *  converter != NULL, the value in voltage (before conversion) 
 *  otherwise.
 *  @return the FetValues, a struct of three double members: 
 *  VD [V], ID [mA] and VG [V] after the conversion if the 
 *  function pointers are not NULL, the values before conversion 
 *  (voltage) if the pointers are NULL.
 *  @throw ReceiverControlEx
 */
FetValues fetValues(
        unsigned short feed_number, 
        unsigned short stage_number,
        double (*currentConverter)(double voltage) = NULL,
        double (*voltageConverter)(double voltage) = NULL
) throw (ReceiverControlEx);
\end{lstlisting}
\lstset{numbers=none}


\subsection{Il metodo \texttt{stageValues}}
Il metodo \texttt{stageValues}\index{metodo!stageValues} prende come parametri: un elemento \texttt{FetValue} (ovvero
\texttt{DRAIN\_VOLTAGE}\index{drain voltage}, \texttt{DRAIN\_CURRENT}\index{drain current} o 
\texttt{GATE\_VOLTAGE}\index{gate voltage}), lo stadio
di amplificazione (un intero compreso tra~1 e~5), un puntatore ad una funzione che effettua
la conversione del valore letto nel corrispondente valore di tensione o corrente, a seconda
della grandezza richiesta (primo parametro).

Il tipo restituito \`e uno \texttt{StageValues}:
\lstset{language=C++}
\lstset{numbers=left,numberstyle={\scriptsize},stepnumber=1,firstnumber=1,numbersep=10pt}
\begin{lstlisting}[mathescape]
/**
 * The left_channel member stores all the left channel values of a
 * specific fet quantity (VD, ID or VG), and the right one stores 
 * the values for the right channel.
 */
struct StageValues {
    std::vector<double> left_channel;
    std::vector<double> right_channel;
};
\end{lstlisting}
\lstset{numbers=none}
Il membro \texttt{left\_channel} \`e un vettore che ha come elementi i valori della grandezza richiesta (il
primo parametro del metodo), per lo stadio di amplificazione richiesto, ordinati per feed;
il primo elemento del vettore \`e quindi riferito al primo feed, il secondo elemento al 
secondo feed e cos\`i via. Stessa cosa per quanto riguarda il vettore \texttt{right\_channel}.
Per poter recuperare questi valori, sulla base di quanto descritto in~\ref{sec:lna-section}, dobbiamo fare un 
numero di richeste \texttt{GET\_DATA} che dipende solo dal numero di feed\footnote{Nel caso del 
ricevitore 22GHz multi-beem ad esempio, avendo questo~7 feed dovremo fare~2 richieste \texttt{GET\_DATA},
poich\`e sono 2 le colonne da leggere, come si evince dallo schema di figura~\ref{fig:AD24}.}.
\lstset{language=C++}
\lstset{numbers=left,numberstyle={\scriptsize},stepnumber=1,firstnumber=1,numbersep=10pt}
\begin{lstlisting}[caption={Dichiarazione del metodo \texttt{stageValues}},
label=lst:stageValues,mathescape]
/** Return for each feed and channel the fet quantity value of 
 *  a given stage. For instance, if you want to get the VD values 
 *  of all the feeds related to the amplifier stage N, you must 
 *  call the method like so: stageValues(DRAIN_VOLTAGE, N).
 *
 *  @param quantity a FetValue: DRAIN_VOLTAGE, DRAIN_CURRENT 
 *  or GATE_CURRENT 
 *  @param stage_number the stage number (from 1 to 5)
 *  @param converter pointer to the function that performs the 
 *  conversion from voltage to the right unit or just with a 
 *  scale factor; default value is NULL, and in this case the 
 *  value returned is without conversion.
 *  @return the StageValues for a given fet ``quantity`` and 
 *  ``stage_number``. The StageValues is a struct of two 
 *  members std::vector<double>, one member for the left 
 *  channel and one for the right one. That members contain 
 *  the related quantities of all the feeds; that means each
 *  item of the std::vector<double> is the quantity value of 
 *  a feed, for the stage requested.
 *  @throw ReceiverControlEx
 */
 StageValues stageValues(
         FetValue quantity, 
         unsigned short stage_number, 
         double (*converter)(double voltage)=NULL
) throw (ReceiverControlEx);
\end{lstlisting}
\lstset{numbers=none}


\subsection{Il metodo \texttt{turnLeftLNAsOn}}
Il metodo \texttt{turnLeftLNAsOn}\index{metodo!turnLeftLNAsOn} accende tutti gli LNA dei canali left.
\lstset{language=C++}
\lstset{numbers=left,numberstyle={\scriptsize},stepnumber=1,firstnumber=1,numbersep=10pt}
\begin{lstlisting}[caption={Dichiarazione del metodo \texttt{turnLeftLNAsOn}},
label=lst:turnLeftLNAsOn,mathescape]
/** Turn the LNAs of the left channels ON
 *  @param data_type the type of the data; the default is 1 bit
 *  @param port_type the port type; the default is the Digital IO
 *  @param port_number the port number; the default is 08
 *  @param value the value to set; the default value is 0x00
 *  @throw ReceiverControlEx
 */
void turnLeftLNAsOn(
        const BYTE data_type=MCB_CMD_DATA_TYPE_B01,
        const BYTE port_type=MCB_PORT_TYPE_DIO,
        const BYTE port_number=MCB_PORT_NUMBER_08,
        const BYTE value=0x00
) throw (ReceiverControlEx);
\end{lstlisting}
\lstset{numbers=none}


\subsection{Il metodo \texttt{turnLeftLNAsOff}}
Il metodo \texttt{turnLeftLNAsOff}\index{metodo!turnLeftLNAsOff} spegne tutti gli LNA dei canali left.
\lstset{language=C++}
\lstset{numbers=left,numberstyle={\scriptsize},stepnumber=1,firstnumber=1,numbersep=10pt}
\begin{lstlisting}[caption={Dichiarazione del metodo \texttt{turnLeftLNAsOff}},
label=lst:turnLeftLNAsOff,mathescape]
/** Turn the LNAs of the left channels OFF
 *  @param data_type the type of the data; the default is 1 bit
 *  @param port_type the port type; the default is the Digital IO
 *  @param port_number the port number; the default port number is 08
 *  @param value the value to set; the default value is 0x01
 *  @throw ReceiverControlEx
 */
void turnLeftLNAsOff(
        const BYTE data_type=MCB_CMD_DATA_TYPE_B01,
        const BYTE port_type=MCB_PORT_TYPE_DIO,
        const BYTE port_number=MCB_PORT_NUMBER_08,
        const BYTE value=0x01
) throw (ReceiverControlEx);
\end{lstlisting}
\lstset{numbers=none}


\subsection{Il metodo \texttt{turnRightLNAsOn}}
Il metodo \texttt{turnRightLNAsOn}\index{metodo!turnRightLNAsOn} accende tutti gli LNA dei canali right.
\lstset{language=C++}
\lstset{numbers=left,numberstyle={\scriptsize},stepnumber=1,firstnumber=1,numbersep=10pt}
\begin{lstlisting}[caption={Dichiarazione del metodo \texttt{turnRightLNAsOn}},
label=lst:turnRightLNAsOn,mathescape]
/** Turn the LNAs of the right channels ON
 *  @param data_type the type of the data; the default is 1 bit
 *  @param port_type the port type; the default is the Digital IO
 *  @param port_number the port number; the default is 09
 *  @param value the value to set; the default value is 0x00
 *  @throw ReceiverControlEx
 */
void turnRightLNAsOn(
        const BYTE data_type=MCB_CMD_DATA_TYPE_B01,
        const BYTE port_type=MCB_PORT_TYPE_DIO,
        const BYTE port_number=MCB_PORT_NUMBER_09,
        const BYTE value=0x00 
) throw (ReceiverControlEx);
\end{lstlisting}
\lstset{numbers=none}


\subsection{Il metodo \texttt{turnRightLNAsOff}}
Il metodo \texttt{turnRightLNAsOff}\index{metodo!turnRightLNAsOff} spegne tutti gli LNA dei canali right.
\lstset{language=C++}
\lstset{numbers=left,numberstyle={\scriptsize},stepnumber=1,firstnumber=1,numbersep=10pt}
\begin{lstlisting}[caption={Dichiarazione del metodo \texttt{turnRightLNAsOff}},
label=lst:turnRightLNAsOff,mathescape]
/** Turn the LNAs of the right channels OFF
 *  @param data_type the type of the data; the default is 1 bit
 *  @param port_type the port type; the default is the Digital IO
 *  @param port_number the port number; the default is 09
 *  @param value the value to set; the default value is 0x01
 *  @throw ReceiverControlEx
 */
void turnRightLNAsOff(
        const BYTE data_type=MCB_CMD_DATA_TYPE_B01,
        const BYTE port_type=MCB_PORT_TYPE_DIO,
        const BYTE port_number=MCB_PORT_NUMBER_09,
        const BYTE value=0x01
) throw (ReceiverControlEx);
\end{lstlisting}
\lstset{numbers=none}

\subsection{Il metodo \texttt{setCalibrationOn}}
Il metodo \texttt{setCalibrationOn}\index{metodo!setCalibrationOn} avvia la calibrazione del ricevitore mediante 
una marca di rumore.
\lstset{language=C++}
\lstset{numbers=left,numberstyle={\scriptsize},stepnumber=1,firstnumber=1,numbersep=10pt}
\begin{lstlisting}[caption={Dichiarazione del metodo \texttt{setCalibrationOn}},
label=lst:setCalibrationOn,mathescape]
/** Set the noise mark generator to ON 
 *  @param data_type the type of the data; the default is 1 bit
 *  @param port_type the port type; the default is the Digital IO
 *  @param port_number the port number; the default is 11
 *  @param value the value to set; the default value is 0x01
 *  @throw ReceiverControlEx
 */
void setCalibrationOn(
        const BYTE data_type=MCB_CMD_DATA_TYPE_B01, 
        const BYTE port_type=MCB_PORT_TYPE_DIO, 
        const BYTE port_number=MCB_PORT_NUMBER_11, 
        const BYTE value=0x01
) throw (ReceiverControlEx);
\end{lstlisting}
\lstset{numbers=none}


\subsection{Il metodo \texttt{setCalibrationOff}}
Il metodo \texttt{setCalibrationOff}\index{metodo!setCalibrationOff} ferma la calibrazione del ricevitore.
\lstset{language=C++}
\lstset{numbers=left,numberstyle={\scriptsize},stepnumber=1,firstnumber=1,numbersep=10pt}
\begin{lstlisting}[caption={Dichiarazione del metodo \texttt{setCalibrationOff}},
label=lst:setCalibrationOff,mathescape]
/** Set the noise mark generator to OFF
 *  @param data_type the type of the data; the default is 1 bit
 *  @param port_type the port type; the default is the Digital IO
 *  @param port_number the port number; the default is 11
 *  @param value the value to set; the default value is 0x00
 *  @throw ReceiverControlEx
 */
void setCalibrationOff(
        const BYTE data_type=MCB_CMD_DATA_TYPE_B01, 
        const BYTE port_type=MCB_PORT_TYPE_DIO, 
        const BYTE port_number=MCB_PORT_NUMBER_11, 
        const BYTE value=0x00
) throw (ReceiverControlEx);
\end{lstlisting}
\lstset{numbers=none}


\subsection{Il metodo \texttt{isCalibrationOn}}
Il metodo \texttt{isCalibrationOn}\index{metodo!isCalibrationOn} restituisce \texttt{true} se la calibrazione del 
ricevitore \`e attiva.
\lstset{language=C++}
\lstset{numbers=left,numberstyle={\scriptsize},stepnumber=1,firstnumber=1,numbersep=10pt}
\begin{lstlisting}[caption={Dichiarazione del metodo \texttt{isCalibrationOn}},
label=lst:isCalibrationOn,mathescape]
/** Is the noise mark generator set to ON?
 *  @param data_type the type of the data; the default is 1 bit
 *  @param port_type the port type; the default is the Digital IO
 *  @param port_number the port number; the default is 11
 *  @return true if the noise mark generator is set to ON
 *  @throw ReceiverControlEx
 */
bool isCalibrationOn(
        const BYTE data_type=MCB_CMD_DATA_TYPE_B01, 
        const BYTE port_type=MCB_PORT_TYPE_DIO, 
        const BYTE port_number=MCB_PORT_NUMBER_11
) throw (ReceiverControlEx);
\end{lstlisting}
\lstset{numbers=none}


\subsection{Il metodo \texttt{setExtCalibrationOn}}
Il metodo \texttt{setExtCalibrationOn}\index{metodo!setExtCalibrationOn} abilita il comando esterno per la calibrazione.
ricevitore \`e attiva.
\lstset{language=C++}
\lstset{numbers=left,numberstyle={\scriptsize},stepnumber=1,firstnumber=1,numbersep=10pt}
\begin{lstlisting}[caption={Dichiarazione del metodo \texttt{setExtCalibrationOn}},
label=lst:setExtCalibrationOn,mathescape]
/** Enable the external noise mark generator synchronous command
 *  @param data_type the type of the data; the default is 1 bit
 *  @param port_type the port type; the default is the Digital IO
 *  @param port_number the port number; the default is 12
 *  @param value the value to set; the default value is 0x01
 *  @throw ReceiverControlEx
 */
void setExtCalibrationOn(
        const BYTE data_type=MCB_CMD_DATA_TYPE_B01, 
        const BYTE port_type=MCB_PORT_TYPE_DIO, 
        const BYTE port_number=MCB_PORT_NUMBER_12, 
        const BYTE value=0x01
) throw (ReceiverControlEx);
\end{lstlisting}
\lstset{numbers=none}


\subsection{Il metodo \texttt{setExtCalibrationOff}}
Il metodo \texttt{setExtCalibrationOff}\index{metodo!setExtCalibrationOff} disabilita il comando esterno per fermare la calibrazione.
\lstset{language=C++}
\lstset{numbers=left,numberstyle={\scriptsize},stepnumber=1,firstnumber=1,numbersep=10pt}
\begin{lstlisting}[caption={Dichiarazione del metodo \texttt{setExtCalibrationOff}},
label=lst:setExtCalibrationOff,mathescape]
/** Disable the external noise mark generator synchronous command
 *  @param data_type the type of the data; the default is 1 bit
 *  @param port_type the port type; the default is the Digital IO
 *  @param port_number the port number; the default is 12
 *  @param value the value to set; the default value is 0x00
 *  @throw ReceiverControlEx
 */
void setExtCalibrationOff(
        const BYTE data_type=MCB_CMD_DATA_TYPE_B01, 
        const BYTE port_type=MCB_PORT_TYPE_DIO, 
        const BYTE port_number=MCB_PORT_NUMBER_12, 
        const BYTE value=0x00
) throw (ReceiverControlEx);
\end{lstlisting}
\lstset{numbers=none}


\subsection{Il metodo \texttt{isExtCalibrationOn}}
Il metodo \texttt{isExtCalibrationOn}\index{metodo!isExtCalibrationOn} restituisce \texttt{true} se il comando esterno 
per avviare la calibrazione \`e abilitato.
\lstset{language=C++}
\lstset{numbers=left,numberstyle={\scriptsize},stepnumber=1,firstnumber=1,numbersep=10pt}
\begin{lstlisting}[caption={Dichiarazione del metodo \texttt{isExtCalibrationOn}},
label=lst:isExtCalibrationOn,mathescape]
/** Is the external noise mark generator command enabled?
 *  @param data_type the type of the data; the default is 1 bit
 *  @param port_type the port type; the default is the Digital IO
 *  @param port_number the port number; the default is 12
 *  @return true if the external noise mark generator command 
 *  is enabled
 *  @throw ReceiverControlEx
 */
bool isExtCalibrationOn(
        const BYTE data_type=MCB_CMD_DATA_TYPE_B01, 
        const BYTE port_type=MCB_PORT_TYPE_DIO, 
        const BYTE port_number=MCB_PORT_NUMBER_12
) throw (ReceiverControlEx);
\end{lstlisting}
\lstset{numbers=none}


\subsection{Il metodo \texttt{setReliableCommOn}}
Il metodo \texttt{setReliableCommOn}\index{metodo!setReliableCommOn} attiva la comunicazione con 
controllo degli errori (checksum)\index{checksum}.
\lstset{language=C++}
\lstset{numbers=left,numberstyle={\scriptsize},stepnumber=1,firstnumber=1,numbersep=10pt}
\begin{lstlisting}[caption={Dichiarazione del metodo \texttt{setReliableCommOn}},
label=lst:setReliableCommOn,mathescape]
/** Set the reliable communication to/from the board to ON */
void setReliableCommOn() { m_reliable_comm = true; }
\end{lstlisting}
\lstset{numbers=none}


\subsection{Il metodo \texttt{setReliableCommOff}}
Il metodo \texttt{setReliableCommOff}\index{metodo!setReliableCommOff} disattiva la 
comunicazione con controllo degli errori (nessun checksum)\index{checksum}.
\lstset{language=C++}
\lstset{numbers=left,numberstyle={\scriptsize},stepnumber=1,firstnumber=1,numbersep=10pt}
\begin{lstlisting}[caption={Dichiarazione del metodo \texttt{setReliableCommOff}},
label=lst:setReliableCommOff,mathescape]
/** Set the reliable communication to/from the board to OFF */
void setReliableCommOff() { m_reliable_comm = false; }
\end{lstlisting}
\lstset{numbers=none}


\subsection{Il metodo \texttt{isReliableCommOn}\index{metodo!isReliableCommOn}}
\lstset{language=C++}
\lstset{numbers=left,numberstyle={\scriptsize},stepnumber=1,firstnumber=1,numbersep=10pt}
\begin{lstlisting}[caption={Dichiarazione del metodo \texttt{isReliableCommOn}},
label=lst:isReliableCommOn,mathescape]
/** return true if the communication to the board is 
 *  set to be reliable 
 */
bool isReliableCommOn() { return m_reliable_comm; }
\end{lstlisting}
\lstset{numbers=none}


\subsection{Il metodo \texttt{vacuum}}
Il metodo \texttt{vacuum}\index{vacuum}\index{metodo!vacuum} restituisce la pressione\index{pressione} 
(in $mbar$) all'interno del dewar.
\lstset{language=C++}
\lstset{numbers=left,numberstyle={\scriptsize},stepnumber=1,firstnumber=1,numbersep=10pt}
\begin{lstlisting}[caption={Dichiarazione del metodo \texttt{vacuum}},
label=lst:vacuum,mathescape]
/** Return the vacuum value inside the dewar in mbar
 *
 *  @param converter pointer to the function that performs 
 *  the conversion from voltage to vacumm unit [mbar]; 
 *  default value is NULL, and in this case the value
 *  returned by vacuum is the voltage value (the value 
 *  before conversion).
 *  @param data_type the type of the data; the default 
 *  type is a 32 bit floating point
 *  @param port_type the port type; the default is the AD24
 *  @param port_number the port number; the default value 
 *  is a range of port numbers from 8 to 15.
 *  @param raw_index the index that allows to get the vacuum 
 *  value from the port_number range.
 *  The default value is 2.
 *  @return the vacuum inside the dewar in mbar if 
 *  converter != NULL, the value before conversion otherwise.
 *  @throw ReceiverControlEx
 */
double vacuum(
        double (*converter)(double voltage)=NULL,
        const BYTE data_type=MCB_CMD_DATA_TYPE_F32,     
        const BYTE port_type=MCB_PORT_TYPE_AD24,       
        const BYTE port_number=MCB_PORT_NUMBER_00_07,  
        const size_t raw_index=2                      
) throw (ReceiverControlEx);
\end{lstlisting}
\lstset{numbers=none}


\subsection{Il metodo \texttt{vertexTemperature}\index{metodo!vacuum}\index{temperatura!vertex}\index{vertex}}
\lstset{language=C++}
\lstset{numbers=left,numberstyle={\scriptsize},stepnumber=1,firstnumber=1,numbersep=10pt}
\begin{lstlisting}[caption={Dichiarazione del metodo \texttt{vertexTemperature}},
label=lst:vertexTemperature,mathescape]
/** Return the vertex temperature in K
 *  @param converter pointer to the function that 
 *  performs the conversion from voltage to Kelvin; 
 *  default value is NULL, and in this case the value
 *  returned by vertexTemperature is the voltage value 
 *  (the value before conversion).
 *  @param data_type the type of the data; the default 
 *  type is a 32 bit floating point
 *  @param port_type the port type; the default is the AD24
 *  @param port_number the port number; the default value 
 *  is a range of port numbers from 8 to 15.
 *  @param raw_index the index that allows to get the 
 *  vertex temperature value from the port_number range. 
 *  The default value is 6.
 *  @return the vertex temperature in Kelvin if 
 *  converter != NULL, the value before conversion otherwise.
 *  @throw ReceiverControlEx
 */
double vertexTemperature(
        double (*converter)(double voltage)=NULL,
        const BYTE data_type=MCB_CMD_DATA_TYPE_F32,     
        const BYTE port_type=MCB_PORT_TYPE_AD24,       
        const BYTE port_number=MCB_PORT_NUMBER_00_07,  
        const size_t raw_index=6                      
) throw (ReceiverControlEx);
\end{lstlisting}
\lstset{numbers=none}


\subsection{Il metodo \texttt{cryoTemperature}\index{metodo!cryoTemperature}}
\lstset{language=C++}
\lstset{numbers=left,numberstyle={\scriptsize},stepnumber=1,firstnumber=1,numbersep=10pt}
\begin{lstlisting}[caption={Dichiarazione del metodo \texttt{cryoTemperature}},
label=lst:cryoTemperature,mathescape]
/** Return the cryogenic temperature
 *  @param temperature_id the id code of the 
 *  temperature (1, 2, 3 or 4)
 *  @param converter pointer to the function 
 *  that performs the conversion from
 *  voltage to Kelvin; default value is NULL,
 *  and in this case the value returned by 
 *  cryoTemperature is the voltage value (the 
 *  value before conversion).
 *  @param data_type the type of the data; the 
 *  default type is a 32 bit floating point
 *  @param port_type the port type; the default is the AD24
 *  @param port_number the port number; the default value 
 *  is a range of port numbers from 8 to 15.
 *  @return the cryogenic temperature in Kelvin if 
 *  converter != NULL, the value in voltage (before 
 *  conversion) otherwise.
 *  @throw ReceiverControlEx
 */
double cryoTemperature(
        const short temperature_id,
        double (*converter)(double voltage)=NULL,
        const BYTE data_type=MCB_CMD_DATA_TYPE_F32,
        const BYTE port_type=MCB_PORT_TYPE_AD24,  
        const BYTE port_number=MCB_PORT_NUMBER_00_07
) throw (ReceiverControlEx);
\end{lstlisting}
\lstset{numbers=none}


\subsection{Il metodo \texttt{setCoolHeadOn}\index{metodo!setCoolHeadOn}\index{cool head}}
\lstset{language=C++}
\lstset{numbers=left,numberstyle={\scriptsize},stepnumber=1,firstnumber=1,numbersep=10pt}
\begin{lstlisting}[caption={Dichiarazione del metodo \texttt{setCoolHeadOn}},
label=lst:setCoolHeadOn,mathescape]
/** Set to ON the cool head 
 *  @param data_type the type of the data; the default is 1 bit
 *  @param port_type the port type; the default is the Digital IO
 *  @param port_number the port number; the default is 08
 *  @param value the value to set; the default value is 0x01
 *  @throw ReceiverControlEx
 */
void setCoolHeadOn(
        const BYTE data_type=MCB_CMD_DATA_TYPE_B01,
        const BYTE port_type=MCB_PORT_TYPE_DIO,   
        const BYTE port_number=MCB_PORT_NUMBER_08,
        const BYTE value=0x01
) throw (ReceiverControlEx);
\end{lstlisting}
\lstset{numbers=none}


\subsection{Il metodo \texttt{setCoolHeadOff}\index{metodo!setCoolHeadOff}}
\lstset{language=C++}
\lstset{numbers=left,numberstyle={\scriptsize},stepnumber=1,firstnumber=1,numbersep=10pt}
\begin{lstlisting}[caption={Dichiarazione del metodo \texttt{setCoolHeadOff}},
label=lst:setCoolHeadOff,mathescape]
/** Set to OFF the cool head 
 *  @param data_type the type of the data; the default is 1 bit
 *  @param port_type the port type; the default is the Digital IO
 *  @param port_number the port number; the default is 08
 *  @param value the value to set; the default value is 0x00
 *  @throw ReceiverControlEx
 */
void setCoolHeadOff(
        const BYTE data_type=MCB_CMD_DATA_TYPE_B01,
        const BYTE port_type=MCB_PORT_TYPE_DIO,   
        const BYTE port_number=MCB_PORT_NUMBER_08,
        const BYTE value=0x00
) throw (ReceiverControlEx);
\end{lstlisting}
\lstset{numbers=none}


\subsection{Il metodo \texttt{isCoolHeadOn}\index{metodo!isCoolHeadOn}}
\lstset{language=C++}
\lstset{numbers=left,numberstyle={\scriptsize},stepnumber=1,firstnumber=1,numbersep=10pt}
\begin{lstlisting}[caption={Dichiarazione del metodo \texttt{isCoolHeadOn}},
label=lst:isCoolHeadOn,mathescape]
/** Is the cool head ON?
 *  @param data_type the type of the data; the default is 1 bit
 *  @param port_type the port type; the default is the Digital IO
 *  @param port_number the port number; the default number is 08
 *  @return true if the cool head is ON
 *  @throw ReceiverControlEx
 */
bool isCoolHeadOn(
        const BYTE data_type=MCB_CMD_DATA_TYPE_B01,
        const BYTE port_type=MCB_PORT_TYPE_DIO,   
        const BYTE port_number=MCB_PORT_NUMBER_08
) throw (ReceiverControlEx);
\end{lstlisting}
\lstset{numbers=none}


\subsection{Il metodo \texttt{setVacuumSensorOn}\index{metodo!setVacuumSensorOn}}
Il metodo \texttt{setVacuumSensorOn} attiva il sensore di pressione\index{pressione}.
\lstset{language=C++}
\lstset{numbers=left,numberstyle={\scriptsize},stepnumber=1,firstnumber=1,numbersep=10pt}
\begin{lstlisting}[caption={Dichiarazione del metodo \texttt{setVacuumSensorOn}},
label=lst:setVacuumSensorOn,mathescape]
/** Set to ON the vacuum sensor
 *  @param data_type the type of the data; the default is 1 bit
 *  @param port_type the port type; the default is the Digital IO
 *  @param port_number the port number; the default is 04
 *  @param value the value to set; the default value is 0x01
 *  @throw ReceiverControlEx
 */
void setVacuumSensorOn(
        const BYTE data_type=MCB_CMD_DATA_TYPE_B01,
        const BYTE port_type=MCB_PORT_TYPE_DIO,
        const BYTE port_number=MCB_PORT_NUMBER_04,
        const BYTE value=0x01
) throw (ReceiverControlEx);
\end{lstlisting}
\lstset{numbers=none}


\subsection{Il metodo \texttt{setVacuumSensorOff}\index{metodo!setVacuumSensorOff}}
Il metodo \texttt{setVacuumSensorOff} disattiva il sensore di pressione\index{pressione}.
\lstset{language=C++}
\lstset{numbers=left,numberstyle={\scriptsize},stepnumber=1,firstnumber=1,numbersep=10pt}
\begin{lstlisting}[caption={Dichiarazione del metodo \texttt{setVacuumSensorOff}},
label=lst:setVacuumSensorOff,mathescape]
/** Set to OFF the vacuum sensor
 *  @param data_type the type of the data; the default is 1 bit
 *  @param port_type the port type; the default is the Digital IO
 *  @param port_number the port number; the default is 04
 *  @param value the value to set; the default value is 0x00
 *  @throw ReceiverControlEx
 */
void setVacuumSensorOff(
        const BYTE data_type=MCB_CMD_DATA_TYPE_B01,
        const BYTE port_type=MCB_PORT_TYPE_DIO,
        const BYTE port_number=MCB_PORT_NUMBER_04,
        const BYTE value=0x00
) throw (ReceiverControlEx);
\end{lstlisting}
\lstset{numbers=none}


\subsection{Il metodo \texttt{isVacuumSensorOn}}
Il metodo \texttt{isVacuumSensorOn}\index{metodo!isVacuumSensorOn} restituisce true se il sensore di pressione\index{pressione}
\`e attivo.
\lstset{language=C++}
\lstset{numbers=left,numberstyle={\scriptsize},stepnumber=1,firstnumber=1,numbersep=10pt}
\begin{lstlisting}[caption={Dichiarazione del metodo \texttt{isVacuumSensorOn}},
label=lst:isVacuumSensorOn,mathescape]
/** Is the vacuum sensor ON?
 *  @param data_type the type of the data; the default is 1 bit
 *  @param port_type the port type; the default is the Digital IO
 *  @param port_number the port number; the default is 04
 *  @return true if the vacuum sensor is ON 
 *  @throw ReceiverControlEx
 */
bool isVacuumSensorOn(
        const BYTE data_type=MCB_CMD_DATA_TYPE_B01,
        const BYTE port_type=MCB_PORT_TYPE_DIO,
        const BYTE port_number=MCB_PORT_NUMBER_04
) throw (ReceiverControlEx);
\end{lstlisting}
\lstset{numbers=none}


\subsection{Il metodo \texttt{setVacuumPumpOn}}
Il metodo \texttt{setVacuumPumpOn}\index{metodo!setVacuumPumpOn} attiva la \emph{pompa a vuoto}\index{pompa a vuoto}.
\lstset{language=C++}
\lstset{numbers=left,numberstyle={\scriptsize},stepnumber=1,firstnumber=1,numbersep=10pt}
\begin{lstlisting}[caption={Dichiarazione del metodo \texttt{setVacuumPumpOn}},
label=lst:setVacuumPumpOn,mathescape]
/** Set to ON the vacuum pump
 *  @param data_type the type of the data; the default is 1 bit
 *  @param port_type the port type; the default is the Digital IO
 *  @param port_number the port number; the default is 05
 *  @param value the value to set; the default value is 0x01
 *  @throw ReceiverControlEx
 */
void setVacuumPumpOn(
        const BYTE data_type=MCB_CMD_DATA_TYPE_B01,
        const BYTE port_type=MCB_PORT_TYPE_DIO,
        const BYTE port_number=MCB_PORT_NUMBER_05,
        const BYTE value=0x01
) throw (ReceiverControlEx);
\end{lstlisting}
\lstset{numbers=none}


\subsection{Il metodo \texttt{setVacuumPumpOff}}
Il metodo \texttt{setVacuumPumpOff}\index{metodo!setVacuumPumpOff} disattiva la pompa a vuoto.
\lstset{language=C++}
\lstset{numbers=left,numberstyle={\scriptsize},stepnumber=1,firstnumber=1,numbersep=10pt}
\begin{lstlisting}[caption={Dichiarazione del metodo \texttt{setVacuumPumpOff}},
label=lst:setVacuumPumpOff,mathescape]
/** Set to OFF the vacuum pump
 *  @param data_type the type of the data; the default is 1 bit
 *  @param port_type the port type; the default is the Digital IO
 *  @param port_number the port number; the default is 05
 *  @param value the value to set; the default value is 0x00
 *  @throw ReceiverControlEx
 */
void setVacuumPumpOff(
        const BYTE data_type=MCB_CMD_DATA_TYPE_B01,
        const BYTE port_type=MCB_PORT_TYPE_DIO,
        const BYTE port_number=MCB_PORT_NUMBER_05,
        const BYTE value=0x00
) throw (ReceiverControlEx);
\end{lstlisting}
\lstset{numbers=none}


\subsection{Il metodo \texttt{isVacuumPumpOn}}
Il metodo \texttt{isVacuumPumpOn}\index{metodo!isVacuumPumpOn} restituisce \texttt{true} se la pompa a vuoto \`e in funzione.
\lstset{language=C++}
\lstset{numbers=left,numberstyle={\scriptsize},stepnumber=1,firstnumber=1,numbersep=10pt}
\begin{lstlisting}[caption={Dichiarazione del metodo \texttt{isVacuumPumpOn}},
label=lst:isVacuumPumpOn,mathescape]
/** Is the vacuum pump ON?
 *  @param data_type the type of the data; the default is 1 bit
 *  @param port_type the port type; the default is the Digital IO
 *  @param port_number the port number; the default is 05
 *  @return true if the vacuum pump is ON
 *  @throw ReceiverControlEx
 */
bool isVacuumPumpOn(
        const BYTE data_type=MCB_CMD_DATA_TYPE_B01,
        const BYTE port_type=MCB_PORT_TYPE_DIO,
        const BYTE port_number=MCB_PORT_NUMBER_05
) throw (ReceiverControlEx);
\end{lstlisting}
\lstset{numbers=none}


\subsection{Il metodo \texttt{hasVacuumPumpFault}}
Il metodo \texttt{hasVacuumPumpFault}\index{metodo!hasVacuumPumpFault} restituisce \texttt{true} se la pompa ha
qualche malfunzionamento\index{pompa a vuoto}.
\lstset{language=C++}
\lstset{numbers=left,numberstyle={\scriptsize},stepnumber=1,firstnumber=1,numbersep=10pt}
\begin{lstlisting}[caption={Dichiarazione del metodo \texttt{hasVacuumPumpFault}},
label=lst:hasVacuumPumpFault,mathescape]
/** Has the vacuum pump a fault?
 *  @param data_type the type of the data; the default is 1 bit
 *  @param port_type the port type; the default is the Digital IO
 *  @param port_number the port number; the default is 06
 *  @return true if the vacuum pump has a fault
 *  @throw ReceiverControlEx
 */
bool hasVacuumPumpFault(
        const BYTE data_type=MCB_CMD_DATA_TYPE_B01,
        const BYTE port_type=MCB_PORT_TYPE_DIO,
        const BYTE port_number=MCB_PORT_NUMBER_06
) throw (ReceiverControlEx);
\end{lstlisting}
\lstset{numbers=none}


\subsection{Il metodo \texttt{setVacuumValveOn}}
Il metodo \texttt{setVacuumValveOn}\index{metodo!hasVacuumValveOn} apre la valvola di pressione\index{valvola di pressione}.
\lstset{language=C++}
\lstset{numbers=left,numberstyle={\scriptsize},stepnumber=1,firstnumber=1,numbersep=10pt}
\begin{lstlisting}[caption={Dichiarazione del metodo \texttt{setVacuumValveOn}},
label=lst:setVacuumValveOn,mathescape]
/** Set to ON the vacuum valve
 *  @param data_type the type of the data; the default is 1 bit
 *  @param port_type the port type; the default is the Digital IO
 *  @param port_number the port number; the default is 07
 *  @param value the value to set; the default value is 0x01
 *  @throw ReceiverControlEx
 */
void setVacuumValveOn(
        const BYTE data_type=MCB_CMD_DATA_TYPE_B01,
        const BYTE port_type=MCB_PORT_TYPE_DIO,
        const BYTE port_number=MCB_PORT_NUMBER_07,
        const BYTE value=0x01
) throw (ReceiverControlEx);
\end{lstlisting}
\lstset{numbers=none}


\subsection{Il metodo \texttt{setVacuumValveOff}}
Il metodo \texttt{setVacuumValveOff}\index{metodo!setVacuumValveOff} chiude la valvola di pressione\index{valvola di pressione}.
\lstset{language=C++}
\lstset{numbers=left,numberstyle={\scriptsize},stepnumber=1,firstnumber=1,numbersep=10pt}
\begin{lstlisting}[caption={Dichiarazione del metodo \texttt{setVacuumValveOff}},
label=lst:setVacuumValveOff,mathescape]
/** Set to OFF the vacuum valve
 *  @param data_type the type of the data; the default is 1 bit
 *  @param port_type the port type; the default is the Digital IO
 *  @param port_number the port number; the default is 07
 *  @param value the value to set; the default value is 0x00
 *  @throw ReceiverControlEx
 */
void setVacuumValveOff(
        const BYTE data_type=MCB_CMD_DATA_TYPE_B01,
        const BYTE port_type=MCB_PORT_TYPE_DIO,
        const BYTE port_number=MCB_PORT_NUMBER_07,
        const BYTE value=0x00
) throw (ReceiverControlEx);
\end{lstlisting}
\lstset{numbers=none}


\subsection{Il metodo \texttt{isVacuumValveOn}}
Il metodo \texttt{isVacuumValveOn}\index{metodo!isVacuumValveOn} restituisce \texttt{true} se la 
valvola di pressione\index{valvola di pressione} \`e aperta.
\lstset{language=C++}
\lstset{numbers=left,numberstyle={\scriptsize},stepnumber=1,firstnumber=1,numbersep=10pt}
\begin{lstlisting}[caption={Dichiarazione del metodo \texttt{isVacuumValveOn}},
label=lst:isVacuumValveOn,mathescape]
/** Is the vacuum valve ON?
 *  @param data_type the type of the data; the default is 1 bit
 *  @param port_type the port type; the default is the Digital IO
 *  @param port_number the port number; the default is 07
 *  @return true if the vacuum valve is ON
 *  @throw ReceiverControlEx
 */
bool isVacuumValveOn(
        const BYTE data_type=MCB_CMD_DATA_TYPE_B01,
        const BYTE port_type=MCB_PORT_TYPE_DIO,
        const BYTE port_number=MCB_PORT_NUMBER_07
) throw (ReceiverControlEx);
\end{lstlisting}
\lstset{numbers=none}


\subsection{Il metodo \texttt{isRemoteOn}}
Il metodo \texttt{isRemoteOn}\index{metodo!isRemoteOn} restituisce \texttt{true} se il comando remoto \`e abilitato.
\lstset{language=C++}
\lstset{numbers=left,numberstyle={\scriptsize},stepnumber=1,firstnumber=1,numbersep=10pt}
\begin{lstlisting}[caption={Dichiarazione del metodo \texttt{isRemoteOn}},
label=lst:isRemoteOn,mathescape]
/** Is the remote command enable?
 *  @param data_type the type of the data; the default is 1 bit
 *  @param port_type the port type; the default is the Digital IO
 *  @param port_number the port number; the default is 26
 *  @return true if the remote command is enable
 *  @throw ReceiverControlEx
 */
bool isRemoteOn(
        const BYTE data_type=MCB_CMD_DATA_TYPE_B01,
        const BYTE port_type=MCB_PORT_TYPE_DIO,
        const BYTE port_number=MCB_PORT_NUMBER_26
) throw (ReceiverControlEx);
\end{lstlisting}
\lstset{numbers=none}


\subsection{Il metodo \texttt{selectLO1}}
Il metodo \texttt{selectLO1}\index{metodo!selectLO1} seleziona l'oscillatore locale\index{oscillatore locale} numero~1.
\lstset{language=C++}
\lstset{numbers=left,numberstyle={\scriptsize},stepnumber=1,firstnumber=1,numbersep=10pt}
\begin{lstlisting}[caption={Dichiarazione del metodo \texttt{selectLO1}},
label=lst:selectLO1,mathescape]
/** Select the first local oscillator (LO1)
 *  @param data_type the type of the data; the default is 1 bit
 *  @param port_type the port type; the default is the Digital IO
 *  @param port_number the port number; the default is 0
 *  @param value the value to set; the default value is 0x00
 *  @throw ReceiverControlEx
 */
void selectLO1(
        const BYTE data_type=MCB_CMD_DATA_TYPE_B01,
        const BYTE port_type=MCB_PORT_TYPE_DIO,
        const BYTE port_number=MCB_PORT_NUMBER_00,
        const BYTE value=0x00
) throw (ReceiverControlEx);
\end{lstlisting}
\lstset{numbers=none}


\subsection{Il metodo \texttt{isLO1Selected}}
Il metodo \texttt{isLO1Selected}\index{metodo!isLO1Selected} restituisce \texttt{true} se 
l'oscillatore locale\index{oscillatore locale} numero~1 \`e selezionato.
\lstset{language=C++}
\lstset{numbers=left,numberstyle={\scriptsize},stepnumber=1,firstnumber=1,numbersep=10pt}
\begin{lstlisting}[caption={Dichiarazione del metodo \texttt{isLO1Selected}},
label=lst:isLO1Selected,mathescape]
/** Is LO1 selected?
 *  @param data_type the type of the data; the default is 1 bit
 *  @param port_type the port type; the default is the Digital IO
 *  @param port_number the port number; the default is 16
 *  @return true if the first local oscillator (LO1) is selected
 *  @throw ReceiverControlEx
 */
bool isLO1Selected(
        const BYTE data_type=MCB_CMD_DATA_TYPE_B01,
        const BYTE port_type=MCB_PORT_TYPE_DIO,   
        const BYTE port_number=MCB_PORT_NUMBER_16
) throw (ReceiverControlEx);
\end{lstlisting}
\lstset{numbers=none}


\subsection{Il metodo \texttt{selectLO2}}
Il metodo \texttt{selectLO2}\index{metodo!selectLO2} seleziona l'oscillatore locale\index{oscillatore locale} numero~2.
\lstset{language=C++}
\lstset{numbers=left,numberstyle={\scriptsize},stepnumber=1,firstnumber=1,numbersep=10pt}
\begin{lstlisting}[caption={Dichiarazione del metodo \texttt{selectLO2}},
label=lst:selectLO2,mathescape]
/** Select the second local oscillator (LO2)
 *  @param data_type the type of the data; the default is 1 bit
 *  @param port_type the port type; the default is the Digital IO
 *  @param port_number the port number; the default is 0
 *  @param value the value to set; the default value is 0x01
 *  @throw ReceiverControlEx
 */
void selectLO2(
        const BYTE data_type=MCB_CMD_DATA_TYPE_B01,
        const BYTE port_type=MCB_PORT_TYPE_DIO,
        const BYTE port_number=MCB_PORT_NUMBER_00,
        const BYTE value=0x01
) throw (ReceiverControlEx);
\end{lstlisting}
\lstset{numbers=none}


\subsection{Il metodo \texttt{isLO2Selected}}
Il metodo \texttt{isLO2Selected}\index{metodo!isLO2Selected} restituisce \texttt{true} se l'oscillatore 
locale\index{oscillatore locale} numero~2 \`e selezionato.
\lstset{language=C++}
\lstset{numbers=left,numberstyle={\scriptsize},stepnumber=1,firstnumber=1,numbersep=10pt}
\begin{lstlisting}[caption={Dichiarazione del metodo \texttt{isLO2Selected}},
label=lst:isLO2Selected,mathescape]
/** Is LO2 selected?
 *  @param data_type the type of the data; the default is 1 bit
 *  @param port_type the port type; the default is the Digital IO
 *  @param port_number the port number; the default is 17
 *  @return true if the second local oscillator (LO2) is selected
 *  @throw ReceiverControlEx
 */
bool isLO2Selected(
        const BYTE data_type=MCB_CMD_DATA_TYPE_B01,
        const BYTE port_type=MCB_PORT_TYPE_DIO, 
        const BYTE port_number=MCB_PORT_NUMBER_17
) throw (ReceiverControlEx);
\end{lstlisting}
\lstset{numbers=none}


\subsection{Il metodo \texttt{isLO2Locked}}
Il metodo \texttt{isLO2Locked}\index{metodo!isLO2Locked} restituisce \texttt{true} se l'oscillatore 
locale\index{oscillatore locale} numero~2 \`e \emph{locked}.
\lstset{language=C++}
\lstset{numbers=left,numberstyle={\scriptsize},stepnumber=1,firstnumber=1,numbersep=10pt}
\begin{lstlisting}[caption={Dichiarazione del metodo \texttt{isLO2Locked}},
label=lst:isLO2Locked,mathescape]
/** Is LO2 locked?
 *  @param data_type the type of the data; the default is 1 bit
 *  @param port_type the port type; the default is the Digital IO
 *  @param port_number the port number; the default is 18
 *  @return true if the second local oscillator (LO2) is locked
 *  @throw ReceiverControlEx
 */
bool isLO2Locked(
        const BYTE data_type=MCB_CMD_DATA_TYPE_B01,
        const BYTE port_type=MCB_PORT_TYPE_DIO, 
        const BYTE port_number=MCB_PORT_NUMBER_18
) throw (ReceiverControlEx);
\end{lstlisting}
\lstset{numbers=none}


\subsection{Il metodo \texttt{setSingleDishMode}}
Il metodo \texttt{setSingleDishMode}\index{metodo!setSingleDishMode} imposta la 
\emph{modalit\`a operativa}\index{modalit\`a operativa}\index{modalit\`a operativa!single dish} del 
ricevitore su \emph{single dish}\index{single dish} (quando
un ricevitore prevede questa modalit\`a).
\lstset{language=C++}
\lstset{numbers=left,numberstyle={\scriptsize},stepnumber=1,firstnumber=1,numbersep=10pt}
\begin{lstlisting}[caption={Dichiarazione del metodo \texttt{setSingleDishMode}},
label=lst:setSingleDishMode,mathescape]
/** Set the single dish mode to ON. The VLBI mode will be turn OFF
 *  @param data_type the type of the data; the default is 1 bit
 *  @param port_type the port type; the default is the Digital IO
 *  @param port_number_sd the port number of the single dish mode; 
 *  the default port number is 0x13
 *  @param port_number_vlbi the port number of the VLBI mode; 
 *  the default port number is 0x14
 *  @param value_sd the value to turn the single dish mode ON; 
 *  default value is 0x00
 *  @param value_vlbi the value to turn the VLBI mode OFF; 
 *  default value is 0x01
 *  @throw ReceiverControlEx
 */
void setSingleDishMode(
        const BYTE data_type=MCB_CMD_DATA_TYPE_B01,
        const BYTE port_type=MCB_PORT_TYPE_DIO,
        const BYTE port_number_sd=MCB_PORT_NUMBER_13,
        const BYTE port_number_vlbi=MCB_PORT_NUMBER_14,
        const BYTE value_sd=0x00,
        const BYTE value_vlbi=0x01
) throw (ReceiverControlEx);
\end{lstlisting}
\lstset{numbers=none}


\subsection{Il metodo \texttt{isSingleDishModeOn}}
Il metodo \texttt{isSingleDishModeOn}\index{metodo!isSingleDishModeOn} restituisce \texttt{true} se il ricevitore
si trova nella modalit\`a operativa\index{modalit\`a operativa!single dish} signle dish\index{single dish}.
\lstset{language=C++}
\lstset{numbers=left,numberstyle={\scriptsize},stepnumber=1,firstnumber=1,numbersep=10pt}
\begin{lstlisting}[caption={Dichiarazione del metodo \texttt{isSingleDishModeOn}},
label=lst:isSingleDishModeOn,mathescape]
/** Is the single dish mode set to ON?
 *  @param data_type the type of the data; the default is 1 bit
 *  @param port_type the port type; the default is the Digital IO
 *  @param port_number the port number; the default is 29
 *  @return true if the single dish mode is active
 *  @throw ReceiverControlEx
 */
bool isSingleDishModeOn(
        const BYTE data_type=MCB_CMD_DATA_TYPE_B01,
        const BYTE port_type=MCB_PORT_TYPE_DIO, 
        const BYTE port_number=MCB_PORT_NUMBER_29
) throw (ReceiverControlEx);
\end{lstlisting}
\lstset{numbers=none}


\subsection{Il metodo \texttt{setVLBIMode}}
Il metodo \texttt{setVLBIMode}\index{metodo!setVLBIOn} imposta la modalit\`a operativa del ricevitore su 
VLBI\index{VLBI}\index{modalit\`a operativa!VLBI} (quando
un ricevitore prevede questa modalit\`a).
\lstset{language=C++}
\lstset{numbers=left,numberstyle={\scriptsize},stepnumber=1,firstnumber=1,numbersep=10pt}
\begin{lstlisting}[caption={Dichiarazione del metodo \texttt{setVLBIMode}},
label=lst:setVLBIMode,mathescape]
/** Set the VLBI mode to ON. The SD mode will be turn OFF
 *  @param data_type the type of the data; the default is 1 bit
 *  @param port_type the port type; the default is the Digital IO
 *  @param port_number_vlbi the of the VLBI mode; 
 *  the default port number is 0x14
 *  @param port_number_sd the port number of the single dish mode; 
 *  the default port number is 0x13
 *  @param value_vlbi the value to turn the VLBI mode ON; default
 *  value is 0x00
 *  @param value_sd the value to turn the single dish mode OFF; 
 *  default value is 0x01
 *  @throw ReceiverControlEx
 */
void setVLBIMode(
        const BYTE data_type=MCB_CMD_DATA_TYPE_B01,
        const BYTE port_type=MCB_PORT_TYPE_DIO,
        const BYTE port_number_vlbi=MCB_PORT_NUMBER_14,
        const BYTE port_number_sd=MCB_PORT_NUMBER_13,
        const BYTE value_vlbi=0x00,
        const BYTE value_sd=0x01
) throw (ReceiverControlEx);
\end{lstlisting}
\lstset{numbers=none}


\subsection{Il metodo \texttt{isVLBIModeOn}}
Il metodo \texttt{isVLBIModeOn}\index{metodo!isVLBIModeOn} restituisce \texttt{true} se il ricevitore
si trova nella modalit\`a operativa\index{modalit\`a operativa!VLBI} VLBI.
\lstset{language=C++}
\lstset{numbers=left,numberstyle={\scriptsize},stepnumber=1,firstnumber=1,numbersep=10pt}
\begin{lstlisting}[caption={Dichiarazione del metodo \texttt{isVLBIModeOn}},
label=lst:isVLBIModeOn,mathescape]
/** Is the VLBI mode set to ON?
 *  @param data_type the type of the data; the default is 1 bit
 *  @param port_type the port type; the default is the Digital IO
 *  @param port_number the port number; the default is 30
 *  @return true if the VLBI mode is active
 *  @throw ReceiverControlEx
 */
bool isVLBIModeOn(
        const BYTE data_type=MCB_CMD_DATA_TYPE_B01,
        const BYTE port_type=MCB_PORT_TYPE_DIO,
        const BYTE port_number=MCB_PORT_NUMBER_30
) throw (ReceiverControlEx);
\end{lstlisting}
\lstset{numbers=none}



\subsection{Il metodo \texttt{numberOfFeeds}}
Il metodo \texttt{numberOfFeeds}\index{metodo!numberOfFeeds} restituisce il numero di feeds del ricevitore.
\lstset{language=C++}
\lstset{numbers=left,numberstyle={\scriptsize},stepnumber=1,firstnumber=1,numbersep=10pt}
\begin{lstlisting}[caption={Dichiarazione del metodo \texttt{numberOfFeeds}},
label=lst:number_of_feeds,mathescape]
/** Return the number of feeds of the receiver */
unsigned short numberOfFeeds() { return m_number_of_feeds; }
\end{lstlisting}
\lstset{numbers=none}


\subsection{Il metodo \texttt{openConnection}\index{metodo!openConnection}}
\lstset{language=C++}
\lstset{numbers=left,numberstyle={\scriptsize},stepnumber=1,firstnumber=1,numbersep=10pt}
\begin{lstlisting}[caption={Dichiarazione del metodo \texttt{openConnection}},
label=lst:openConnection,mathescape]
/** Perform a TCP connection socket to the boards
 *  @throw ReceiverControlEx
 */
void openConnection(void) throw (ReceiverControlEx);
\end{lstlisting}
\lstset{numbers=none}


\subsection{Il metodo \texttt{closeConnection}\index{metodo!closeConnection}}
\lstset{language=C++}
\lstset{numbers=left,numberstyle={\scriptsize},stepnumber=1,firstnumber=1,numbersep=10pt}
\begin{lstlisting}[caption={Dichiarazione del metodo \texttt{closeConnection}},
label=lst:closeConnection,mathescape]
/** Close the TCP connection sockets to the boards */
void closeConnection(void);
\end{lstlisting}
\lstset{numbers=none}


\subsection{Il metodo \texttt{isLNABoardConnectionOK}\index{metodo!isLNABoardConnectionOK}}
\lstset{language=C++}
\lstset{numbers=left,numberstyle={\scriptsize},stepnumber=1,firstnumber=1,numbersep=10pt}
\begin{lstlisting}[caption={Dichiarazione del metodo \texttt{isLNABoardConnectionOK}},
label=lst:isLNABoardConnectionOK,mathescape]
/** Is the connection to the LNA board OK?
 *  @return true if the connection to the LNA board is OK
 */
bool isLNABoardConnectionOK();
\end{lstlisting}
\lstset{numbers=none}


\subsection{Il metodo \texttt{isDewarBoardConnectionOK}\index{metodo!isDewarBoardConnectionOK}}
\lstset{language=C++}
\lstset{numbers=left,numberstyle={\scriptsize},stepnumber=1,firstnumber=1,numbersep=10pt}
\begin{lstlisting}[caption={Dichiarazione del metodo \texttt{isDewarBoardConnectionOK}},
label=lst:isDewarBoardConnectionOK,mathescape]
/** Is the connection to the dewar board OK?
 *  @return true if the connection to the dewar board is OK
 */
bool isDewarBoardConnectionOK();
\end{lstlisting}
\lstset{numbers=none}


\section{Utilizzo della Libreria}
La libreria \texttt{ReceiverControl} \`e dipendente da \texttt{MicroControllerBoard}
ed \`e composta dalla sola classe \texttt{ReceiverControl} dichiarata e definita rispettivamente
in \emph{ReceiverControl.h} e \emph{ReceiverControl.cpp}.

Nel listato~\ref{lst:receiver-library} \`e illustrato un breve esempio di utilizzo della
libreria.
\lstset{language=C++}
\lstset{numbers=left,numberstyle={\scriptsize},stepnumber=1,firstnumber=1,numbersep=10pt}
\begin{lstlisting}[caption={[Esempio di utilizzo della libreria \texttt{ReceiverLibrary}]Esempio 
di utilizzo della libreria \texttt{ReceiverLibrary}},
label=lst:receiver-library,mathescape]
#include "ReceiverControl.h"
#include <cstdlib>

using namespace IRA;

// Funzioni di conversione utilizzate solo a titolo esemplificativo:
// Converte un valore di tensione in temperatura (Kelvin)
double voltage2Kelvin(double voltage) { return voltage * 2 }
// Converte un valore di tensione in un valore di corrente (mA)
double currentConverter(double voltage) { return(10 * voltage); }
// Converte i valore di tensione nei corretti valori di VD e VG
double voltageConverter(double voltage) { return(voltage); }
// Converte il valore di tensione in un valore di pressione (mbar)
double voltage2mbar(double voltage) { 
    return(pow(10, 1.5 * voltage - 12)); 
}

int main()
{
    // Definiamo i parametri IP e porta da passare al costruttore
    std::string dewar_IP("192.168.51.63"); // IP della scheda dewar
    unsigned int dewar_port = 5002; // Porta della scheda dewar
    std::string lna_IP("192.168.51.64"); // IP della scheda LNA
    unsigned int lna_port = 5002; // Porta della scheda LNA
    // Definiamo il numero di feed del ricevitore
    unsigned short feeds = 2; 

    try {
        // Istanziamo l'oggetto ReceiverControl
        ReceiverControl rc = ReceiverControl(
            dewar_IP, 
            dewar_port, 
            lna_IP, 
            lna_port, 
            feeds
        );
    
        // Avvia la calibrazione (con checksum per default)
        rc.setCalibrationOn();
        cout << "Il generatore della marca di rumore e' attivo? " \
             << (rc.isCalibrationOn() == true ? "si" : "no") << endl;

        // Disabilita il controllo errori (nessun checksum)
        rc.setReliableCommOff();

        // Valore della pressione prima della conversione
        cout << "Valore in Volt: " << rc.vacuum() << endl;
        // Valore della pression dopo la conversione
        cout << "In mbar: " << rc.vacuum(voltage2mbar) << endl;

        // Temperatura della vertex prima della conversione
        cout << rc.vertexTemperature() << endl;

        // Temperature criogeniche
        cout << "Valore della prima temperatura criogenica: " \
             << rc.cryoTemperature(1, voltage2Kelvin) << endl;
        cout << "Valore della seconda temperatura criogenica: " \
             << rc.cryoTemperature(2, voltage2Kelvin) << endl;

        // Accendi gli LNA dei canali left
        rc.turnLeftLNAsOn();

        // Leggi i FetValues
        ReceiverControl::FetValues values = \
            rc.fetValues(0, 4, currentConverter, voltageConverter);

        // Leggi gli StageValues
        ReceiverControl::StageValues svalues = rc.stageValues(
            ReceiverControl::DRAIN_VOLTAGE,
            4,
            voltageConverter
        );

        // Imposta la modalita' operativa VLBI
        rc.setVLBIMode();
        cout << "La modalita' operativa VLBI e' attiva? " \
             << (rc.isVLBIModeOn() == true ? "si" : "no") << endl;

        rc.closeConnection(); // Chiudi la connessione
    }
    catch(ReceiverControlEx& ex) {
        cout << ex.what() << endl;
        return 1;
    }
    return 0;
}
\end{lstlisting}
\lstset{numbers=none}

