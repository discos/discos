/******************************************************************************** $Id: JacPrep,v 1.12 2005/04/05 13:29:24 mzampare Exp $
* DO NOT EDIT
* Automatically generated from ../idl/XBackends.midl
* on Fri Oct 17 17:13:16 2014
*******************************************************************************/
#ifndef _XBackends_midl_
#define _XBackends_midl_
#ifndef _ACS_PREPROCESSED_
#define _ACS_PREPROCESSED_
#endif
#include <baci.idl>
#include <enumpropMACRO.idl> 
#include "GenericBackend.idl"

#pragma prefix "alma"

module Backends {

 enum TXArcosConf {
  XArcos_K77,
  XArcos_K01,
  XArcos_K04,
        XArcos_K00,
  XArcos_C00
 };

 typedef sequence<TXArcosConf> TXArcosConfSeq; interface CBTXArcosConf : ACS::Callback { oneway void working(in TXArcosConf value, in ACSErr::Completion c, in ACS::CBDescOut desc); oneway void done(in TXArcosConf value, in ACSErr::Completion c, in ACS::CBDescOut desc); };
typedef CBTXArcosConf TXArcosConfCB; interface AlarmTXArcosConf : ACS::Callback { oneway void alarm_raised(in TXArcosConf value, in ACSErr::Completion c, in ACS::CBDescOut desc); oneway void alarm_cleared(in TXArcosConf value, in ACSErr::Completion c, in ACS::CBDescOut desc); };
 typedef AlarmTXArcosConf TXArcosConfAlarm; interface PTXArcosConf: ACS::TypelessProperty { TXArcosConf get_sync(out ACSErr::Completion c); void get_async(in ACS::CBpattern cb, in ACS::CBDescIn desc); long get_history(in long n_last_values, out TXArcosConfSeq vs, out ACS::TimeSeq ts); ACS::Monitorpattern create_monitor(in ACS::CBpattern cb, in ACS::CBDescIn desc); ACS::Monitor create_postponed_monitor (in ACS::Time start_time, in ACS::CBpattern cb, in ACS::CBDescIn desc); readonly attribute ACS::TimeInterval default_timer_trigger; readonly attribute ACS::TimeInterval min_timer_trigger; readonly attribute TXArcosConf default_value; readonly attribute ACS::stringSeq statesDescription; readonly attribute ACS::ConditionSeq condition; readonly attribute TXArcosConfSeq allStates; };
 interface ROTXArcosConf: PTXArcosConf{ ACS::Subscription new_subscription_AlarmEnum(in ACS::Alarmpattern cb, in ACS::CBDescIn desc); readonly attribute TXArcosConfSeq alarm_on; readonly attribute TXArcosConfSeq alarm_off; };
 interface RWTXArcosConf: PTXArcosConf { ACSErr::Completion set_sync(in TXArcosConf value); void set_async(in TXArcosConf value, in ACS::CBvoid cb, in ACS::CBDescIn desc); void set_nonblocking(in TXArcosConf value);};


 interface XBackends : GenericBackend {



  readonly attribute Management::ROTBoolean mode8bit;

  void setInputsNumber(in long inputsNumber) raises (ComponentErrors::ComponentErrorsEx,BackendsErrors::BackendsErrorsEx);
  void setSectionsNumber(in long SectionsNumber) raises (ComponentErrors::ComponentErrorsEx,BackendsErrors::BackendsErrorsEx);
  void visualSpecific()raises (ComponentErrors::ComponentErrorsEx,BackendsErrors::BackendsErrorsEx);
  void visualData()raises (ComponentErrors::ComponentErrorsEx,BackendsErrors::BackendsErrorsEx);
  void visualACS()raises (ComponentErrors::ComponentErrorsEx,BackendsErrors::BackendsErrorsEx);
  void setMode8bit(in boolean mode)raises (ComponentErrors::ComponentErrorsEx,BackendsErrors::BackendsErrorsEx);
  void setXarcosConf(in Backends::TXArcosConf conf) raises (ComponentErrors::ComponentErrorsEx,BackendsErrors::BackendsErrorsEx);
 };


};

#endif
