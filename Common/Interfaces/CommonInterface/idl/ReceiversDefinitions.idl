/******************************************************************************** $Id: JacPrep,v 1.12 2005/04/05 13:29:24 mzampare Exp $
* DO NOT EDIT
* Automatically generated from ../idl/ReceiversDefinitions.midl
* on Wed Nov 12 19:24:55 2014
*******************************************************************************/
#ifndef _ReceiversDefinitions_midl_
#define _ReceiversDefinitions_midl_
#ifndef _ACS_PREPROCESSED_
#define _ACS_PREPROCESSED_
#endif
#include <baci.idl>
#include <enumpropMACRO.idl>

#pragma prefix "alma"
module Receivers {


 enum TPolarization {
  RCV_LCP,
  RCV_RCP,
  RCV_VLP,
  RCV_HLP
 };

 typedef sequence<TPolarization> TPolarizationSeq; interface CBTPolarization : ACS::Callback { oneway void working(in TPolarization value, in ACSErr::Completion c, in ACS::CBDescOut desc); oneway void done(in TPolarization value, in ACSErr::Completion c, in ACS::CBDescOut desc); };
typedef CBTPolarization TPolarizationCB; interface AlarmTPolarization : ACS::Callback { oneway void alarm_raised(in TPolarization value, in ACSErr::Completion c, in ACS::CBDescOut desc); oneway void alarm_cleared(in TPolarization value, in ACSErr::Completion c, in ACS::CBDescOut desc); };
 typedef AlarmTPolarization TPolarizationAlarm; interface PTPolarization: ACS::TypelessProperty { TPolarization get_sync(out ACSErr::Completion c); void get_async(in ACS::CBpattern cb, in ACS::CBDescIn desc); long get_history(in long n_last_values, out TPolarizationSeq vs, out ACS::TimeSeq ts); ACS::Monitorpattern create_monitor(in ACS::CBpattern cb, in ACS::CBDescIn desc); ACS::Monitor create_postponed_monitor (in ACS::Time start_time, in ACS::CBpattern cb, in ACS::CBDescIn desc); readonly attribute ACS::TimeInterval default_timer_trigger; readonly attribute ACS::TimeInterval min_timer_trigger; readonly attribute TPolarization default_value; readonly attribute ACS::stringSeq statesDescription; readonly attribute ACS::ConditionSeq condition; readonly attribute TPolarizationSeq allStates; };
 interface ROTPolarization: PTPolarization{ ACS::Subscription new_subscription_AlarmEnum(in ACS::Alarmpattern cb, in ACS::CBDescIn desc); readonly attribute TPolarizationSeq alarm_on; readonly attribute TPolarizationSeq alarm_off; };
 interface RWTPolarization: PTPolarization { ACSErr::Completion set_sync(in TPolarization value); void set_async(in TPolarization value, in ACS::CBvoid cb, in ACS::CBDescIn desc); void set_nonblocking(in TPolarization value);};



    struct TPosition {
        double x;
        double y;
    };





    enum TRewindModes {
     RCV_AUTO_REWIND,
     RCV_MANUAL_REWIND,
     RCV_UNDEF_REWIND
    };


    typedef sequence<TRewindModes> TRewindModesSeq; interface CBTRewindModes : ACS::Callback { oneway void working(in TRewindModes value, in ACSErr::Completion c, in ACS::CBDescOut desc); oneway void done(in TRewindModes value, in ACSErr::Completion c, in ACS::CBDescOut desc); };
typedef CBTRewindModes TRewindModesCB; interface AlarmTRewindModes : ACS::Callback { oneway void alarm_raised(in TRewindModes value, in ACSErr::Completion c, in ACS::CBDescOut desc); oneway void alarm_cleared(in TRewindModes value, in ACSErr::Completion c, in ACS::CBDescOut desc); };
 typedef AlarmTRewindModes TRewindModesAlarm; interface PTRewindModes: ACS::TypelessProperty { TRewindModes get_sync(out ACSErr::Completion c); void get_async(in ACS::CBpattern cb, in ACS::CBDescIn desc); long get_history(in long n_last_values, out TRewindModesSeq vs, out ACS::TimeSeq ts); ACS::Monitorpattern create_monitor(in ACS::CBpattern cb, in ACS::CBDescIn desc); ACS::Monitor create_postponed_monitor (in ACS::Time start_time, in ACS::CBpattern cb, in ACS::CBDescIn desc); readonly attribute ACS::TimeInterval default_timer_trigger; readonly attribute ACS::TimeInterval min_timer_trigger; readonly attribute TRewindModes default_value; readonly attribute ACS::stringSeq statesDescription; readonly attribute ACS::ConditionSeq condition; readonly attribute TRewindModesSeq allStates; };
 interface ROTRewindModes: PTRewindModes{ ACS::Subscription new_subscription_AlarmEnum(in ACS::Alarmpattern cb, in ACS::CBDescIn desc); readonly attribute TRewindModesSeq alarm_on; readonly attribute TRewindModesSeq alarm_off; };
 interface RWTRewindModes: PTRewindModes { ACSErr::Completion set_sync(in TRewindModes value); void set_async(in TRewindModes value, in ACS::CBvoid cb, in ACS::CBDescIn desc); void set_nonblocking(in TRewindModes value);};





    enum TDerotatorConfigurations {
     RCV_FIXED_DEROTCONF,
     RCV_BSC_DEROTCONF,
     RCV_OPTIMIZED_DEROTCONF,
     RCV_ALIGNED_DEROTCONF,
     RCV_CUSTOM_DEROTCONF,
     RCV_UNDEF_DEROTCONF
    };


    typedef sequence<TDerotatorConfigurations> TDerotatorConfigurationsSeq; interface CBTDerotatorConfigurations : ACS::Callback { oneway void working(in TDerotatorConfigurations value, in ACSErr::Completion c, in ACS::CBDescOut desc); oneway void done(in TDerotatorConfigurations value, in ACSErr::Completion c, in ACS::CBDescOut desc); };
typedef CBTDerotatorConfigurations TDerotatorConfigurationsCB; interface AlarmTDerotatorConfigurations : ACS::Callback { oneway void alarm_raised(in TDerotatorConfigurations value, in ACSErr::Completion c, in ACS::CBDescOut desc); oneway void alarm_cleared(in TDerotatorConfigurations value, in ACSErr::Completion c, in ACS::CBDescOut desc); };
 typedef AlarmTDerotatorConfigurations TDerotatorConfigurationsAlarm; interface PTDerotatorConfigurations: ACS::TypelessProperty { TDerotatorConfigurations get_sync(out ACSErr::Completion c); void get_async(in ACS::CBpattern cb, in ACS::CBDescIn desc); long get_history(in long n_last_values, out TDerotatorConfigurationsSeq vs, out ACS::TimeSeq ts); ACS::Monitorpattern create_monitor(in ACS::CBpattern cb, in ACS::CBDescIn desc); ACS::Monitor create_postponed_monitor (in ACS::Time start_time, in ACS::CBpattern cb, in ACS::CBDescIn desc); readonly attribute ACS::TimeInterval default_timer_trigger; readonly attribute ACS::TimeInterval min_timer_trigger; readonly attribute TDerotatorConfigurations default_value; readonly attribute ACS::stringSeq statesDescription; readonly attribute ACS::ConditionSeq condition; readonly attribute TDerotatorConfigurationsSeq allStates; };
 interface ROTDerotatorConfigurations: PTDerotatorConfigurations{ ACS::Subscription new_subscription_AlarmEnum(in ACS::Alarmpattern cb, in ACS::CBDescIn desc); readonly attribute TDerotatorConfigurationsSeq alarm_on; readonly attribute TDerotatorConfigurationsSeq alarm_off; };
 interface RWTDerotatorConfigurations: PTDerotatorConfigurations { ACSErr::Completion set_sync(in TDerotatorConfigurations value); void set_async(in TDerotatorConfigurations value, in ACS::CBvoid cb, in ACS::CBDescIn desc); void set_nonblocking(in TDerotatorConfigurations value);};





 typedef struct RunTime {



  ACS::Time startEpoch;



  boolean onTheFly;
 } TRunTimeParameters;

};

#endif
