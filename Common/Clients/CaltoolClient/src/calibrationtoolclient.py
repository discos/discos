#! /usr/bin/env python
from Acspy.Clients.SimpleClient import PySimpleClient
import Acspy.Common.Err
import maciErrType
import maciErrTypeImpl
import ClientErrorsImpl 
import ACSLog


import ACS, ACS__POA                                  # Import the Python CORBA stubs for BACI
from PyQt4 import Qt
from PyQt4.QtCore import   pyqtSlot,QThread,QMutex,QTimer
import PyQt4.Qwt5 as Qwt
import sys,getopt
from time import sleep
import math 



import calibrationtool_ui # file generated by pyuic4 but modified to include 
		          #custom widgets.
			  
__version__ = '$Id'


'''
@version $Id$
'''


class MyWorker(QThread):
	def __init__(self,component,parent=None):
		self.Mutex =QMutex()
		QThread.__init__(self,parent)
		self.caltool=component[0]
                self.scheduler=component[1]
                self.boss     =component[2]
                self.simpleClient=component[3]
	        self.run=True;
                self.arrayDataY=self.caltool._get_arrayDataY()
		self.arrayDataX=self.caltool._get_arrayDataX()
                self.dataX=self.caltool._get_dataX()
                self.dataY=self.caltool._get_dataY()
 #               self.datax_tmp=[0 for i in len(self_data)]
                self.datay_tmp=[]
                self.datax_tmp=[]
                self.projectname=self.caltool._get_projectName()
                self.observer   =self.caltool._get_observer()
                self.filename   =self.caltool._get_fileName()
                self.deviceID   =self.caltool._get_deviceID()
                self.subscan    =self.scheduler._get_subScanID()
                self.scan       =self.scheduler._get_scanID()
                self.hpbw       =self.caltool._get_hpbw()
                self.amplitude  =self.caltool._get_amplitude()
                self.peakOffset  =self.caltool._get_peakOffset()
                self.slope       =self.caltool._get_slope()
                self.offset       =self.caltool._get_offset()
                self.name        =self.boss._get_target()
                self.device      =self.caltool._get_deviceID()
                self.oldscan=0L
                self.newscan=0L
                self.oldsubscan=0L
                self.newsubscan=0L
                self.oldrecordingstatus=False
                self.newrecordingstatus=False
                
                
                
        def run (self):
              try:
        	
#	           arrayDataX=self.componenselft._get_arrayDataX()
#        	   arrayDataY=self.component._get_arrayDataY()
	           while self.run:
 
        		(arraydatax,compl)=self.arrayDataX.get_sync()		
                        arraydatax[:]=[x /math.pi*180. for x in arraydatax]

	         	self.emit(Qt.SIGNAL("arrayDataX"),arraydatax)
                        (arraydatay,compl2)=self.arrayDataY.get_sync()
                        
                        self.emit(Qt.SIGNAL("arrayDataY"),arraydatay)
                        (datay,compl3)=self.dataY.get_sync()
                        (datax,compl3)=self.dataX.get_sync()
                        datax=datax/math.pi*180.
                        (projectname,compl4)=self.projectname.get_sync()
                        self.emit(Qt.SIGNAL("projectname"),projectname)
                        (observername,compl5)=self.observer.get_sync()
                        self.emit(Qt.SIGNAL("observer"),observername)
                        (filename,compl6)=self.filename.get_sync()
                        self.emit(Qt.SIGNAL("filename"),filename)
                        (subscanid,compl7)=self.subscan.get_sync()
                        self.emit(Qt.SIGNAL("subscan"),str(subscanid))
                        (scanid,compl8)=self.scan.get_sync()
                        self.emit(Qt.SIGNAL("scan"),str(scanid))
                        (hpbw,compl9)=self.hpbw.get_sync()
                        self.emit(Qt.SIGNAL("hpbw"),("%5.3f" % (hpbw/math.pi*180*60))) 
                        (amplitude,compl10)=self.amplitude.get_sync()
                        self.emit(Qt.SIGNAL("amplitude"),"%5.3f" % amplitude)
                        (peakOffset,compl11)=self.peakOffset.get_sync()
                        self.emit(Qt.SIGNAL("peakOffset"),"%5.3f" % (peakOffset/math.pi*180))
                        (slope,compl12)=self.slope.get_sync()
                        
                        self.emit(Qt.SIGNAL("slope"),"%5.3f" %slope)
                        (offset,compl13)=self.offset.get_sync()
                        self.emit(Qt.SIGNAL("offset"),"%5.3f" % offset)
                        (target,compl13)=self.name.get_sync()
                        self.emit(Qt.SIGNAL("target"),target)
                        (device,compl13)=self.device.get_sync()
                        self.emit(Qt.SIGNAL("device"),str(device))
                        rec= self.caltool.isRecording()
                        if rec==True:  
                           self.datay_tmp.append(datay)
                           self.datax_tmp.append(datax)
                           self.emit(Qt.SIGNAL("DataY"),self.datay_tmp)
                           self.emit(Qt.SIGNAL("DataX"),self.datax_tmp)
                        
                        self.emit(Qt.SIGNAL("isRecording"),rec)

 #                       print rec
#                        if (subscanid!=self.oldsubscan and scanid !=self.oldscanid):
#                                print "scan changed",self.oldsubscan,subscanid
#                                self.oldsubscan=subscanid
#                                self.subscan=subscanid
#                                self.datax_tmp=[]
#                                self.datay_tmp=[]
                                

                        if (rec!=self.oldrecordingstatus):
                               self.oldrecordingstatus=rec
                               self.datax_tmp=[]
                               self.datay_tmp=[]


                        
		        QThread.msleep(200)
                   print "Exited from thread"
                   
	      except Exception,ex:
			newEx = ClientErrorsImpl.CouldntAccessPropertyExImpl(exception=ex, create=1)
        		newEx.setPropertyName("")
         #ACS_LOG_ERROR
        		newEx.log(self.simpleClient.getLogger(),ACSLog.ACS_LOG_ERROR)

                        self.run=False
                        
	def __del__(self):
		pass
 
 



class Application(Qt.QDialog,calibrationtool_ui.Ui_CalibrationToolDialog):
 
	def __init__(self,compname,parent=None):
		Qt.QDialog.__init__(self)

		self.componentname = compname
 		print self.componentname
		self.simpleClient = PySimpleClient()
		try:
			component= self.simpleClient.getComponent(self.componentname)
                        scheduler= self.simpleClient.getDefaultComponent("IDL:alma/Management/Scheduler:1.0")
                        antennaBoss =self.simpleClient.getDefaultComponent("IDL:alma/Antenna/AntennaBoss:1.0")


     			self.thread=MyWorker([component,scheduler,antennaBoss,self.simpleClient])
			self.setupUi(self)
#                        self.qwtPlot_datax.setAxisScale(Qwt.QwtPlot.xBottom, 0,1000)
                        self.qwtPlot_datax.setAxisAutoScale(Qwt.QwtPlot. yLeft) 
			self.setWindowTitle(self.componentname)
                        self.qwtPlot_datax.setAxisTitle(Qwt.QwtPlot.yLeft, "Ta(K)")
                        self.qwtPlot_datay.setAxisTitle(Qwt.QwtPlot.yLeft, "Ta(K)")
                        self.qwtPlot_datax.setAxisTitle(Qwt.QwtPlot.xBottom, "Direction (Deg)")
                        self.qwtPlot_datay.setAxisTitle(Qwt.QwtPlot.xBottom, "Direction (Deg)")





			self.connect(self.thread,Qt.SIGNAL("arrayDataX"),self.qwtPlot_datay.setX)
    	 		self.connect(self.thread,Qt.SIGNAL("arrayDataY"),self.qwtPlot_datay.setVal)
                        
                        self.connect(self.thread,Qt.SIGNAL("DataX"),self.qwtPlot_datax.setX)
                        self.connect(self.thread,Qt.SIGNAL("DataY"),self.qwtPlot_datax.setVal)
                        
                        self.connect(self.thread,Qt.SIGNAL("projectname"),self.plainTextEdit_project.setPlainText)
                        self.connect(self.thread,Qt.SIGNAL("observer"),self.plainTextEdit_observer.setPlainText)
                        self.connect(self.thread,Qt.SIGNAL("filename"),self.plainTextEdit_filename.setPlainText)
                        self.connect(self.thread,Qt.SIGNAL("subscan"),self.subscanIdLineEdit.setText)
                        self.connect(self.thread,Qt.SIGNAL("scan"),self.scanIdLineEdit.setText)
                        self.connect(self.thread,Qt.SIGNAL("hpbw"),self.hpbwLineEdit.setText)
                        self.connect(self.thread,Qt.SIGNAL("amplitude"),self.amplitudeLineEdit.setText)
                        self.connect(self.thread,Qt.SIGNAL("peakOffset"),self.peakoffsetLineEdit.setText)
                        self.connect(self.thread,Qt.SIGNAL("slope"),self.slopeLineEdit.setText)
                        self.connect(self.thread,Qt.SIGNAL("offset"),self.offsetLineEdit.setText)
                        self.connect(self.thread,Qt.SIGNAL("target"),self.nameLineEdit.setText)
                        self.connect(self.thread,Qt.SIGNAL("device"),self.deviceIdLineEdit.setText)
                        self.connect(self.thread,Qt.SIGNAL("isRecording"),self.isRecording)
                        


		except  Exception,ex:
			newEx = ClientErrorsImpl.CouldntAccessComponentExImpl(exception=ex, create=1)
        		newEx.setComponentName(self.componentname)
         #ACS_LOG_ERROR
        		newEx.log(self.simpleClient.getLogger(),ACSLog.ACS_LOG_ERROR)
        		self.simpleClient.disconnect()
        		sys.exit(-1)	
 	@pyqtSlot(Qt.QObject,name="isRecording")
        def isRecording(self,rec):
          if rec==False:
              self.recording.setText("OFF")
              palette = self.recording.palette()
              role = self.recording.backgroundRole()
              palette.setColor(role, Qt.QColor('gray'))
              self.recording.setPalette(palette)
          if rec==True:
              self.recording.setText("ON")
              palette = self.recording.palette()
              role = self.recording.backgroundRole()
              palette.setColor(role, Qt.QColor('green'))
              self.recording.setPalette(palette)
            


        @pyqtSlot(Qt.QObject,name="scalePlots")  # decorator for the slot
        def scalePlots(self,val):
	        self.qwtPlot_datay.setAxisScale(QwtPlot.xBottom, min(val), max(val))		
	def run(self):
		self.thread.start()
					
	def __del__(self):
		self.thread.run=False  
                try:
 		     self.simpleClient.releaseComponent(self.componentname)
		     self.simpleClient.disconnect()
                except Exception,ex:
                      print "exception"
                      
		print "end app"
		

def usage(nameapp):
        print nameapp+" [component name]"
        
        
  

 

def main(args):
	try:
           opts, args = getopt.getopt(sys.argv[1:],"h",["help"])
        except getopt.GetoptError, err:
            print str(err)
            usage()
            sys.exit(1)
         
        for o,a in opts:
            if o in ("-h", "--help"):
              usage()
              sys.exit()
        
        if len(args)==0:
            componentname="MANAGEMENT/CalibrationTool"
        else:
            componentname=args[0]
         
           
        app = Qt.QApplication(args)
	a=Application(componentname) #passa il nome del component al costruttore
	a.run()
	p=a.show()
		
     	sys.exit(app.exec_())
	sleep(2)
if __name__=='__main__':
	main(sys.argv)
