/******************************************************************************** $Id: JacPrep,v 1.13 2010/01/04 15:34:48 gchiozzi Exp $
* DO NOT EDIT
* Automatically generated from ../idl/SRTMinorServoCommon.midl
* on Mon Nov 27 14:03:33 2023
*******************************************************************************/
#ifndef _SRTMinorServoCommon_midl_
#define _SRTMinorServoCommon_midl_
#ifndef _ACS_PREPROCESSED_
#define _ACS_PREPROCESSED_
#endif
#include <baci.idl>
#include <enumpropMACRO.idl>







#pragma prefix "alma"

module MinorServo
{
    enum SRTMinorServoFocalConfiguration
    {
        CONFIGURATION_UNKNOWN,
        CONFIGURATION_PARK,
        CONFIGURATION_PRIMARY,
        CONFIGURATION_GREGORIAN1,
        CONFIGURATION_GREGORIAN2,
        CONFIGURATION_GREGORIAN3,
        CONFIGURATION_GREGORIAN4,
        CONFIGURATION_GREGORIAN5,
        CONFIGURATION_GREGORIAN6,
        CONFIGURATION_GREGORIAN7,
        CONFIGURATION_GREGORIAN8,
        CONFIGURATION_BWG1,
        CONFIGURATION_BWG2,
        CONFIGURATION_BWG3,
        CONFIGURATION_BWG4
    };


    typedef sequence<SRTMinorServoFocalConfiguration> SRTMinorServoFocalConfigurationSeq; interface CBSRTMinorServoFocalConfiguration : ACS::Callback { oneway void working(in SRTMinorServoFocalConfiguration value, in ACSErr::Completion c, in ACS::CBDescOut desc); oneway void done(in SRTMinorServoFocalConfiguration value, in ACSErr::Completion c, in ACS::CBDescOut desc); };
typedef CBSRTMinorServoFocalConfiguration SRTMinorServoFocalConfigurationCB; interface AlarmSRTMinorServoFocalConfiguration : ACS::Callback { oneway void alarm_raised(in SRTMinorServoFocalConfiguration value, in ACSErr::Completion c, in ACS::CBDescOut desc); oneway void alarm_cleared(in SRTMinorServoFocalConfiguration value, in ACSErr::Completion c, in ACS::CBDescOut desc); };
 typedef AlarmSRTMinorServoFocalConfiguration SRTMinorServoFocalConfigurationAlarm; interface PSRTMinorServoFocalConfiguration: ACS::TypelessProperty { SRTMinorServoFocalConfiguration get_sync(out ACSErr::Completion c); void get_async(in ACS::CBpattern cb, in ACS::CBDescIn desc); long get_history(in long n_last_values, out SRTMinorServoFocalConfigurationSeq vs, out ACS::TimeSeq ts); ACS::Monitorpattern create_monitor(in ACS::CBpattern cb, in ACS::CBDescIn desc); ACS::Monitor create_postponed_monitor (in ACS::Time start_time, in ACS::CBpattern cb, in ACS::CBDescIn desc); readonly attribute ACS::TimeInterval default_timer_trigger; readonly attribute ACS::TimeInterval min_timer_trigger; readonly attribute SRTMinorServoFocalConfiguration default_value; readonly attribute ACS::stringSeq statesDescription; readonly attribute ACS::ConditionSeq condition; readonly attribute SRTMinorServoFocalConfigurationSeq allStates; };
 interface ROSRTMinorServoFocalConfiguration: PSRTMinorServoFocalConfiguration{ ACS::Subscription new_subscription_AlarmEnum(in ACS::Alarmpattern cb, in ACS::CBDescIn desc); readonly attribute SRTMinorServoFocalConfigurationSeq alarm_on; readonly attribute SRTMinorServoFocalConfigurationSeq alarm_off; };
 interface RWSRTMinorServoFocalConfiguration: PSRTMinorServoFocalConfiguration { ACSErr::Completion set_sync(in SRTMinorServoFocalConfiguration value); void set_async(in SRTMinorServoFocalConfiguration value, in ACS::CBvoid cb, in ACS::CBDescIn desc); void set_nonblocking(in SRTMinorServoFocalConfiguration value);};


    enum SRTMinorServoControlStatus
    {
        CONTROL_DISCOS,
        CONTROL_VBRAIN
    };


    typedef sequence<SRTMinorServoControlStatus> SRTMinorServoControlStatusSeq; interface CBSRTMinorServoControlStatus : ACS::Callback { oneway void working(in SRTMinorServoControlStatus value, in ACSErr::Completion c, in ACS::CBDescOut desc); oneway void done(in SRTMinorServoControlStatus value, in ACSErr::Completion c, in ACS::CBDescOut desc); };
typedef CBSRTMinorServoControlStatus SRTMinorServoControlStatusCB; interface AlarmSRTMinorServoControlStatus : ACS::Callback { oneway void alarm_raised(in SRTMinorServoControlStatus value, in ACSErr::Completion c, in ACS::CBDescOut desc); oneway void alarm_cleared(in SRTMinorServoControlStatus value, in ACSErr::Completion c, in ACS::CBDescOut desc); };
 typedef AlarmSRTMinorServoControlStatus SRTMinorServoControlStatusAlarm; interface PSRTMinorServoControlStatus: ACS::TypelessProperty { SRTMinorServoControlStatus get_sync(out ACSErr::Completion c); void get_async(in ACS::CBpattern cb, in ACS::CBDescIn desc); long get_history(in long n_last_values, out SRTMinorServoControlStatusSeq vs, out ACS::TimeSeq ts); ACS::Monitorpattern create_monitor(in ACS::CBpattern cb, in ACS::CBDescIn desc); ACS::Monitor create_postponed_monitor (in ACS::Time start_time, in ACS::CBpattern cb, in ACS::CBDescIn desc); readonly attribute ACS::TimeInterval default_timer_trigger; readonly attribute ACS::TimeInterval min_timer_trigger; readonly attribute SRTMinorServoControlStatus default_value; readonly attribute ACS::stringSeq statesDescription; readonly attribute ACS::ConditionSeq condition; readonly attribute SRTMinorServoControlStatusSeq allStates; };
 interface ROSRTMinorServoControlStatus: PSRTMinorServoControlStatus{ ACS::Subscription new_subscription_AlarmEnum(in ACS::Alarmpattern cb, in ACS::CBDescIn desc); readonly attribute SRTMinorServoControlStatusSeq alarm_on; readonly attribute SRTMinorServoControlStatusSeq alarm_off; };
 interface RWSRTMinorServoControlStatus: PSRTMinorServoControlStatus { ACSErr::Completion set_sync(in SRTMinorServoControlStatus value); void set_async(in SRTMinorServoControlStatus value, in ACS::CBvoid cb, in ACS::CBDescIn desc); void set_nonblocking(in SRTMinorServoControlStatus value);};


    enum SRTMinorServoGregorianCoverStatus
    {
        COVER_STATUS_UNKNOWN,
        COVER_STATUS_OPEN,
        COVER_STATUS_CLOSED
    };


    typedef sequence<SRTMinorServoGregorianCoverStatus> SRTMinorServoGregorianCoverStatusSeq; interface CBSRTMinorServoGregorianCoverStatus : ACS::Callback { oneway void working(in SRTMinorServoGregorianCoverStatus value, in ACSErr::Completion c, in ACS::CBDescOut desc); oneway void done(in SRTMinorServoGregorianCoverStatus value, in ACSErr::Completion c, in ACS::CBDescOut desc); };
typedef CBSRTMinorServoGregorianCoverStatus SRTMinorServoGregorianCoverStatusCB; interface AlarmSRTMinorServoGregorianCoverStatus : ACS::Callback { oneway void alarm_raised(in SRTMinorServoGregorianCoverStatus value, in ACSErr::Completion c, in ACS::CBDescOut desc); oneway void alarm_cleared(in SRTMinorServoGregorianCoverStatus value, in ACSErr::Completion c, in ACS::CBDescOut desc); };
 typedef AlarmSRTMinorServoGregorianCoverStatus SRTMinorServoGregorianCoverStatusAlarm; interface PSRTMinorServoGregorianCoverStatus: ACS::TypelessProperty { SRTMinorServoGregorianCoverStatus get_sync(out ACSErr::Completion c); void get_async(in ACS::CBpattern cb, in ACS::CBDescIn desc); long get_history(in long n_last_values, out SRTMinorServoGregorianCoverStatusSeq vs, out ACS::TimeSeq ts); ACS::Monitorpattern create_monitor(in ACS::CBpattern cb, in ACS::CBDescIn desc); ACS::Monitor create_postponed_monitor (in ACS::Time start_time, in ACS::CBpattern cb, in ACS::CBDescIn desc); readonly attribute ACS::TimeInterval default_timer_trigger; readonly attribute ACS::TimeInterval min_timer_trigger; readonly attribute SRTMinorServoGregorianCoverStatus default_value; readonly attribute ACS::stringSeq statesDescription; readonly attribute ACS::ConditionSeq condition; readonly attribute SRTMinorServoGregorianCoverStatusSeq allStates; };
 interface ROSRTMinorServoGregorianCoverStatus: PSRTMinorServoGregorianCoverStatus{ ACS::Subscription new_subscription_AlarmEnum(in ACS::Alarmpattern cb, in ACS::CBDescIn desc); readonly attribute SRTMinorServoGregorianCoverStatusSeq alarm_on; readonly attribute SRTMinorServoGregorianCoverStatusSeq alarm_off; };
 interface RWSRTMinorServoGregorianCoverStatus: PSRTMinorServoGregorianCoverStatus { ACSErr::Completion set_sync(in SRTMinorServoGregorianCoverStatus value); void set_async(in SRTMinorServoGregorianCoverStatus value, in ACS::CBvoid cb, in ACS::CBDescIn desc); void set_nonblocking(in SRTMinorServoGregorianCoverStatus value);};


    enum SRTMinorServoCabinetStatus
    {
        DRIVE_CABINET_OK,
        DRIVE_CABINET_WARNING,
        DRIVE_CABINET_ERROR
    };


    typedef sequence<SRTMinorServoCabinetStatus> SRTMinorServoCabinetStatusSeq; interface CBSRTMinorServoCabinetStatus : ACS::Callback { oneway void working(in SRTMinorServoCabinetStatus value, in ACSErr::Completion c, in ACS::CBDescOut desc); oneway void done(in SRTMinorServoCabinetStatus value, in ACSErr::Completion c, in ACS::CBDescOut desc); };
typedef CBSRTMinorServoCabinetStatus SRTMinorServoCabinetStatusCB; interface AlarmSRTMinorServoCabinetStatus : ACS::Callback { oneway void alarm_raised(in SRTMinorServoCabinetStatus value, in ACSErr::Completion c, in ACS::CBDescOut desc); oneway void alarm_cleared(in SRTMinorServoCabinetStatus value, in ACSErr::Completion c, in ACS::CBDescOut desc); };
 typedef AlarmSRTMinorServoCabinetStatus SRTMinorServoCabinetStatusAlarm; interface PSRTMinorServoCabinetStatus: ACS::TypelessProperty { SRTMinorServoCabinetStatus get_sync(out ACSErr::Completion c); void get_async(in ACS::CBpattern cb, in ACS::CBDescIn desc); long get_history(in long n_last_values, out SRTMinorServoCabinetStatusSeq vs, out ACS::TimeSeq ts); ACS::Monitorpattern create_monitor(in ACS::CBpattern cb, in ACS::CBDescIn desc); ACS::Monitor create_postponed_monitor (in ACS::Time start_time, in ACS::CBpattern cb, in ACS::CBDescIn desc); readonly attribute ACS::TimeInterval default_timer_trigger; readonly attribute ACS::TimeInterval min_timer_trigger; readonly attribute SRTMinorServoCabinetStatus default_value; readonly attribute ACS::stringSeq statesDescription; readonly attribute ACS::ConditionSeq condition; readonly attribute SRTMinorServoCabinetStatusSeq allStates; };
 interface ROSRTMinorServoCabinetStatus: PSRTMinorServoCabinetStatus{ ACS::Subscription new_subscription_AlarmEnum(in ACS::Alarmpattern cb, in ACS::CBDescIn desc); readonly attribute SRTMinorServoCabinetStatusSeq alarm_on; readonly attribute SRTMinorServoCabinetStatusSeq alarm_off; };
 interface RWSRTMinorServoCabinetStatus: PSRTMinorServoCabinetStatus { ACSErr::Completion set_sync(in SRTMinorServoCabinetStatus value); void set_async(in SRTMinorServoCabinetStatus value, in ACS::CBvoid cb, in ACS::CBDescIn desc); void set_nonblocking(in SRTMinorServoCabinetStatus value);};


    enum SRTMinorServoOperativeMode
    {
        OPERATIVE_MODE_UNKNOWN,
        OPERATIVE_MODE_SETUP,
        OPERATIVE_MODE_STOW,
        OPERATIVE_MODE_STOP,
        OPERATIVE_MODE_PRESET,
        OPERATIVE_MODE_PROGRAMTRACK
    };


    typedef sequence<SRTMinorServoOperativeMode> SRTMinorServoOperativeModeSeq; interface CBSRTMinorServoOperativeMode : ACS::Callback { oneway void working(in SRTMinorServoOperativeMode value, in ACSErr::Completion c, in ACS::CBDescOut desc); oneway void done(in SRTMinorServoOperativeMode value, in ACSErr::Completion c, in ACS::CBDescOut desc); };
typedef CBSRTMinorServoOperativeMode SRTMinorServoOperativeModeCB; interface AlarmSRTMinorServoOperativeMode : ACS::Callback { oneway void alarm_raised(in SRTMinorServoOperativeMode value, in ACSErr::Completion c, in ACS::CBDescOut desc); oneway void alarm_cleared(in SRTMinorServoOperativeMode value, in ACSErr::Completion c, in ACS::CBDescOut desc); };
 typedef AlarmSRTMinorServoOperativeMode SRTMinorServoOperativeModeAlarm; interface PSRTMinorServoOperativeMode: ACS::TypelessProperty { SRTMinorServoOperativeMode get_sync(out ACSErr::Completion c); void get_async(in ACS::CBpattern cb, in ACS::CBDescIn desc); long get_history(in long n_last_values, out SRTMinorServoOperativeModeSeq vs, out ACS::TimeSeq ts); ACS::Monitorpattern create_monitor(in ACS::CBpattern cb, in ACS::CBDescIn desc); ACS::Monitor create_postponed_monitor (in ACS::Time start_time, in ACS::CBpattern cb, in ACS::CBDescIn desc); readonly attribute ACS::TimeInterval default_timer_trigger; readonly attribute ACS::TimeInterval min_timer_trigger; readonly attribute SRTMinorServoOperativeMode default_value; readonly attribute ACS::stringSeq statesDescription; readonly attribute ACS::ConditionSeq condition; readonly attribute SRTMinorServoOperativeModeSeq allStates; };
 interface ROSRTMinorServoOperativeMode: PSRTMinorServoOperativeMode{ ACS::Subscription new_subscription_AlarmEnum(in ACS::Alarmpattern cb, in ACS::CBDescIn desc); readonly attribute SRTMinorServoOperativeModeSeq alarm_on; readonly attribute SRTMinorServoOperativeModeSeq alarm_off; };
 interface RWSRTMinorServoOperativeMode: PSRTMinorServoOperativeMode { ACSErr::Completion set_sync(in SRTMinorServoOperativeMode value); void set_async(in SRTMinorServoOperativeMode value, in ACS::CBvoid cb, in ACS::CBDescIn desc); void set_nonblocking(in SRTMinorServoOperativeMode value);};


    enum SRTMinorServoBossStatus
    {
        BOSS_STATUS_UNCONFIGURED,
        BOSS_STATUS_SETUP_IN_PROGRESS,
        BOSS_STATUS_PARK_IN_PROGRESS,
        BOSS_STATUS_ERROR,
        BOSS_STATUS_CONFIGURED
    };


    typedef sequence<SRTMinorServoBossStatus> SRTMinorServoBossStatusSeq; interface CBSRTMinorServoBossStatus : ACS::Callback { oneway void working(in SRTMinorServoBossStatus value, in ACSErr::Completion c, in ACS::CBDescOut desc); oneway void done(in SRTMinorServoBossStatus value, in ACSErr::Completion c, in ACS::CBDescOut desc); };
typedef CBSRTMinorServoBossStatus SRTMinorServoBossStatusCB; interface AlarmSRTMinorServoBossStatus : ACS::Callback { oneway void alarm_raised(in SRTMinorServoBossStatus value, in ACSErr::Completion c, in ACS::CBDescOut desc); oneway void alarm_cleared(in SRTMinorServoBossStatus value, in ACSErr::Completion c, in ACS::CBDescOut desc); };
 typedef AlarmSRTMinorServoBossStatus SRTMinorServoBossStatusAlarm; interface PSRTMinorServoBossStatus: ACS::TypelessProperty { SRTMinorServoBossStatus get_sync(out ACSErr::Completion c); void get_async(in ACS::CBpattern cb, in ACS::CBDescIn desc); long get_history(in long n_last_values, out SRTMinorServoBossStatusSeq vs, out ACS::TimeSeq ts); ACS::Monitorpattern create_monitor(in ACS::CBpattern cb, in ACS::CBDescIn desc); ACS::Monitor create_postponed_monitor (in ACS::Time start_time, in ACS::CBpattern cb, in ACS::CBDescIn desc); readonly attribute ACS::TimeInterval default_timer_trigger; readonly attribute ACS::TimeInterval min_timer_trigger; readonly attribute SRTMinorServoBossStatus default_value; readonly attribute ACS::stringSeq statesDescription; readonly attribute ACS::ConditionSeq condition; readonly attribute SRTMinorServoBossStatusSeq allStates; };
 interface ROSRTMinorServoBossStatus: PSRTMinorServoBossStatus{ ACS::Subscription new_subscription_AlarmEnum(in ACS::Alarmpattern cb, in ACS::CBDescIn desc); readonly attribute SRTMinorServoBossStatusSeq alarm_on; readonly attribute SRTMinorServoBossStatusSeq alarm_off; };
 interface RWSRTMinorServoBossStatus: PSRTMinorServoBossStatus { ACSErr::Completion set_sync(in SRTMinorServoBossStatus value); void set_async(in SRTMinorServoBossStatus value, in ACS::CBvoid cb, in ACS::CBDescIn desc); void set_nonblocking(in SRTMinorServoBossStatus value);};

};

#endif
