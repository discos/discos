// -*- C++ -*-
//
// $Id$

// ****  Code generated by the The ACE ORB (TAO) IDL Compiler v1.6.5 ****
// TAO and the TAO IDL Compiler have been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// and
//       Distributed Object Computing Laboratory
//       University of California at Irvine
//       Irvine, CA
//       USA
//       http://doc.ece.uci.edu/
// and
//       Institute for Software Integrated Systems
//       Vanderbilt University
//       Nashville, TN
//       USA
//       http://www.isis.vanderbilt.edu/
//
// Information about TAO is available at:
//     http://www.cs.wustl.edu/~schmidt/TAO.html


// TAO_IDL - Generated from 
// be/be_codegen.cpp:703

#ifndef _TAO_IDL____OBJECT_NOTOACTIVESURFACEBOSSS_CPP_
#define _TAO_IDL____OBJECT_NOTOACTIVESURFACEBOSSS_CPP_


#include "NotoActiveSurfaceBossS.h"
#include "tao/PortableServer/Operation_Table_Perfect_Hash.h"
#include "tao/PortableServer/Upcall_Command.h"
#include "tao/PortableServer/Upcall_Wrapper.h"
#include "tao/TAO_Server_Request.h"
#include "tao/ORB_Core.h"
#include "tao/Profile.h"
#include "tao/Stub.h"
#include "tao/IFR_Client_Adapter.h"
#include "tao/Object_T.h"
#include "tao/AnyTypeCode/TypeCode.h"
#include "tao/AnyTypeCode/DynamicC.h"
#include "tao/CDR.h"
#include "tao/operation_details.h"
#include "tao/PortableInterceptor.h"
#include "tao/PortableServer/Basic_SArguments.h"
#include "tao/PortableServer/Fixed_Size_SArgument_T.h"
#include "tao/PortableServer/Object_SArgument_T.h"
#include "tao/PortableServer/Special_Basic_SArguments.h"
#include "tao/PortableServer/UB_String_SArguments.h"
#include "tao/PortableServer/Var_Size_SArgument_T.h"
#include "tao/PortableServer/TypeCode_SArg_Traits.h"
#include "tao/PortableServer/Object_SArg_Traits.h"
#include "tao/PortableServer/get_arg.h"
#include "tao/Special_Basic_Arguments.h"
#include "tao/UB_String_Arguments.h"
#include "tao/Basic_Arguments.h"
#include "tao/Fixed_Size_Argument_T.h"
#include "tao/Object_Argument_T.h"
#include "tao/Var_Size_Argument_T.h"
#include "ace/Dynamic_Service.h"
#include "ace/Malloc_Allocator.h"

#if !defined (__ACE_INLINE__)
#include "NotoActiveSurfaceBossS.inl"
#endif /* !defined INLINE */

// TAO_IDL - Generated from
// be/be_visitor_arg_traits.cpp:73

TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Arg traits specializations.
namespace TAO
{
  
  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:620

#if !defined (_ACS_STRINGSEQ__SARG_TRAITS_)
#define _ACS_STRINGSEQ__SARG_TRAITS_
  
  template<>
  class SArg_Traits<ACS::stringSeq>
    : public
        Var_Size_SArg_Traits_T<
            ACS::stringSeq,
            TAO::Any_Insert_Policy_Stream <ACS::stringSeq>
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:620

#if !defined (_ACS_TIMESEQ__SARG_TRAITS_)
#define _ACS_TIMESEQ__SARG_TRAITS_
  
  template<>
  class SArg_Traits<ACS::TimeSeq>
    : public
        Var_Size_SArg_Traits_T<
            ACS::TimeSeq,
            TAO::Any_Insert_Policy_Stream <ACS::TimeSeq>
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:620

#if !defined (_ACS_CONDITIONSEQ__SARG_TRAITS_)
#define _ACS_CONDITIONSEQ__SARG_TRAITS_
  
  template<>
  class SArg_Traits<ACS::ConditionSeq>
    : public
        Var_Size_SArg_Traits_T<
            ACS::ConditionSeq,
            TAO::Any_Insert_Policy_Stream <ACS::ConditionSeq>
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:868

#if !defined (_ACSERR_COMPLETION__SARG_TRAITS_)
#define _ACSERR_COMPLETION__SARG_TRAITS_
  
  template<>
  class SArg_Traits<ACSErr::Completion>
    : public
        Var_Size_SArg_Traits_T<
            ACSErr::Completion,
            TAO::Any_Insert_Policy_Stream <ACSErr::Completion>
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:868

#if !defined (_ACS_CBDESCIN__SARG_TRAITS_)
#define _ACS_CBDESCIN__SARG_TRAITS_
  
  template<>
  class SArg_Traits<ACS::CBDescIn>
    : public
        Fixed_Size_SArg_Traits_T<
            ACS::CBDescIn,
            TAO::Any_Insert_Policy_Stream <ACS::CBDescIn>
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:868

#if !defined (_ACS_CBDESCOUT__SARG_TRAITS_)
#define _ACS_CBDESCOUT__SARG_TRAITS_
  
  template<>
  class SArg_Traits<ACS::CBDescOut>
    : public
        Fixed_Size_SArg_Traits_T<
            ACS::CBDescOut,
            TAO::Any_Insert_Policy_Stream <ACS::CBDescOut>
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:141

#if !defined (_ACS_SUBSCRIPTION__SARG_TRAITS_)
#define _ACS_SUBSCRIPTION__SARG_TRAITS_
  
  template<>
  class  SArg_Traits<ACS::Subscription>
    : public
        Object_SArg_Traits_T<
            ACS::Subscription_ptr,
            ACS::Subscription_var,
            ACS::Subscription_out,
            TAO::Any_Insert_Policy_Stream <ACS::Subscription_ptr>
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:141

#if !defined (_ACS_MONITOR__SARG_TRAITS_)
#define _ACS_MONITOR__SARG_TRAITS_
  
  template<>
  class  SArg_Traits<ACS::Monitor>
    : public
        Object_SArg_Traits_T<
            ACS::Monitor_ptr,
            ACS::Monitor_var,
            ACS::Monitor_out,
            TAO::Any_Insert_Policy_Stream <ACS::Monitor_ptr>
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:141

#if !defined (_ACS_MONITORPATTERN__SARG_TRAITS_)
#define _ACS_MONITORPATTERN__SARG_TRAITS_
  
  template<>
  class  SArg_Traits<ACS::Monitorpattern>
    : public
        Object_SArg_Traits_T<
            ACS::Monitorpattern_ptr,
            ACS::Monitorpattern_var,
            ACS::Monitorpattern_out,
            TAO::Any_Insert_Policy_Stream <ACS::Monitorpattern_ptr>
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:141

#if !defined (_ACS_CBVOID__SARG_TRAITS_)
#define _ACS_CBVOID__SARG_TRAITS_
  
  template<>
  class  SArg_Traits<ACS::CBvoid>
    : public
        Object_SArg_Traits_T<
            ACS::CBvoid_ptr,
            ACS::CBvoid_var,
            ACS::CBvoid_out,
            TAO::Any_Insert_Policy_Stream <ACS::CBvoid_ptr>
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:141

#if !defined (_ACS_CBPATTERN__SARG_TRAITS_)
#define _ACS_CBPATTERN__SARG_TRAITS_
  
  template<>
  class  SArg_Traits<ACS::CBpattern>
    : public
        Object_SArg_Traits_T<
            ACS::CBpattern_ptr,
            ACS::CBpattern_var,
            ACS::CBpattern_out,
            TAO::Any_Insert_Policy_Stream <ACS::CBpattern_ptr>
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:141

#if !defined (_ACS_ALARMPATTERN__SARG_TRAITS_)
#define _ACS_ALARMPATTERN__SARG_TRAITS_
  
  template<>
  class  SArg_Traits<ACS::Alarmpattern>
    : public
        Object_SArg_Traits_T<
            ACS::Alarmpattern_ptr,
            ACS::Alarmpattern_var,
            ACS::Alarmpattern_out,
            TAO::Any_Insert_Policy_Stream <ACS::Alarmpattern_ptr>
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:141

#if !defined (_MANAGEMENT_ROTBOOLEAN__SARG_TRAITS_)
#define _MANAGEMENT_ROTBOOLEAN__SARG_TRAITS_
  
  template<>
  class  SArg_Traits<Management::ROTBoolean>
    : public
        Object_SArg_Traits_T<
            Management::ROTBoolean_ptr,
            Management::ROTBoolean_var,
            Management::ROTBoolean_out,
            TAO::Any_Insert_Policy_Stream <Management::ROTBoolean_ptr>
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:826

#if !defined (_ACTIVESURFACE_TASONEWAYACTION__SARG_TRAITS_)
#define _ACTIVESURFACE_TASONEWAYACTION__SARG_TRAITS_
  
  template<>
  class SArg_Traits<ActiveSurface::TASOneWayAction>
    : public
        Basic_SArg_Traits_T<
            ActiveSurface::TASOneWayAction,
            TAO::Any_Insert_Policy_Stream <ActiveSurface::TASOneWayAction>
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:620

#if !defined (_ACTIVESURFACE_TASONEWAYACTIONSEQ__SARG_TRAITS_)
#define _ACTIVESURFACE_TASONEWAYACTIONSEQ__SARG_TRAITS_
  
  template<>
  class SArg_Traits<ActiveSurface::TASOneWayActionSeq>
    : public
        Var_Size_SArg_Traits_T<
            ActiveSurface::TASOneWayActionSeq,
            TAO::Any_Insert_Policy_Stream <ActiveSurface::TASOneWayActionSeq>
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:826

#if !defined (_ACTIVESURFACE_TASPROFILE__SARG_TRAITS_)
#define _ACTIVESURFACE_TASPROFILE__SARG_TRAITS_
  
  template<>
  class SArg_Traits<ActiveSurface::TASProfile>
    : public
        Basic_SArg_Traits_T<
            ActiveSurface::TASProfile,
            TAO::Any_Insert_Policy_Stream <ActiveSurface::TASProfile>
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:620

#if !defined (_ACTIVESURFACE_TASPROFILESEQ__SARG_TRAITS_)
#define _ACTIVESURFACE_TASPROFILESEQ__SARG_TRAITS_
  
  template<>
  class SArg_Traits<ActiveSurface::TASProfileSeq>
    : public
        Var_Size_SArg_Traits_T<
            ActiveSurface::TASProfileSeq,
            TAO::Any_Insert_Policy_Stream <ActiveSurface::TASProfileSeq>
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:141

#if !defined (_ACTIVESURFACE_ROTASPROFILE__SARG_TRAITS_)
#define _ACTIVESURFACE_ROTASPROFILE__SARG_TRAITS_
  
  template<>
  class  SArg_Traits<ActiveSurface::ROTASProfile>
    : public
        Object_SArg_Traits_T<
            ActiveSurface::ROTASProfile_ptr,
            ActiveSurface::ROTASProfile_var,
            ActiveSurface::ROTASProfile_out,
            TAO::Any_Insert_Policy_Stream <ActiveSurface::ROTASProfile_ptr>
          >
  {
  };

#endif /* end #if !defined */
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_arg_traits.cpp:73

TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Arg traits specializations.
namespace TAO
{
  
  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:620

#if !defined (_ACS_STRINGSEQ__ARG_TRAITS_)
#define _ACS_STRINGSEQ__ARG_TRAITS_
  
  template<>
  class Arg_Traits<ACS::stringSeq>
    : public
        Var_Size_Arg_Traits_T<
            ACS::stringSeq,
            TAO::Any_Insert_Policy_Stream <ACS::stringSeq>
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:620

#if !defined (_ACS_TIMESEQ__ARG_TRAITS_)
#define _ACS_TIMESEQ__ARG_TRAITS_
  
  template<>
  class Arg_Traits<ACS::TimeSeq>
    : public
        Var_Size_Arg_Traits_T<
            ACS::TimeSeq,
            TAO::Any_Insert_Policy_Stream <ACS::TimeSeq>
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:620

#if !defined (_ACS_CONDITIONSEQ__ARG_TRAITS_)
#define _ACS_CONDITIONSEQ__ARG_TRAITS_
  
  template<>
  class Arg_Traits<ACS::ConditionSeq>
    : public
        Var_Size_Arg_Traits_T<
            ACS::ConditionSeq,
            TAO::Any_Insert_Policy_Stream <ACS::ConditionSeq>
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:868

#if !defined (_ACSERR_COMPLETION__ARG_TRAITS_)
#define _ACSERR_COMPLETION__ARG_TRAITS_
  
  template<>
  class Arg_Traits<ACSErr::Completion>
    : public
        Var_Size_Arg_Traits_T<
            ACSErr::Completion,
            TAO::Any_Insert_Policy_Stream <ACSErr::Completion>
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:868

#if !defined (_ACS_CBDESCIN__ARG_TRAITS_)
#define _ACS_CBDESCIN__ARG_TRAITS_
  
  template<>
  class Arg_Traits<ACS::CBDescIn>
    : public
        Fixed_Size_Arg_Traits_T<
            ACS::CBDescIn,
            TAO::Any_Insert_Policy_Stream <ACS::CBDescIn>
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:868

#if !defined (_ACS_CBDESCOUT__ARG_TRAITS_)
#define _ACS_CBDESCOUT__ARG_TRAITS_
  
  template<>
  class Arg_Traits<ACS::CBDescOut>
    : public
        Fixed_Size_Arg_Traits_T<
            ACS::CBDescOut,
            TAO::Any_Insert_Policy_Stream <ACS::CBDescOut>
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:141

#if !defined (_ACS_SUBSCRIPTION__ARG_TRAITS_)
#define _ACS_SUBSCRIPTION__ARG_TRAITS_
  
  template<>
  class  Arg_Traits<ACS::Subscription>
    : public
        Object_Arg_Traits_T<
            ACS::Subscription_ptr,
            ACS::Subscription_var,
            ACS::Subscription_out,
            TAO::Objref_Traits<ACS::Subscription>,
            TAO::Any_Insert_Policy_Stream <ACS::Subscription_ptr>
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:141

#if !defined (_ACS_MONITOR__ARG_TRAITS_)
#define _ACS_MONITOR__ARG_TRAITS_
  
  template<>
  class  Arg_Traits<ACS::Monitor>
    : public
        Object_Arg_Traits_T<
            ACS::Monitor_ptr,
            ACS::Monitor_var,
            ACS::Monitor_out,
            TAO::Objref_Traits<ACS::Monitor>,
            TAO::Any_Insert_Policy_Stream <ACS::Monitor_ptr>
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:141

#if !defined (_ACS_MONITORPATTERN__ARG_TRAITS_)
#define _ACS_MONITORPATTERN__ARG_TRAITS_
  
  template<>
  class  Arg_Traits<ACS::Monitorpattern>
    : public
        Object_Arg_Traits_T<
            ACS::Monitorpattern_ptr,
            ACS::Monitorpattern_var,
            ACS::Monitorpattern_out,
            TAO::Objref_Traits<ACS::Monitorpattern>,
            TAO::Any_Insert_Policy_Stream <ACS::Monitorpattern_ptr>
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:141

#if !defined (_ACS_CBVOID__ARG_TRAITS_)
#define _ACS_CBVOID__ARG_TRAITS_
  
  template<>
  class  Arg_Traits<ACS::CBvoid>
    : public
        Object_Arg_Traits_T<
            ACS::CBvoid_ptr,
            ACS::CBvoid_var,
            ACS::CBvoid_out,
            TAO::Objref_Traits<ACS::CBvoid>,
            TAO::Any_Insert_Policy_Stream <ACS::CBvoid_ptr>
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:141

#if !defined (_ACS_CBPATTERN__ARG_TRAITS_)
#define _ACS_CBPATTERN__ARG_TRAITS_
  
  template<>
  class  Arg_Traits<ACS::CBpattern>
    : public
        Object_Arg_Traits_T<
            ACS::CBpattern_ptr,
            ACS::CBpattern_var,
            ACS::CBpattern_out,
            TAO::Objref_Traits<ACS::CBpattern>,
            TAO::Any_Insert_Policy_Stream <ACS::CBpattern_ptr>
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:141

#if !defined (_ACS_ALARMPATTERN__ARG_TRAITS_)
#define _ACS_ALARMPATTERN__ARG_TRAITS_
  
  template<>
  class  Arg_Traits<ACS::Alarmpattern>
    : public
        Object_Arg_Traits_T<
            ACS::Alarmpattern_ptr,
            ACS::Alarmpattern_var,
            ACS::Alarmpattern_out,
            TAO::Objref_Traits<ACS::Alarmpattern>,
            TAO::Any_Insert_Policy_Stream <ACS::Alarmpattern_ptr>
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:141

#if !defined (_MANAGEMENT_ROTBOOLEAN__ARG_TRAITS_)
#define _MANAGEMENT_ROTBOOLEAN__ARG_TRAITS_
  
  template<>
  class  Arg_Traits<Management::ROTBoolean>
    : public
        Object_Arg_Traits_T<
            Management::ROTBoolean_ptr,
            Management::ROTBoolean_var,
            Management::ROTBoolean_out,
            TAO::Objref_Traits<Management::ROTBoolean>,
            TAO::Any_Insert_Policy_Stream <Management::ROTBoolean_ptr>
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:826

#if !defined (_ACTIVESURFACE_TASONEWAYACTION__ARG_TRAITS_)
#define _ACTIVESURFACE_TASONEWAYACTION__ARG_TRAITS_
  
  template<>
  class Arg_Traits<ActiveSurface::TASOneWayAction>
    : public
        Basic_Arg_Traits_T<
            ActiveSurface::TASOneWayAction,
            TAO::Any_Insert_Policy_Stream <ActiveSurface::TASOneWayAction>
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:620

#if !defined (_ACTIVESURFACE_TASONEWAYACTIONSEQ__ARG_TRAITS_)
#define _ACTIVESURFACE_TASONEWAYACTIONSEQ__ARG_TRAITS_
  
  template<>
  class Arg_Traits<ActiveSurface::TASOneWayActionSeq>
    : public
        Var_Size_Arg_Traits_T<
            ActiveSurface::TASOneWayActionSeq,
            TAO::Any_Insert_Policy_Stream <ActiveSurface::TASOneWayActionSeq>
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:826

#if !defined (_ACTIVESURFACE_TASPROFILE__ARG_TRAITS_)
#define _ACTIVESURFACE_TASPROFILE__ARG_TRAITS_
  
  template<>
  class Arg_Traits<ActiveSurface::TASProfile>
    : public
        Basic_Arg_Traits_T<
            ActiveSurface::TASProfile,
            TAO::Any_Insert_Policy_Stream <ActiveSurface::TASProfile>
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:620

#if !defined (_ACTIVESURFACE_TASPROFILESEQ__ARG_TRAITS_)
#define _ACTIVESURFACE_TASPROFILESEQ__ARG_TRAITS_
  
  template<>
  class Arg_Traits<ActiveSurface::TASProfileSeq>
    : public
        Var_Size_Arg_Traits_T<
            ActiveSurface::TASProfileSeq,
            TAO::Any_Insert_Policy_Stream <ActiveSurface::TASProfileSeq>
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:141

#if !defined (_ACTIVESURFACE_ROTASPROFILE__ARG_TRAITS_)
#define _ACTIVESURFACE_ROTASPROFILE__ARG_TRAITS_
  
  template<>
  class  Arg_Traits<ActiveSurface::ROTASProfile>
    : public
        Object_Arg_Traits_T<
            ActiveSurface::ROTASProfile_ptr,
            ActiveSurface::ROTASProfile_var,
            ActiveSurface::ROTASProfile_out,
            TAO::Objref_Traits<ActiveSurface::ROTASProfile>,
            TAO::Any_Insert_Policy_Stream <ActiveSurface::ROTASProfile_ptr>
          >
  {
  };

#endif /* end #if !defined */
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_interface.cpp:1555

class TAO_ActiveSurface_CBTASOneWayAction_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: /alma/ACS-8.2/TAO/ACE_wrappers/build/linux/bin/gperf -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_ActiveSurface_CBTASOneWayAction_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_ActiveSurface_CBTASOneWayAction_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19,  0,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19,  0,
     19, 19,  0,  0, 19,  0, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19,  0,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19,  5, 19, 19,  0, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19,
#else
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19,  0, 19,  0, 19, 19,
      0,  0, 19,  0, 19, 19, 19, 19, 19, 19,
      0, 19, 19, 19, 19, 19,  5, 19, 19,  0,
     19, 19, 19, 19, 19, 19, 19, 19,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_ActiveSurface_CBTASOneWayAction_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 8,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 14,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 18,
      HASH_VALUE_RANGE = 15,
      DUPLICATES = 0,
      WORDLIST_SIZE = 12
    };

  static const TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"done", &POA_ActiveSurface::CBTASOneWayAction::done_skel, 0},
      {"_is_a", &POA_ActiveSurface::CBTASOneWayAction::_is_a_skel, 0},
      {"",0,0},
      {"working", &POA_ActiveSurface::CBTASOneWayAction::working_skel, 0},
      {"",0,0},
      {"negotiate", &POA_ActiveSurface::CBTASOneWayAction::negotiate_skel, 0},
      {"_interface", &POA_ActiveSurface::CBTASOneWayAction::_interface_skel, 0},
      {"",0,0},{"",0,0},{"",0,0},
      {"_repository_id", &POA_ActiveSurface::CBTASOneWayAction::_repository_id_skel, 0},
      {"_component", &POA_ActiveSurface::CBTASOneWayAction::_component_skel, 0},
      {"",0,0},{"",0,0},
      {"_non_existent", &POA_ActiveSurface::CBTASOneWayAction::_non_existent_skel, 0},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname;

          if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}

static TAO_ActiveSurface_CBTASOneWayAction_Perfect_Hash_OpTable tao_ActiveSurface_CBTASOneWayAction_optable;

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ss.cpp:984

TAO::Collocation_Proxy_Broker *
ActiveSurface__TAO_CBTASOneWayAction_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
ActiveSurface__TAO_CBTASOneWayAction_Proxy_Broker_Factory_Initializer (size_t)
{
  ActiveSurface__TAO_CBTASOneWayAction_Proxy_Broker_Factory_function_pointer = 
    ActiveSurface__TAO_CBTASOneWayAction_Proxy_Broker_Factory_function;
  
  return 0;
}

static int
ActiveSurface__TAO_CBTASOneWayAction_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  ActiveSurface__TAO_CBTASOneWayAction_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (ActiveSurface__TAO_CBTASOneWayAction_Proxy_Broker_Factory_Initializer)
    );

// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_ss.cpp:103

POA_ActiveSurface::CBTASOneWayAction::CBTASOneWayAction (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_ActiveSurface_CBTASOneWayAction_optable;
}

POA_ActiveSurface::CBTASOneWayAction::CBTASOneWayAction (const CBTASOneWayAction& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_ACS::OffShoot (rhs),
    POA_ACS::Callback (rhs)
{
}

POA_ActiveSurface::CBTASOneWayAction::~CBTASOneWayAction (void)
{
}
namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class working_CBTASOneWayAction
    : public TAO::Upcall_Command
  {
  public:
    inline working_CBTASOneWayAction (
      POA_ActiveSurface::CBTASOneWayAction * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ActiveSurface::TASOneWayAction>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::ActiveSurface::TASOneWayAction> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::ACSErr::Completion>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::ACSErr::Completion> (
          this->operation_details_,
          this->args_,
          2);
        
      TAO::SArg_Traits< ::ACS::CBDescOut>::in_arg_type arg_3 =
        TAO::Portable_Server::get_in_arg< ::ACS::CBDescOut> (
          this->operation_details_,
          this->args_,
          3);
        
      this->servant_->working (
        arg_1
        , arg_2
        , arg_3);
    }
  
  private:
    POA_ActiveSurface::CBTASOneWayAction * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from 
// be/be_visitor_operation/operation_ss.cpp:190

void POA_ActiveSurface::CBTASOneWayAction::working_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::ActiveSurface::TASOneWayAction>::in_arg_val _tao_value;
  TAO::SArg_Traits< ::ACSErr::Completion>::in_arg_val _tao_c;
  TAO::SArg_Traits< ::ACS::CBDescOut>::in_arg_val _tao_desc;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_value,
      &_tao_c,
      &_tao_desc
    };
  
  static size_t const nargs = 4;
  
  POA_ActiveSurface::CBTASOneWayAction * const impl =
    static_cast<POA_ActiveSurface::CBTASOneWayAction *> (servant);

  working_CBTASOneWayAction command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class done_CBTASOneWayAction
    : public TAO::Upcall_Command
  {
  public:
    inline done_CBTASOneWayAction (
      POA_ActiveSurface::CBTASOneWayAction * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ActiveSurface::TASOneWayAction>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::ActiveSurface::TASOneWayAction> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::ACSErr::Completion>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::ACSErr::Completion> (
          this->operation_details_,
          this->args_,
          2);
        
      TAO::SArg_Traits< ::ACS::CBDescOut>::in_arg_type arg_3 =
        TAO::Portable_Server::get_in_arg< ::ACS::CBDescOut> (
          this->operation_details_,
          this->args_,
          3);
        
      this->servant_->done (
        arg_1
        , arg_2
        , arg_3);
    }
  
  private:
    POA_ActiveSurface::CBTASOneWayAction * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from 
// be/be_visitor_operation/operation_ss.cpp:190

void POA_ActiveSurface::CBTASOneWayAction::done_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::ActiveSurface::TASOneWayAction>::in_arg_val _tao_value;
  TAO::SArg_Traits< ::ACSErr::Completion>::in_arg_val _tao_c;
  TAO::SArg_Traits< ::ACS::CBDescOut>::in_arg_val _tao_desc;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_value,
      &_tao_c,
      &_tao_desc
    };
  
  static size_t const nargs = 4;
  
  POA_ActiveSurface::CBTASOneWayAction * const impl =
    static_cast<POA_ActiveSurface::CBTASOneWayAction *> (servant);

  done_CBTASOneWayAction command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}



// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_ss.cpp:169

namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class _is_a_CBTASOneWayAction_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _is_a_CBTASOneWayAction_Upcall_Command (
      POA_ActiveSurface::CBTASOneWayAction * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::CORBA::Char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Char *> (
          this->operation_details_,
          this->args_,
          1);
        
      retval =
        this->servant_-> _is_a (
          arg_1);
    }
  
  private:
    POA_ActiveSurface::CBTASOneWayAction * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_ActiveSurface::CBTASOneWayAction::_is_a_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Char *>::in_arg_val _tao_repository_id;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };
  
  static size_t const nargs = 2;
  
  POA_ActiveSurface::CBTASOneWayAction * const impl =
    static_cast<POA_ActiveSurface::CBTASOneWayAction *> (servant);
  
  _is_a_CBTASOneWayAction_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class _non_existent_CBTASOneWayAction_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _non_existent_CBTASOneWayAction_Upcall_Command (
      POA_ActiveSurface::CBTASOneWayAction * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _non_existent ();
    }
  
  private:
    POA_ActiveSurface::CBTASOneWayAction * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_ActiveSurface::CBTASOneWayAction::_non_existent_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_ActiveSurface::CBTASOneWayAction * const impl =
    static_cast<POA_ActiveSurface::CBTASOneWayAction *> (servant);
  
  _non_existent_CBTASOneWayAction_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}
namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class _repository_id_CBTASOneWayAction_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _repository_id_CBTASOneWayAction_Upcall_Command (
      POA_ActiveSurface::CBTASOneWayAction * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Char *>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Char *> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _repository_id ();
    }
  
  private:
    POA_ActiveSurface::CBTASOneWayAction * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_ActiveSurface::CBTASOneWayAction::_repository_id_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::Char *>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_ActiveSurface::CBTASOneWayAction * const impl =
    static_cast<POA_ActiveSurface::CBTASOneWayAction *> (servant);
  
  _repository_id_CBTASOneWayAction_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_ss.cpp:508

void POA_ActiveSurface::CBTASOneWayAction::_interface_skel (
    TAO_ServerRequest & server_request, 
    void * /* servant_upcall */,
    void * servant)
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (_tao_adapter == 0)
    {
      throw ::CORBA::INTF_REPOS (::CORBA::OMGVMCID | 1, ::CORBA::COMPLETED_NO);
    }
  
  POA_ActiveSurface::CBTASOneWayAction * const impl =
    static_cast<POA_ActiveSurface::CBTASOneWayAction *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval = impl->_get_interface ();
  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();
  
  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (_tao_out, _tao_retval);
  
  _tao_adapter->dispose (_tao_retval);
  
  if (_tao_result == false)
    {
      throw ::CORBA::MARSHAL ();
    }
}

namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class _get_component_CBTASOneWayAction_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _get_component_CBTASOneWayAction_Upcall_Command (
      POA_ActiveSurface::CBTASOneWayAction * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _get_component ();
    }
  
  private:
    POA_ActiveSurface::CBTASOneWayAction * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_ActiveSurface::CBTASOneWayAction::_component_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_ActiveSurface::CBTASOneWayAction * const impl =
    static_cast<POA_ActiveSurface::CBTASOneWayAction *> (servant);
  
  _get_component_CBTASOneWayAction_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

::CORBA::Boolean POA_ActiveSurface::CBTASOneWayAction::_is_a (const char* value)
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:alma/ACS/OffShoot:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:alma/ACS/Callback:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:alma/ActiveSurface/CBTASOneWayAction:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_ActiveSurface::CBTASOneWayAction::_interface_repository_id (void) const
{
  return "IDL:alma/ActiveSurface/CBTASOneWayAction:1.0";
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ss.cpp:926

void POA_ActiveSurface::CBTASOneWayAction::_dispatch (TAO_ServerRequest & req, void * servant_upcall)
{
  this->synchronous_upcall_dispatch (req, servant_upcall, this);
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ss.cpp:852

ActiveSurface::CBTASOneWayAction *
POA_ActiveSurface::CBTASOneWayAction::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();
  
  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object_ptr ();
  
  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );
  
  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();
  
  typedef ::ActiveSurface::CBTASOneWayAction STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        ActiveSurface__TAO_CBTASOneWayAction_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// be/be_interface.cpp:1555

class TAO_ActiveSurface_AlarmTASOneWayAction_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: /alma/ACS-8.2/TAO/ACE_wrappers/build/linux/bin/gperf -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_ActiveSurface_AlarmTASOneWayAction_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_ActiveSurface_AlarmTASOneWayAction_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19,  0,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19,  0,
     19, 19,  0,  0, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19,  0,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19,  5, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19,
#else
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19,  0, 19,  0, 19, 19,
      0,  0, 19, 19, 19, 19, 19, 19, 19, 19,
      0, 19, 19, 19, 19, 19,  5, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_ActiveSurface_AlarmTASOneWayAction_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 8,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 14,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 18,
      HASH_VALUE_RANGE = 14,
      DUPLICATES = 0,
      WORDLIST_SIZE = 13
    };

  static const TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"_is_a", &POA_ActiveSurface::AlarmTASOneWayAction::_is_a_skel, 0},
      {"",0,0},{"",0,0},{"",0,0},
      {"negotiate", &POA_ActiveSurface::AlarmTASOneWayAction::negotiate_skel, 0},
      {"_interface", &POA_ActiveSurface::AlarmTASOneWayAction::_interface_skel, 0},
      {"",0,0},
      {"alarm_raised", &POA_ActiveSurface::AlarmTASOneWayAction::alarm_raised_skel, 0},
      {"alarm_cleared", &POA_ActiveSurface::AlarmTASOneWayAction::alarm_cleared_skel, 0},
      {"_repository_id", &POA_ActiveSurface::AlarmTASOneWayAction::_repository_id_skel, 0},
      {"_component", &POA_ActiveSurface::AlarmTASOneWayAction::_component_skel, 0},
      {"",0,0},{"",0,0},
      {"_non_existent", &POA_ActiveSurface::AlarmTASOneWayAction::_non_existent_skel, 0},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname;

          if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}

static TAO_ActiveSurface_AlarmTASOneWayAction_Perfect_Hash_OpTable tao_ActiveSurface_AlarmTASOneWayAction_optable;

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ss.cpp:984

TAO::Collocation_Proxy_Broker *
ActiveSurface__TAO_AlarmTASOneWayAction_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
ActiveSurface__TAO_AlarmTASOneWayAction_Proxy_Broker_Factory_Initializer (size_t)
{
  ActiveSurface__TAO_AlarmTASOneWayAction_Proxy_Broker_Factory_function_pointer = 
    ActiveSurface__TAO_AlarmTASOneWayAction_Proxy_Broker_Factory_function;
  
  return 0;
}

static int
ActiveSurface__TAO_AlarmTASOneWayAction_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  ActiveSurface__TAO_AlarmTASOneWayAction_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (ActiveSurface__TAO_AlarmTASOneWayAction_Proxy_Broker_Factory_Initializer)
    );

// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_ss.cpp:103

POA_ActiveSurface::AlarmTASOneWayAction::AlarmTASOneWayAction (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_ActiveSurface_AlarmTASOneWayAction_optable;
}

POA_ActiveSurface::AlarmTASOneWayAction::AlarmTASOneWayAction (const AlarmTASOneWayAction& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_ACS::OffShoot (rhs),
    POA_ACS::Callback (rhs)
{
}

POA_ActiveSurface::AlarmTASOneWayAction::~AlarmTASOneWayAction (void)
{
}
namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class alarm_raised_AlarmTASOneWayAction
    : public TAO::Upcall_Command
  {
  public:
    inline alarm_raised_AlarmTASOneWayAction (
      POA_ActiveSurface::AlarmTASOneWayAction * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ActiveSurface::TASOneWayAction>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::ActiveSurface::TASOneWayAction> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::ACSErr::Completion>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::ACSErr::Completion> (
          this->operation_details_,
          this->args_,
          2);
        
      TAO::SArg_Traits< ::ACS::CBDescOut>::in_arg_type arg_3 =
        TAO::Portable_Server::get_in_arg< ::ACS::CBDescOut> (
          this->operation_details_,
          this->args_,
          3);
        
      this->servant_->alarm_raised (
        arg_1
        , arg_2
        , arg_3);
    }
  
  private:
    POA_ActiveSurface::AlarmTASOneWayAction * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from 
// be/be_visitor_operation/operation_ss.cpp:190

void POA_ActiveSurface::AlarmTASOneWayAction::alarm_raised_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::ActiveSurface::TASOneWayAction>::in_arg_val _tao_value;
  TAO::SArg_Traits< ::ACSErr::Completion>::in_arg_val _tao_c;
  TAO::SArg_Traits< ::ACS::CBDescOut>::in_arg_val _tao_desc;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_value,
      &_tao_c,
      &_tao_desc
    };
  
  static size_t const nargs = 4;
  
  POA_ActiveSurface::AlarmTASOneWayAction * const impl =
    static_cast<POA_ActiveSurface::AlarmTASOneWayAction *> (servant);

  alarm_raised_AlarmTASOneWayAction command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class alarm_cleared_AlarmTASOneWayAction
    : public TAO::Upcall_Command
  {
  public:
    inline alarm_cleared_AlarmTASOneWayAction (
      POA_ActiveSurface::AlarmTASOneWayAction * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ActiveSurface::TASOneWayAction>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::ActiveSurface::TASOneWayAction> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::ACSErr::Completion>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::ACSErr::Completion> (
          this->operation_details_,
          this->args_,
          2);
        
      TAO::SArg_Traits< ::ACS::CBDescOut>::in_arg_type arg_3 =
        TAO::Portable_Server::get_in_arg< ::ACS::CBDescOut> (
          this->operation_details_,
          this->args_,
          3);
        
      this->servant_->alarm_cleared (
        arg_1
        , arg_2
        , arg_3);
    }
  
  private:
    POA_ActiveSurface::AlarmTASOneWayAction * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from 
// be/be_visitor_operation/operation_ss.cpp:190

void POA_ActiveSurface::AlarmTASOneWayAction::alarm_cleared_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::ActiveSurface::TASOneWayAction>::in_arg_val _tao_value;
  TAO::SArg_Traits< ::ACSErr::Completion>::in_arg_val _tao_c;
  TAO::SArg_Traits< ::ACS::CBDescOut>::in_arg_val _tao_desc;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_value,
      &_tao_c,
      &_tao_desc
    };
  
  static size_t const nargs = 4;
  
  POA_ActiveSurface::AlarmTASOneWayAction * const impl =
    static_cast<POA_ActiveSurface::AlarmTASOneWayAction *> (servant);

  alarm_cleared_AlarmTASOneWayAction command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}



// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_ss.cpp:169

namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class _is_a_AlarmTASOneWayAction_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _is_a_AlarmTASOneWayAction_Upcall_Command (
      POA_ActiveSurface::AlarmTASOneWayAction * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::CORBA::Char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Char *> (
          this->operation_details_,
          this->args_,
          1);
        
      retval =
        this->servant_-> _is_a (
          arg_1);
    }
  
  private:
    POA_ActiveSurface::AlarmTASOneWayAction * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_ActiveSurface::AlarmTASOneWayAction::_is_a_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Char *>::in_arg_val _tao_repository_id;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };
  
  static size_t const nargs = 2;
  
  POA_ActiveSurface::AlarmTASOneWayAction * const impl =
    static_cast<POA_ActiveSurface::AlarmTASOneWayAction *> (servant);
  
  _is_a_AlarmTASOneWayAction_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class _non_existent_AlarmTASOneWayAction_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _non_existent_AlarmTASOneWayAction_Upcall_Command (
      POA_ActiveSurface::AlarmTASOneWayAction * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _non_existent ();
    }
  
  private:
    POA_ActiveSurface::AlarmTASOneWayAction * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_ActiveSurface::AlarmTASOneWayAction::_non_existent_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_ActiveSurface::AlarmTASOneWayAction * const impl =
    static_cast<POA_ActiveSurface::AlarmTASOneWayAction *> (servant);
  
  _non_existent_AlarmTASOneWayAction_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}
namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class _repository_id_AlarmTASOneWayAction_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _repository_id_AlarmTASOneWayAction_Upcall_Command (
      POA_ActiveSurface::AlarmTASOneWayAction * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Char *>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Char *> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _repository_id ();
    }
  
  private:
    POA_ActiveSurface::AlarmTASOneWayAction * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_ActiveSurface::AlarmTASOneWayAction::_repository_id_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::Char *>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_ActiveSurface::AlarmTASOneWayAction * const impl =
    static_cast<POA_ActiveSurface::AlarmTASOneWayAction *> (servant);
  
  _repository_id_AlarmTASOneWayAction_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_ss.cpp:508

void POA_ActiveSurface::AlarmTASOneWayAction::_interface_skel (
    TAO_ServerRequest & server_request, 
    void * /* servant_upcall */,
    void * servant)
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (_tao_adapter == 0)
    {
      throw ::CORBA::INTF_REPOS (::CORBA::OMGVMCID | 1, ::CORBA::COMPLETED_NO);
    }
  
  POA_ActiveSurface::AlarmTASOneWayAction * const impl =
    static_cast<POA_ActiveSurface::AlarmTASOneWayAction *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval = impl->_get_interface ();
  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();
  
  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (_tao_out, _tao_retval);
  
  _tao_adapter->dispose (_tao_retval);
  
  if (_tao_result == false)
    {
      throw ::CORBA::MARSHAL ();
    }
}

namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class _get_component_AlarmTASOneWayAction_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _get_component_AlarmTASOneWayAction_Upcall_Command (
      POA_ActiveSurface::AlarmTASOneWayAction * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _get_component ();
    }
  
  private:
    POA_ActiveSurface::AlarmTASOneWayAction * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_ActiveSurface::AlarmTASOneWayAction::_component_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_ActiveSurface::AlarmTASOneWayAction * const impl =
    static_cast<POA_ActiveSurface::AlarmTASOneWayAction *> (servant);
  
  _get_component_AlarmTASOneWayAction_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

::CORBA::Boolean POA_ActiveSurface::AlarmTASOneWayAction::_is_a (const char* value)
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:alma/ACS/OffShoot:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:alma/ACS/Callback:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:alma/ActiveSurface/AlarmTASOneWayAction:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_ActiveSurface::AlarmTASOneWayAction::_interface_repository_id (void) const
{
  return "IDL:alma/ActiveSurface/AlarmTASOneWayAction:1.0";
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ss.cpp:926

void POA_ActiveSurface::AlarmTASOneWayAction::_dispatch (TAO_ServerRequest & req, void * servant_upcall)
{
  this->synchronous_upcall_dispatch (req, servant_upcall, this);
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ss.cpp:852

ActiveSurface::AlarmTASOneWayAction *
POA_ActiveSurface::AlarmTASOneWayAction::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();
  
  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object_ptr ();
  
  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );
  
  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();
  
  typedef ::ActiveSurface::AlarmTASOneWayAction STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        ActiveSurface__TAO_AlarmTASOneWayAction_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// be/be_interface.cpp:1555

class TAO_ActiveSurface_PTASOneWayAction_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: /alma/ACS-8.2/TAO/ACE_wrappers/build/linux/bin/gperf -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_ActiveSurface_PTASOneWayAction_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_ActiveSurface_PTASOneWayAction_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     50, 50, 50, 50, 50, 50, 50, 50, 50, 50,
     50, 50, 50, 50, 50, 50, 50, 50, 50, 50,
     50, 50, 50, 50, 50, 50, 50, 50, 50, 50,
     50, 50, 50, 50, 50, 50, 50, 50, 50, 50,
     50, 50, 50, 50, 50, 50, 50, 50, 50, 50,
     50, 50, 50, 50, 50, 50, 50, 50, 50, 50,
     50, 50, 50, 50, 50, 50, 50, 50, 50, 50,
     50, 50, 50, 50, 50, 50, 50, 50, 50, 50,
     50, 50, 50, 50, 50, 50, 50, 50, 50, 50,
     50, 50, 50, 50, 50, 50, 50, 50, 50, 50,
     50, 50, 50, 50, 50, 50, 50, 50, 50,  0,
     50, 50, 50, 50, 50, 50, 50, 50, 50, 50,
     50, 50, 50, 50, 50, 50, 50, 50, 50,  0,
     50, 15,  0,  0, 10,  0, 50, 50, 50, 50,
     50, 50, 50, 50, 50, 50, 50, 50, 50,  5,
     50, 50, 50, 10, 50, 50, 50, 50, 50, 50,
     50, 50, 15, 20, 50, 50, 50, 50,  0, 50,
     50, 50, 50, 50, 50, 50, 50, 50, 50, 50,
     50, 50, 50, 50, 50, 50, 50, 50, 50, 50,
     50, 50, 50, 50, 50, 50, 50, 50, 50, 50,
     50, 50, 50, 50, 50, 50, 50, 50, 50, 50,
     50, 50, 50, 50, 50, 50, 50, 50, 50, 50,
     50, 50, 50, 50, 50, 50, 50, 50, 50, 50,
     50, 50, 50, 50, 50, 50, 50, 50, 50, 50,
     50, 50, 50, 50, 50, 50, 50, 50, 50, 50,
     50, 50, 50, 50, 50, 50,
#else
     50, 50, 50, 50, 50, 50, 50, 50, 50, 50,
     50, 50, 50, 50, 50, 50, 50, 50, 50, 50,
     50, 50, 50, 50, 50, 50, 50, 50, 50, 50,
     50, 50, 50, 50, 50, 50, 50, 50, 50, 50,
     50, 50, 50, 50, 50, 50, 50, 50, 50, 50,
     50, 50, 50, 50, 50, 50, 50, 50, 50, 50,
     50, 50, 50, 50, 50, 50, 50, 50, 50, 50,
     50, 50, 50, 50, 50, 50, 50, 50, 50, 50,
     50, 50, 50, 50, 50, 50, 50, 50, 50, 50,
     50, 50, 50, 50, 50,  0, 50,  0, 50, 15,
      0,  0, 10,  0, 50, 50, 50, 50, 50, 50,
      5, 50, 50, 50, 10, 15, 20, 50, 50, 50,
     50,  0, 50, 50, 50, 50, 50, 50,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_ActiveSurface_PTASOneWayAction_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 25,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 34,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 49,
      HASH_VALUE_RANGE = 45,
      DUPLICATES = 0,
      WORDLIST_SIZE = 30
    };

  static const TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"_is_a", &POA_ActiveSurface::PTASOneWayAction::_is_a_skel, 0},
      {"",0,0},{"",0,0},{"",0,0},
      {"_get_name", &POA_ActiveSurface::PTASOneWayAction::_get_name_skel, 0},
      {"_interface", &POA_ActiveSurface::PTASOneWayAction::_interface_skel, 0},
      {"get_history", &POA_ActiveSurface::PTASOneWayAction::get_history_skel, 0},
      {"",0,0},{"",0,0},
      {"_repository_id", &POA_ActiveSurface::PTASOneWayAction::_repository_id_skel, 0},
      {"",0,0},{"",0,0},{"",0,0},
      {"_get_default_value", &POA_ActiveSurface::PTASOneWayAction::_get_default_value_skel, 0},
      {"_get_condition", &POA_ActiveSurface::PTASOneWayAction::_get_condition_skel, 0},
      {"_get_resolution", &POA_ActiveSurface::PTASOneWayAction::_get_resolution_skel, 0},
      {"_get_description", &POA_ActiveSurface::PTASOneWayAction::_get_description_skel, 0},
      {"",0,0},
      {"get_sync", &POA_ActiveSurface::PTASOneWayAction::get_sync_skel, 0},
      {"get_async", &POA_ActiveSurface::PTASOneWayAction::get_async_skel, 0},
      {"_get_units", &POA_ActiveSurface::PTASOneWayAction::_get_units_skel, 0},
      {"get_characteristic_by_name", &POA_ActiveSurface::PTASOneWayAction::get_characteristic_by_name_skel, 0},
      {"_get_statesDescription", &POA_ActiveSurface::PTASOneWayAction::_get_statesDescription_skel, 0},
      {"",0,0},
      {"_get_allStates", &POA_ActiveSurface::PTASOneWayAction::_get_allStates_skel, 0},
      {"_component", &POA_ActiveSurface::PTASOneWayAction::_component_skel, 0},
      {"_get_format", &POA_ActiveSurface::PTASOneWayAction::_get_format_skel, 0},
      {"_get_min_timer_trigger", &POA_ActiveSurface::PTASOneWayAction::_get_min_timer_trigger_skel, 0},
      {"_non_existent", &POA_ActiveSurface::PTASOneWayAction::_non_existent_skel, 0},
      {"_get_characteristic_component_name", &POA_ActiveSurface::PTASOneWayAction::_get_characteristic_component_name_skel, 0},
      {"",0,0},
      {"_get_default_timer_trigger", &POA_ActiveSurface::PTASOneWayAction::_get_default_timer_trigger_skel, 0},
      {"",0,0},
      {"get_all_characteristics", &POA_ActiveSurface::PTASOneWayAction::get_all_characteristics_skel, 0},
      {"create_monitor", &POA_ActiveSurface::PTASOneWayAction::create_monitor_skel, 0},
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"find_characteristic", &POA_ActiveSurface::PTASOneWayAction::find_characteristic_skel, 0},
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"create_postponed_monitor", &POA_ActiveSurface::PTASOneWayAction::create_postponed_monitor_skel, 0},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname;

          if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}

static TAO_ActiveSurface_PTASOneWayAction_Perfect_Hash_OpTable tao_ActiveSurface_PTASOneWayAction_optable;

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ss.cpp:984

TAO::Collocation_Proxy_Broker *
ActiveSurface__TAO_PTASOneWayAction_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
ActiveSurface__TAO_PTASOneWayAction_Proxy_Broker_Factory_Initializer (size_t)
{
  ActiveSurface__TAO_PTASOneWayAction_Proxy_Broker_Factory_function_pointer = 
    ActiveSurface__TAO_PTASOneWayAction_Proxy_Broker_Factory_function;
  
  return 0;
}

static int
ActiveSurface__TAO_PTASOneWayAction_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  ActiveSurface__TAO_PTASOneWayAction_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (ActiveSurface__TAO_PTASOneWayAction_Proxy_Broker_Factory_Initializer)
    );

// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_ss.cpp:103

POA_ActiveSurface::PTASOneWayAction::PTASOneWayAction (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_ActiveSurface_PTASOneWayAction_optable;
}

POA_ActiveSurface::PTASOneWayAction::PTASOneWayAction (const PTASOneWayAction& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_ACS::CharacteristicModel (rhs),
    POA_ACS::OffShoot (rhs),
    POA_ACS::Property (rhs),
    POA_ACS::TypelessProperty (rhs)
{
}

POA_ActiveSurface::PTASOneWayAction::~PTASOneWayAction (void)
{
}
namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class get_sync_PTASOneWayAction
    : public TAO::Upcall_Command
  {
  public:
    inline get_sync_PTASOneWayAction (
      POA_ActiveSurface::PTASOneWayAction * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ActiveSurface::TASOneWayAction>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ActiveSurface::TASOneWayAction> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::ACSErr::Completion>::out_arg_type arg_1 =
        TAO::Portable_Server::get_out_arg< ::ACSErr::Completion> (
          this->operation_details_,
          this->args_,
          1);
        
      retval =
        this->servant_->get_sync (
          arg_1);
    }
  
  private:
    POA_ActiveSurface::PTASOneWayAction * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from 
// be/be_visitor_operation/operation_ss.cpp:190

void POA_ActiveSurface::PTASOneWayAction::get_sync_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ActiveSurface::TASOneWayAction>::ret_val retval;
  TAO::SArg_Traits< ::ACSErr::Completion>::out_arg_val _tao_c;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_c
    };
  
  static size_t const nargs = 2;
  
  POA_ActiveSurface::PTASOneWayAction * const impl =
    static_cast<POA_ActiveSurface::PTASOneWayAction *> (servant);

  get_sync_PTASOneWayAction command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class get_async_PTASOneWayAction
    : public TAO::Upcall_Command
  {
  public:
    inline get_async_PTASOneWayAction (
      POA_ActiveSurface::PTASOneWayAction * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACS::CBpattern>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::ACS::CBpattern> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::ACS::CBDescIn>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::ACS::CBDescIn> (
          this->operation_details_,
          this->args_,
          2);
        
      this->servant_->get_async (
        arg_1
        , arg_2);
    }
  
  private:
    POA_ActiveSurface::PTASOneWayAction * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from 
// be/be_visitor_operation/operation_ss.cpp:190

void POA_ActiveSurface::PTASOneWayAction::get_async_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::ACS::CBpattern>::in_arg_val _tao_cb;
  TAO::SArg_Traits< ::ACS::CBDescIn>::in_arg_val _tao_desc;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_cb,
      &_tao_desc
    };
  
  static size_t const nargs = 3;
  
  POA_ActiveSurface::PTASOneWayAction * const impl =
    static_cast<POA_ActiveSurface::PTASOneWayAction *> (servant);

  get_async_PTASOneWayAction command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class get_history_PTASOneWayAction
    : public TAO::Upcall_Command
  {
  public:
    inline get_history_PTASOneWayAction (
      POA_ActiveSurface::PTASOneWayAction * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Long>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Long> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::ActiveSurface::TASOneWayActionSeq>::out_arg_type arg_2 =
        TAO::Portable_Server::get_out_arg< ::ActiveSurface::TASOneWayActionSeq> (
          this->operation_details_,
          this->args_,
          2);
        
      TAO::SArg_Traits< ::ACS::TimeSeq>::out_arg_type arg_3 =
        TAO::Portable_Server::get_out_arg< ::ACS::TimeSeq> (
          this->operation_details_,
          this->args_,
          3);
        
      retval =
        this->servant_->get_history (
          arg_1
          , arg_2
          , arg_3);
    }
  
  private:
    POA_ActiveSurface::PTASOneWayAction * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from 
// be/be_visitor_operation/operation_ss.cpp:190

void POA_ActiveSurface::PTASOneWayAction::get_history_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::Long>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_n_last_values;
  TAO::SArg_Traits< ::ActiveSurface::TASOneWayActionSeq>::out_arg_val _tao_vs;
  TAO::SArg_Traits< ::ACS::TimeSeq>::out_arg_val _tao_ts;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_n_last_values,
      &_tao_vs,
      &_tao_ts
    };
  
  static size_t const nargs = 4;
  
  POA_ActiveSurface::PTASOneWayAction * const impl =
    static_cast<POA_ActiveSurface::PTASOneWayAction *> (servant);

  get_history_PTASOneWayAction command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class create_monitor_PTASOneWayAction
    : public TAO::Upcall_Command
  {
  public:
    inline create_monitor_PTASOneWayAction (
      POA_ActiveSurface::PTASOneWayAction * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACS::Monitorpattern>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACS::Monitorpattern> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::ACS::CBpattern>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::ACS::CBpattern> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::ACS::CBDescIn>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::ACS::CBDescIn> (
          this->operation_details_,
          this->args_,
          2);
        
      retval =
        this->servant_->create_monitor (
          arg_1
          , arg_2);
    }
  
  private:
    POA_ActiveSurface::PTASOneWayAction * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from 
// be/be_visitor_operation/operation_ss.cpp:190

void POA_ActiveSurface::PTASOneWayAction::create_monitor_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACS::Monitorpattern>::ret_val retval;
  TAO::SArg_Traits< ::ACS::CBpattern>::in_arg_val _tao_cb;
  TAO::SArg_Traits< ::ACS::CBDescIn>::in_arg_val _tao_desc;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_cb,
      &_tao_desc
    };
  
  static size_t const nargs = 3;
  
  POA_ActiveSurface::PTASOneWayAction * const impl =
    static_cast<POA_ActiveSurface::PTASOneWayAction *> (servant);

  create_monitor_PTASOneWayAction command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class create_postponed_monitor_PTASOneWayAction
    : public TAO::Upcall_Command
  {
  public:
    inline create_postponed_monitor_PTASOneWayAction (
      POA_ActiveSurface::PTASOneWayAction * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACS::Monitor>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACS::Monitor> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::ACS::Time>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::ACS::Time> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::ACS::CBpattern>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::ACS::CBpattern> (
          this->operation_details_,
          this->args_,
          2);
        
      TAO::SArg_Traits< ::ACS::CBDescIn>::in_arg_type arg_3 =
        TAO::Portable_Server::get_in_arg< ::ACS::CBDescIn> (
          this->operation_details_,
          this->args_,
          3);
        
      retval =
        this->servant_->create_postponed_monitor (
          arg_1
          , arg_2
          , arg_3);
    }
  
  private:
    POA_ActiveSurface::PTASOneWayAction * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from 
// be/be_visitor_operation/operation_ss.cpp:190

void POA_ActiveSurface::PTASOneWayAction::create_postponed_monitor_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACS::Monitor>::ret_val retval;
  TAO::SArg_Traits< ::ACS::Time>::in_arg_val _tao_start_time;
  TAO::SArg_Traits< ::ACS::CBpattern>::in_arg_val _tao_cb;
  TAO::SArg_Traits< ::ACS::CBDescIn>::in_arg_val _tao_desc;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_start_time,
      &_tao_cb,
      &_tao_desc
    };
  
  static size_t const nargs = 4;
  
  POA_ActiveSurface::PTASOneWayAction * const impl =
    static_cast<POA_ActiveSurface::PTASOneWayAction *> (servant);

  create_postponed_monitor_PTASOneWayAction command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class _get_default_timer_trigger_PTASOneWayAction
    : public TAO::Upcall_Command
  {
  public:
    inline _get_default_timer_trigger_PTASOneWayAction (
      POA_ActiveSurface::PTASOneWayAction * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACS::TimeInterval>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACS::TimeInterval> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_->default_timer_trigger ();
    }
  
  private:
    POA_ActiveSurface::PTASOneWayAction * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from 
// be/be_visitor_operation/operation_ss.cpp:190

void POA_ActiveSurface::PTASOneWayAction::_get_default_timer_trigger_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACS::TimeInterval>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_ActiveSurface::PTASOneWayAction * const impl =
    static_cast<POA_ActiveSurface::PTASOneWayAction *> (servant);

  _get_default_timer_trigger_PTASOneWayAction command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class _get_min_timer_trigger_PTASOneWayAction
    : public TAO::Upcall_Command
  {
  public:
    inline _get_min_timer_trigger_PTASOneWayAction (
      POA_ActiveSurface::PTASOneWayAction * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACS::TimeInterval>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACS::TimeInterval> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_->min_timer_trigger ();
    }
  
  private:
    POA_ActiveSurface::PTASOneWayAction * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from 
// be/be_visitor_operation/operation_ss.cpp:190

void POA_ActiveSurface::PTASOneWayAction::_get_min_timer_trigger_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACS::TimeInterval>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_ActiveSurface::PTASOneWayAction * const impl =
    static_cast<POA_ActiveSurface::PTASOneWayAction *> (servant);

  _get_min_timer_trigger_PTASOneWayAction command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class _get_default_value_PTASOneWayAction
    : public TAO::Upcall_Command
  {
  public:
    inline _get_default_value_PTASOneWayAction (
      POA_ActiveSurface::PTASOneWayAction * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ActiveSurface::TASOneWayAction>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ActiveSurface::TASOneWayAction> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_->default_value ();
    }
  
  private:
    POA_ActiveSurface::PTASOneWayAction * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from 
// be/be_visitor_operation/operation_ss.cpp:190

void POA_ActiveSurface::PTASOneWayAction::_get_default_value_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ActiveSurface::TASOneWayAction>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_ActiveSurface::PTASOneWayAction * const impl =
    static_cast<POA_ActiveSurface::PTASOneWayAction *> (servant);

  _get_default_value_PTASOneWayAction command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class _get_statesDescription_PTASOneWayAction
    : public TAO::Upcall_Command
  {
  public:
    inline _get_statesDescription_PTASOneWayAction (
      POA_ActiveSurface::PTASOneWayAction * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACS::stringSeq>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACS::stringSeq> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_->statesDescription ();
    }
  
  private:
    POA_ActiveSurface::PTASOneWayAction * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from 
// be/be_visitor_operation/operation_ss.cpp:190

void POA_ActiveSurface::PTASOneWayAction::_get_statesDescription_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACS::stringSeq>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_ActiveSurface::PTASOneWayAction * const impl =
    static_cast<POA_ActiveSurface::PTASOneWayAction *> (servant);

  _get_statesDescription_PTASOneWayAction command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class _get_condition_PTASOneWayAction
    : public TAO::Upcall_Command
  {
  public:
    inline _get_condition_PTASOneWayAction (
      POA_ActiveSurface::PTASOneWayAction * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACS::ConditionSeq>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACS::ConditionSeq> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_->condition ();
    }
  
  private:
    POA_ActiveSurface::PTASOneWayAction * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from 
// be/be_visitor_operation/operation_ss.cpp:190

void POA_ActiveSurface::PTASOneWayAction::_get_condition_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACS::ConditionSeq>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_ActiveSurface::PTASOneWayAction * const impl =
    static_cast<POA_ActiveSurface::PTASOneWayAction *> (servant);

  _get_condition_PTASOneWayAction command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class _get_allStates_PTASOneWayAction
    : public TAO::Upcall_Command
  {
  public:
    inline _get_allStates_PTASOneWayAction (
      POA_ActiveSurface::PTASOneWayAction * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ActiveSurface::TASOneWayActionSeq>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ActiveSurface::TASOneWayActionSeq> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_->allStates ();
    }
  
  private:
    POA_ActiveSurface::PTASOneWayAction * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from 
// be/be_visitor_operation/operation_ss.cpp:190

void POA_ActiveSurface::PTASOneWayAction::_get_allStates_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ActiveSurface::TASOneWayActionSeq>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_ActiveSurface::PTASOneWayAction * const impl =
    static_cast<POA_ActiveSurface::PTASOneWayAction *> (servant);

  _get_allStates_PTASOneWayAction command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}



// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_ss.cpp:169

namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class _is_a_PTASOneWayAction_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _is_a_PTASOneWayAction_Upcall_Command (
      POA_ActiveSurface::PTASOneWayAction * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::CORBA::Char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Char *> (
          this->operation_details_,
          this->args_,
          1);
        
      retval =
        this->servant_-> _is_a (
          arg_1);
    }
  
  private:
    POA_ActiveSurface::PTASOneWayAction * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_ActiveSurface::PTASOneWayAction::_is_a_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Char *>::in_arg_val _tao_repository_id;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };
  
  static size_t const nargs = 2;
  
  POA_ActiveSurface::PTASOneWayAction * const impl =
    static_cast<POA_ActiveSurface::PTASOneWayAction *> (servant);
  
  _is_a_PTASOneWayAction_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class _non_existent_PTASOneWayAction_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _non_existent_PTASOneWayAction_Upcall_Command (
      POA_ActiveSurface::PTASOneWayAction * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _non_existent ();
    }
  
  private:
    POA_ActiveSurface::PTASOneWayAction * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_ActiveSurface::PTASOneWayAction::_non_existent_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_ActiveSurface::PTASOneWayAction * const impl =
    static_cast<POA_ActiveSurface::PTASOneWayAction *> (servant);
  
  _non_existent_PTASOneWayAction_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}
namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class _repository_id_PTASOneWayAction_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _repository_id_PTASOneWayAction_Upcall_Command (
      POA_ActiveSurface::PTASOneWayAction * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Char *>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Char *> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _repository_id ();
    }
  
  private:
    POA_ActiveSurface::PTASOneWayAction * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_ActiveSurface::PTASOneWayAction::_repository_id_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::Char *>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_ActiveSurface::PTASOneWayAction * const impl =
    static_cast<POA_ActiveSurface::PTASOneWayAction *> (servant);
  
  _repository_id_PTASOneWayAction_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_ss.cpp:508

void POA_ActiveSurface::PTASOneWayAction::_interface_skel (
    TAO_ServerRequest & server_request, 
    void * /* servant_upcall */,
    void * servant)
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (_tao_adapter == 0)
    {
      throw ::CORBA::INTF_REPOS (::CORBA::OMGVMCID | 1, ::CORBA::COMPLETED_NO);
    }
  
  POA_ActiveSurface::PTASOneWayAction * const impl =
    static_cast<POA_ActiveSurface::PTASOneWayAction *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval = impl->_get_interface ();
  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();
  
  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (_tao_out, _tao_retval);
  
  _tao_adapter->dispose (_tao_retval);
  
  if (_tao_result == false)
    {
      throw ::CORBA::MARSHAL ();
    }
}

namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class _get_component_PTASOneWayAction_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _get_component_PTASOneWayAction_Upcall_Command (
      POA_ActiveSurface::PTASOneWayAction * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _get_component ();
    }
  
  private:
    POA_ActiveSurface::PTASOneWayAction * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_ActiveSurface::PTASOneWayAction::_component_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_ActiveSurface::PTASOneWayAction * const impl =
    static_cast<POA_ActiveSurface::PTASOneWayAction *> (servant);
  
  _get_component_PTASOneWayAction_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

::CORBA::Boolean POA_ActiveSurface::PTASOneWayAction::_is_a (const char* value)
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:alma/ACS/CharacteristicModel:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:alma/ACS/OffShoot:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:alma/ACS/Property:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:alma/ACS/TypelessProperty:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:alma/ActiveSurface/PTASOneWayAction:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_ActiveSurface::PTASOneWayAction::_interface_repository_id (void) const
{
  return "IDL:alma/ActiveSurface/PTASOneWayAction:1.0";
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ss.cpp:926

void POA_ActiveSurface::PTASOneWayAction::_dispatch (TAO_ServerRequest & req, void * servant_upcall)
{
  this->synchronous_upcall_dispatch (req, servant_upcall, this);
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ss.cpp:852

ActiveSurface::PTASOneWayAction *
POA_ActiveSurface::PTASOneWayAction::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();
  
  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object_ptr ();
  
  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );
  
  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();
  
  typedef ::ActiveSurface::PTASOneWayAction STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        ActiveSurface__TAO_PTASOneWayAction_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// be/be_interface.cpp:1555

class TAO_ActiveSurface_ROTASOneWayAction_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: /alma/ACS-8.2/TAO/ACE_wrappers/build/linux/bin/gperf -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_ActiveSurface_ROTASOneWayAction_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_ActiveSurface_ROTASOneWayAction_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
     60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
     60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
     60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
     60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
     60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
     60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
     60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
     60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
     60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
     60, 60, 60, 60, 60, 60, 60, 60, 60,  0,
     60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
     60, 60, 60, 60, 60, 60, 60, 60, 60,  0,
     60, 30, 15,  0,  5,  0, 60, 60, 60, 60,
     60, 60, 60, 60, 60, 60, 60, 60, 10,  0,
     60, 60, 60,  5, 60, 60, 60, 60, 60, 60,
     60, 60, 10, 30, 60, 60, 60, 60,  0, 60,
     60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
     60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
     60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
     60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
     60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
     60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
     60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
     60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
     60, 60, 60, 60, 60, 60,
#else
     60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
     60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
     60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
     60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
     60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
     60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
     60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
     60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
     60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
     60, 60, 60, 60, 60,  0, 60,  0, 60, 30,
     15,  0,  5,  0, 60, 60, 60, 60, 60, 10,
      0, 60, 60, 60,  5, 10, 30, 60, 60, 60,
     60,  0, 60, 60, 60, 60, 60, 60,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_ActiveSurface_ROTASOneWayAction_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 28,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 34,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 59,
      HASH_VALUE_RANGE = 55,
      DUPLICATES = 0,
      WORDLIST_SIZE = 33
    };

  static const TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"_is_a", &POA_ActiveSurface::ROTASOneWayAction::_is_a_skel, 0},
      {"",0,0},{"",0,0},{"",0,0},
      {"_get_name", &POA_ActiveSurface::ROTASOneWayAction::_get_name_skel, 0},
      {"_interface", &POA_ActiveSurface::ROTASOneWayAction::_interface_skel, 0},
      {"get_history", &POA_ActiveSurface::ROTASOneWayAction::get_history_skel, 0},
      {"",0,0},
      {"_get_alarm_on", &POA_ActiveSurface::ROTASOneWayAction::_get_alarm_on_skel, 0},
      {"_get_condition", &POA_ActiveSurface::ROTASOneWayAction::_get_condition_skel, 0},
      {"_get_resolution", &POA_ActiveSurface::ROTASOneWayAction::_get_resolution_skel, 0},
      {"_get_description", &POA_ActiveSurface::ROTASOneWayAction::_get_description_skel, 0},
      {"",0,0},
      {"_get_default_value", &POA_ActiveSurface::ROTASOneWayAction::_get_default_value_skel, 0},
      {"_get_alarm_off", &POA_ActiveSurface::ROTASOneWayAction::_get_alarm_off_skel, 0},
      {"_get_units", &POA_ActiveSurface::ROTASOneWayAction::_get_units_skel, 0},
      {"",0,0},
      {"_get_statesDescription", &POA_ActiveSurface::ROTASOneWayAction::_get_statesDescription_skel, 0},
      {"",0,0},
      {"_get_allStates", &POA_ActiveSurface::ROTASOneWayAction::_get_allStates_skel, 0},
      {"",0,0},
      {"get_characteristic_by_name", &POA_ActiveSurface::ROTASOneWayAction::get_characteristic_by_name_skel, 0},
      {"_get_min_timer_trigger", &POA_ActiveSurface::ROTASOneWayAction::_get_min_timer_trigger_skel, 0},
      {"",0,0},
      {"_repository_id", &POA_ActiveSurface::ROTASOneWayAction::_repository_id_skel, 0},
      {"",0,0},
      {"_get_default_timer_trigger", &POA_ActiveSurface::ROTASOneWayAction::_get_default_timer_trigger_skel, 0},
      {"",0,0},
      {"get_all_characteristics", &POA_ActiveSurface::ROTASOneWayAction::get_all_characteristics_skel, 0},
      {"_get_characteristic_component_name", &POA_ActiveSurface::ROTASOneWayAction::_get_characteristic_component_name_skel, 0},
      {"",0,0},
      {"new_subscription_AlarmEnum", &POA_ActiveSurface::ROTASOneWayAction::new_subscription_AlarmEnum_skel, 0},
      {"",0,0},
      {"get_sync", &POA_ActiveSurface::ROTASOneWayAction::get_sync_skel, 0},
      {"get_async", &POA_ActiveSurface::ROTASOneWayAction::get_async_skel, 0},
      {"_component", &POA_ActiveSurface::ROTASOneWayAction::_component_skel, 0},
      {"_get_format", &POA_ActiveSurface::ROTASOneWayAction::_get_format_skel, 0},
      {"",0,0},
      {"_non_existent", &POA_ActiveSurface::ROTASOneWayAction::_non_existent_skel, 0},
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"create_monitor", &POA_ActiveSurface::ROTASOneWayAction::create_monitor_skel, 0},
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"find_characteristic", &POA_ActiveSurface::ROTASOneWayAction::find_characteristic_skel, 0},
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"create_postponed_monitor", &POA_ActiveSurface::ROTASOneWayAction::create_postponed_monitor_skel, 0},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname;

          if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}

static TAO_ActiveSurface_ROTASOneWayAction_Perfect_Hash_OpTable tao_ActiveSurface_ROTASOneWayAction_optable;

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ss.cpp:984

TAO::Collocation_Proxy_Broker *
ActiveSurface__TAO_ROTASOneWayAction_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
ActiveSurface__TAO_ROTASOneWayAction_Proxy_Broker_Factory_Initializer (size_t)
{
  ActiveSurface__TAO_ROTASOneWayAction_Proxy_Broker_Factory_function_pointer = 
    ActiveSurface__TAO_ROTASOneWayAction_Proxy_Broker_Factory_function;
  
  return 0;
}

static int
ActiveSurface__TAO_ROTASOneWayAction_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  ActiveSurface__TAO_ROTASOneWayAction_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (ActiveSurface__TAO_ROTASOneWayAction_Proxy_Broker_Factory_Initializer)
    );

// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_ss.cpp:103

POA_ActiveSurface::ROTASOneWayAction::ROTASOneWayAction (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_ActiveSurface_ROTASOneWayAction_optable;
}

POA_ActiveSurface::ROTASOneWayAction::ROTASOneWayAction (const ROTASOneWayAction& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_ACS::CharacteristicModel (rhs),
    POA_ACS::OffShoot (rhs),
    POA_ACS::Property (rhs),
    POA_ACS::TypelessProperty (rhs),
    POA_ActiveSurface::PTASOneWayAction (rhs)
{
}

POA_ActiveSurface::ROTASOneWayAction::~ROTASOneWayAction (void)
{
}
namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class new_subscription_AlarmEnum_ROTASOneWayAction
    : public TAO::Upcall_Command
  {
  public:
    inline new_subscription_AlarmEnum_ROTASOneWayAction (
      POA_ActiveSurface::ROTASOneWayAction * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACS::Subscription>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACS::Subscription> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::ACS::Alarmpattern>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::ACS::Alarmpattern> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::ACS::CBDescIn>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::ACS::CBDescIn> (
          this->operation_details_,
          this->args_,
          2);
        
      retval =
        this->servant_->new_subscription_AlarmEnum (
          arg_1
          , arg_2);
    }
  
  private:
    POA_ActiveSurface::ROTASOneWayAction * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from 
// be/be_visitor_operation/operation_ss.cpp:190

void POA_ActiveSurface::ROTASOneWayAction::new_subscription_AlarmEnum_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACS::Subscription>::ret_val retval;
  TAO::SArg_Traits< ::ACS::Alarmpattern>::in_arg_val _tao_cb;
  TAO::SArg_Traits< ::ACS::CBDescIn>::in_arg_val _tao_desc;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_cb,
      &_tao_desc
    };
  
  static size_t const nargs = 3;
  
  POA_ActiveSurface::ROTASOneWayAction * const impl =
    static_cast<POA_ActiveSurface::ROTASOneWayAction *> (servant);

  new_subscription_AlarmEnum_ROTASOneWayAction command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class _get_alarm_on_ROTASOneWayAction
    : public TAO::Upcall_Command
  {
  public:
    inline _get_alarm_on_ROTASOneWayAction (
      POA_ActiveSurface::ROTASOneWayAction * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ActiveSurface::TASOneWayActionSeq>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ActiveSurface::TASOneWayActionSeq> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_->alarm_on ();
    }
  
  private:
    POA_ActiveSurface::ROTASOneWayAction * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from 
// be/be_visitor_operation/operation_ss.cpp:190

void POA_ActiveSurface::ROTASOneWayAction::_get_alarm_on_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ActiveSurface::TASOneWayActionSeq>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_ActiveSurface::ROTASOneWayAction * const impl =
    static_cast<POA_ActiveSurface::ROTASOneWayAction *> (servant);

  _get_alarm_on_ROTASOneWayAction command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class _get_alarm_off_ROTASOneWayAction
    : public TAO::Upcall_Command
  {
  public:
    inline _get_alarm_off_ROTASOneWayAction (
      POA_ActiveSurface::ROTASOneWayAction * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ActiveSurface::TASOneWayActionSeq>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ActiveSurface::TASOneWayActionSeq> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_->alarm_off ();
    }
  
  private:
    POA_ActiveSurface::ROTASOneWayAction * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from 
// be/be_visitor_operation/operation_ss.cpp:190

void POA_ActiveSurface::ROTASOneWayAction::_get_alarm_off_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ActiveSurface::TASOneWayActionSeq>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_ActiveSurface::ROTASOneWayAction * const impl =
    static_cast<POA_ActiveSurface::ROTASOneWayAction *> (servant);

  _get_alarm_off_ROTASOneWayAction command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}



// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_ss.cpp:169

namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class _is_a_ROTASOneWayAction_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _is_a_ROTASOneWayAction_Upcall_Command (
      POA_ActiveSurface::ROTASOneWayAction * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::CORBA::Char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Char *> (
          this->operation_details_,
          this->args_,
          1);
        
      retval =
        this->servant_-> _is_a (
          arg_1);
    }
  
  private:
    POA_ActiveSurface::ROTASOneWayAction * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_ActiveSurface::ROTASOneWayAction::_is_a_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Char *>::in_arg_val _tao_repository_id;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };
  
  static size_t const nargs = 2;
  
  POA_ActiveSurface::ROTASOneWayAction * const impl =
    static_cast<POA_ActiveSurface::ROTASOneWayAction *> (servant);
  
  _is_a_ROTASOneWayAction_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class _non_existent_ROTASOneWayAction_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _non_existent_ROTASOneWayAction_Upcall_Command (
      POA_ActiveSurface::ROTASOneWayAction * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _non_existent ();
    }
  
  private:
    POA_ActiveSurface::ROTASOneWayAction * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_ActiveSurface::ROTASOneWayAction::_non_existent_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_ActiveSurface::ROTASOneWayAction * const impl =
    static_cast<POA_ActiveSurface::ROTASOneWayAction *> (servant);
  
  _non_existent_ROTASOneWayAction_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}
namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class _repository_id_ROTASOneWayAction_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _repository_id_ROTASOneWayAction_Upcall_Command (
      POA_ActiveSurface::ROTASOneWayAction * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Char *>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Char *> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _repository_id ();
    }
  
  private:
    POA_ActiveSurface::ROTASOneWayAction * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_ActiveSurface::ROTASOneWayAction::_repository_id_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::Char *>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_ActiveSurface::ROTASOneWayAction * const impl =
    static_cast<POA_ActiveSurface::ROTASOneWayAction *> (servant);
  
  _repository_id_ROTASOneWayAction_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_ss.cpp:508

void POA_ActiveSurface::ROTASOneWayAction::_interface_skel (
    TAO_ServerRequest & server_request, 
    void * /* servant_upcall */,
    void * servant)
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (_tao_adapter == 0)
    {
      throw ::CORBA::INTF_REPOS (::CORBA::OMGVMCID | 1, ::CORBA::COMPLETED_NO);
    }
  
  POA_ActiveSurface::ROTASOneWayAction * const impl =
    static_cast<POA_ActiveSurface::ROTASOneWayAction *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval = impl->_get_interface ();
  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();
  
  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (_tao_out, _tao_retval);
  
  _tao_adapter->dispose (_tao_retval);
  
  if (_tao_result == false)
    {
      throw ::CORBA::MARSHAL ();
    }
}

namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class _get_component_ROTASOneWayAction_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _get_component_ROTASOneWayAction_Upcall_Command (
      POA_ActiveSurface::ROTASOneWayAction * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _get_component ();
    }
  
  private:
    POA_ActiveSurface::ROTASOneWayAction * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_ActiveSurface::ROTASOneWayAction::_component_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_ActiveSurface::ROTASOneWayAction * const impl =
    static_cast<POA_ActiveSurface::ROTASOneWayAction *> (servant);
  
  _get_component_ROTASOneWayAction_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

::CORBA::Boolean POA_ActiveSurface::ROTASOneWayAction::_is_a (const char* value)
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:alma/ACS/CharacteristicModel:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:alma/ACS/OffShoot:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:alma/ACS/Property:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:alma/ACS/TypelessProperty:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:alma/ActiveSurface/PTASOneWayAction:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:alma/ActiveSurface/ROTASOneWayAction:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_ActiveSurface::ROTASOneWayAction::_interface_repository_id (void) const
{
  return "IDL:alma/ActiveSurface/ROTASOneWayAction:1.0";
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ss.cpp:926

void POA_ActiveSurface::ROTASOneWayAction::_dispatch (TAO_ServerRequest & req, void * servant_upcall)
{
  this->synchronous_upcall_dispatch (req, servant_upcall, this);
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ss.cpp:852

ActiveSurface::ROTASOneWayAction *
POA_ActiveSurface::ROTASOneWayAction::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();
  
  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object_ptr ();
  
  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );
  
  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();
  
  typedef ::ActiveSurface::ROTASOneWayAction STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        ActiveSurface__TAO_ROTASOneWayAction_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// be/be_interface.cpp:1555

class TAO_ActiveSurface_RWTASOneWayAction_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: /alma/ACS-8.2/TAO/ACE_wrappers/build/linux/bin/gperf -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_ActiveSurface_RWTASOneWayAction_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_ActiveSurface_RWTASOneWayAction_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     62, 62, 62, 62, 62, 62, 62, 62, 62, 62,
     62, 62, 62, 62, 62, 62, 62, 62, 62, 62,
     62, 62, 62, 62, 62, 62, 62, 62, 62, 62,
     62, 62, 62, 62, 62, 62, 62, 62, 62, 62,
     62, 62, 62, 62, 62, 62, 62, 62, 62, 62,
     62, 62, 62, 62, 62, 62, 62, 62, 62, 62,
     62, 62, 62, 62, 62, 62, 62, 62, 62, 62,
     62, 62, 62, 62, 62, 62, 62, 62, 62, 62,
     62, 62, 62, 62, 62, 62, 62, 62, 62, 62,
     62, 62, 62, 62, 62, 62, 62, 62, 62, 62,
     62, 62, 62, 62, 62, 62, 62, 62, 62,  0,
     62, 62, 62, 62, 62, 62, 62, 62, 62, 62,
     62, 62, 62, 62, 62, 62, 62, 62, 62,  0,
     62,  0, 10, 10,  3, 25, 62, 62, 62, 62,
     62, 62, 62, 62, 62, 62, 62, 62, 62, 15,
     62, 62, 62, 25, 62, 62, 62, 62, 62, 62,
     62, 62,  0,  5, 62, 62, 62, 62,  0, 62,
     62, 62, 62, 62, 62, 62, 62, 62, 62, 62,
     62, 62, 62, 62, 62, 62, 62, 62, 62, 62,
     62, 62, 62, 62, 62, 62, 62, 62, 62, 62,
     62, 62, 62, 62, 62, 62, 62, 62, 62, 62,
     62, 62, 62, 62, 62, 62, 62, 62, 62, 62,
     62, 62, 62, 62, 62, 62, 62, 62, 62, 62,
     62, 62, 62, 62, 62, 62, 62, 62, 62, 62,
     62, 62, 62, 62, 62, 62, 62, 62, 62, 62,
     62, 62, 62, 62, 62, 62,
#else
     62, 62, 62, 62, 62, 62, 62, 62, 62, 62,
     62, 62, 62, 62, 62, 62, 62, 62, 62, 62,
     62, 62, 62, 62, 62, 62, 62, 62, 62, 62,
     62, 62, 62, 62, 62, 62, 62, 62, 62, 62,
     62, 62, 62, 62, 62, 62, 62, 62, 62, 62,
     62, 62, 62, 62, 62, 62, 62, 62, 62, 62,
     62, 62, 62, 62, 62, 62, 62, 62, 62, 62,
     62, 62, 62, 62, 62, 62, 62, 62, 62, 62,
     62, 62, 62, 62, 62, 62, 62, 62, 62, 62,
     62, 62, 62, 62, 62,  0, 62,  0, 62,  0,
     10, 10,  3, 25, 62, 62, 62, 62, 62, 62,
     15, 62, 62, 62, 25,  0,  5, 62, 62, 62,
     62,  0, 62, 62, 62, 62, 62, 62,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_ActiveSurface_RWTASOneWayAction_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 28,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 34,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 61,
      HASH_VALUE_RANGE = 57,
      DUPLICATES = 0,
      WORDLIST_SIZE = 33
    };

  static const TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"_is_a", &POA_ActiveSurface::RWTASOneWayAction::_is_a_skel, 0},
      {"",0,0},{"",0,0},
      {"set_sync", &POA_ActiveSurface::RWTASOneWayAction::set_sync_skel, 0},
      {"set_async", &POA_ActiveSurface::RWTASOneWayAction::set_async_skel, 0},
      {"_get_units", &POA_ActiveSurface::RWTASOneWayAction::_get_units_skel, 0},
      {"",0,0},{"",0,0},{"",0,0},
      {"_get_allStates", &POA_ActiveSurface::RWTASOneWayAction::_get_allStates_skel, 0},
      {"_component", &POA_ActiveSurface::RWTASOneWayAction::_component_skel, 0},
      {"_get_format", &POA_ActiveSurface::RWTASOneWayAction::_get_format_skel, 0},
      {"",0,0},
      {"_non_existent", &POA_ActiveSurface::RWTASOneWayAction::_non_existent_skel, 0},
      {"_get_name", &POA_ActiveSurface::RWTASOneWayAction::_get_name_skel, 0},
      {"_interface", &POA_ActiveSurface::RWTASOneWayAction::_interface_skel, 0},
      {"",0,0},
      {"find_characteristic", &POA_ActiveSurface::RWTASOneWayAction::find_characteristic_skel, 0},
      {"",0,0},
      {"_repository_id", &POA_ActiveSurface::RWTASOneWayAction::_repository_id_skel, 0},
      {"",0,0},{"",0,0},{"",0,0},
      {"_get_default_value", &POA_ActiveSurface::RWTASOneWayAction::_get_default_value_skel, 0},
      {"_get_condition", &POA_ActiveSurface::RWTASOneWayAction::_get_condition_skel, 0},
      {"_get_resolution", &POA_ActiveSurface::RWTASOneWayAction::_get_resolution_skel, 0},
      {"_get_description", &POA_ActiveSurface::RWTASOneWayAction::_get_description_skel, 0},
      {"",0,0},
      {"get_sync", &POA_ActiveSurface::RWTASOneWayAction::get_sync_skel, 0},
      {"get_async", &POA_ActiveSurface::RWTASOneWayAction::get_async_skel, 0},
      {"",0,0},
      {"get_history", &POA_ActiveSurface::RWTASOneWayAction::get_history_skel, 0},
      {"_get_statesDescription", &POA_ActiveSurface::RWTASOneWayAction::_get_statesDescription_skel, 0},
      {"",0,0},
      {"create_monitor", &POA_ActiveSurface::RWTASOneWayAction::create_monitor_skel, 0},
      {"set_nonblocking", &POA_ActiveSurface::RWTASOneWayAction::set_nonblocking_skel, 0},
      {"",0,0},{"",0,0},{"",0,0},
      {"_get_characteristic_component_name", &POA_ActiveSurface::RWTASOneWayAction::_get_characteristic_component_name_skel, 0},
      {"",0,0},{"",0,0},
      {"_get_min_timer_trigger", &POA_ActiveSurface::RWTASOneWayAction::_get_min_timer_trigger_skel, 0},
      {"get_all_characteristics", &POA_ActiveSurface::RWTASOneWayAction::get_all_characteristics_skel, 0},
      {"create_postponed_monitor", &POA_ActiveSurface::RWTASOneWayAction::create_postponed_monitor_skel, 0},
      {"",0,0},
      {"_get_default_timer_trigger", &POA_ActiveSurface::RWTASOneWayAction::_get_default_timer_trigger_skel, 0},
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"get_characteristic_by_name", &POA_ActiveSurface::RWTASOneWayAction::get_characteristic_by_name_skel, 0},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname;

          if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}

static TAO_ActiveSurface_RWTASOneWayAction_Perfect_Hash_OpTable tao_ActiveSurface_RWTASOneWayAction_optable;

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ss.cpp:984

TAO::Collocation_Proxy_Broker *
ActiveSurface__TAO_RWTASOneWayAction_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
ActiveSurface__TAO_RWTASOneWayAction_Proxy_Broker_Factory_Initializer (size_t)
{
  ActiveSurface__TAO_RWTASOneWayAction_Proxy_Broker_Factory_function_pointer = 
    ActiveSurface__TAO_RWTASOneWayAction_Proxy_Broker_Factory_function;
  
  return 0;
}

static int
ActiveSurface__TAO_RWTASOneWayAction_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  ActiveSurface__TAO_RWTASOneWayAction_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (ActiveSurface__TAO_RWTASOneWayAction_Proxy_Broker_Factory_Initializer)
    );

// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_ss.cpp:103

POA_ActiveSurface::RWTASOneWayAction::RWTASOneWayAction (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_ActiveSurface_RWTASOneWayAction_optable;
}

POA_ActiveSurface::RWTASOneWayAction::RWTASOneWayAction (const RWTASOneWayAction& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_ACS::CharacteristicModel (rhs),
    POA_ACS::OffShoot (rhs),
    POA_ACS::Property (rhs),
    POA_ACS::TypelessProperty (rhs),
    POA_ActiveSurface::PTASOneWayAction (rhs)
{
}

POA_ActiveSurface::RWTASOneWayAction::~RWTASOneWayAction (void)
{
}
namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class set_sync_RWTASOneWayAction
    : public TAO::Upcall_Command
  {
  public:
    inline set_sync_RWTASOneWayAction (
      POA_ActiveSurface::RWTASOneWayAction * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACSErr::Completion>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACSErr::Completion> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::ActiveSurface::TASOneWayAction>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::ActiveSurface::TASOneWayAction> (
          this->operation_details_,
          this->args_,
          1);
        
      retval =
        this->servant_->set_sync (
          arg_1);
    }
  
  private:
    POA_ActiveSurface::RWTASOneWayAction * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from 
// be/be_visitor_operation/operation_ss.cpp:190

void POA_ActiveSurface::RWTASOneWayAction::set_sync_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACSErr::Completion>::ret_val retval;
  TAO::SArg_Traits< ::ActiveSurface::TASOneWayAction>::in_arg_val _tao_value;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_value
    };
  
  static size_t const nargs = 2;
  
  POA_ActiveSurface::RWTASOneWayAction * const impl =
    static_cast<POA_ActiveSurface::RWTASOneWayAction *> (servant);

  set_sync_RWTASOneWayAction command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class set_async_RWTASOneWayAction
    : public TAO::Upcall_Command
  {
  public:
    inline set_async_RWTASOneWayAction (
      POA_ActiveSurface::RWTASOneWayAction * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ActiveSurface::TASOneWayAction>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::ActiveSurface::TASOneWayAction> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::ACS::CBvoid>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::ACS::CBvoid> (
          this->operation_details_,
          this->args_,
          2);
        
      TAO::SArg_Traits< ::ACS::CBDescIn>::in_arg_type arg_3 =
        TAO::Portable_Server::get_in_arg< ::ACS::CBDescIn> (
          this->operation_details_,
          this->args_,
          3);
        
      this->servant_->set_async (
        arg_1
        , arg_2
        , arg_3);
    }
  
  private:
    POA_ActiveSurface::RWTASOneWayAction * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from 
// be/be_visitor_operation/operation_ss.cpp:190

void POA_ActiveSurface::RWTASOneWayAction::set_async_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::ActiveSurface::TASOneWayAction>::in_arg_val _tao_value;
  TAO::SArg_Traits< ::ACS::CBvoid>::in_arg_val _tao_cb;
  TAO::SArg_Traits< ::ACS::CBDescIn>::in_arg_val _tao_desc;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_value,
      &_tao_cb,
      &_tao_desc
    };
  
  static size_t const nargs = 4;
  
  POA_ActiveSurface::RWTASOneWayAction * const impl =
    static_cast<POA_ActiveSurface::RWTASOneWayAction *> (servant);

  set_async_RWTASOneWayAction command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class set_nonblocking_RWTASOneWayAction
    : public TAO::Upcall_Command
  {
  public:
    inline set_nonblocking_RWTASOneWayAction (
      POA_ActiveSurface::RWTASOneWayAction * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ActiveSurface::TASOneWayAction>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::ActiveSurface::TASOneWayAction> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->set_nonblocking (
        arg_1);
    }
  
  private:
    POA_ActiveSurface::RWTASOneWayAction * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from 
// be/be_visitor_operation/operation_ss.cpp:190

void POA_ActiveSurface::RWTASOneWayAction::set_nonblocking_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::ActiveSurface::TASOneWayAction>::in_arg_val _tao_value;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_value
    };
  
  static size_t const nargs = 2;
  
  POA_ActiveSurface::RWTASOneWayAction * const impl =
    static_cast<POA_ActiveSurface::RWTASOneWayAction *> (servant);

  set_nonblocking_RWTASOneWayAction command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}



// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_ss.cpp:169

namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class _is_a_RWTASOneWayAction_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _is_a_RWTASOneWayAction_Upcall_Command (
      POA_ActiveSurface::RWTASOneWayAction * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::CORBA::Char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Char *> (
          this->operation_details_,
          this->args_,
          1);
        
      retval =
        this->servant_-> _is_a (
          arg_1);
    }
  
  private:
    POA_ActiveSurface::RWTASOneWayAction * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_ActiveSurface::RWTASOneWayAction::_is_a_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Char *>::in_arg_val _tao_repository_id;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };
  
  static size_t const nargs = 2;
  
  POA_ActiveSurface::RWTASOneWayAction * const impl =
    static_cast<POA_ActiveSurface::RWTASOneWayAction *> (servant);
  
  _is_a_RWTASOneWayAction_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class _non_existent_RWTASOneWayAction_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _non_existent_RWTASOneWayAction_Upcall_Command (
      POA_ActiveSurface::RWTASOneWayAction * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _non_existent ();
    }
  
  private:
    POA_ActiveSurface::RWTASOneWayAction * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_ActiveSurface::RWTASOneWayAction::_non_existent_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_ActiveSurface::RWTASOneWayAction * const impl =
    static_cast<POA_ActiveSurface::RWTASOneWayAction *> (servant);
  
  _non_existent_RWTASOneWayAction_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}
namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class _repository_id_RWTASOneWayAction_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _repository_id_RWTASOneWayAction_Upcall_Command (
      POA_ActiveSurface::RWTASOneWayAction * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Char *>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Char *> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _repository_id ();
    }
  
  private:
    POA_ActiveSurface::RWTASOneWayAction * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_ActiveSurface::RWTASOneWayAction::_repository_id_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::Char *>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_ActiveSurface::RWTASOneWayAction * const impl =
    static_cast<POA_ActiveSurface::RWTASOneWayAction *> (servant);
  
  _repository_id_RWTASOneWayAction_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_ss.cpp:508

void POA_ActiveSurface::RWTASOneWayAction::_interface_skel (
    TAO_ServerRequest & server_request, 
    void * /* servant_upcall */,
    void * servant)
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (_tao_adapter == 0)
    {
      throw ::CORBA::INTF_REPOS (::CORBA::OMGVMCID | 1, ::CORBA::COMPLETED_NO);
    }
  
  POA_ActiveSurface::RWTASOneWayAction * const impl =
    static_cast<POA_ActiveSurface::RWTASOneWayAction *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval = impl->_get_interface ();
  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();
  
  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (_tao_out, _tao_retval);
  
  _tao_adapter->dispose (_tao_retval);
  
  if (_tao_result == false)
    {
      throw ::CORBA::MARSHAL ();
    }
}

namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class _get_component_RWTASOneWayAction_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _get_component_RWTASOneWayAction_Upcall_Command (
      POA_ActiveSurface::RWTASOneWayAction * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _get_component ();
    }
  
  private:
    POA_ActiveSurface::RWTASOneWayAction * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_ActiveSurface::RWTASOneWayAction::_component_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_ActiveSurface::RWTASOneWayAction * const impl =
    static_cast<POA_ActiveSurface::RWTASOneWayAction *> (servant);
  
  _get_component_RWTASOneWayAction_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

::CORBA::Boolean POA_ActiveSurface::RWTASOneWayAction::_is_a (const char* value)
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:alma/ACS/CharacteristicModel:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:alma/ACS/OffShoot:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:alma/ACS/Property:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:alma/ACS/TypelessProperty:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:alma/ActiveSurface/PTASOneWayAction:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:alma/ActiveSurface/RWTASOneWayAction:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_ActiveSurface::RWTASOneWayAction::_interface_repository_id (void) const
{
  return "IDL:alma/ActiveSurface/RWTASOneWayAction:1.0";
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ss.cpp:926

void POA_ActiveSurface::RWTASOneWayAction::_dispatch (TAO_ServerRequest & req, void * servant_upcall)
{
  this->synchronous_upcall_dispatch (req, servant_upcall, this);
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ss.cpp:852

ActiveSurface::RWTASOneWayAction *
POA_ActiveSurface::RWTASOneWayAction::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();
  
  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object_ptr ();
  
  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );
  
  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();
  
  typedef ::ActiveSurface::RWTASOneWayAction STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        ActiveSurface__TAO_RWTASOneWayAction_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// be/be_interface.cpp:1555

class TAO_ActiveSurface_CBTASProfile_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: /alma/ACS-8.2/TAO/ACE_wrappers/build/linux/bin/gperf -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_ActiveSurface_CBTASProfile_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_ActiveSurface_CBTASProfile_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19,  0,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19,  0,
     19, 19,  0,  0, 19,  0, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19,  0,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19,  5, 19, 19,  0, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19,
#else
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19,  0, 19,  0, 19, 19,
      0,  0, 19,  0, 19, 19, 19, 19, 19, 19,
      0, 19, 19, 19, 19, 19,  5, 19, 19,  0,
     19, 19, 19, 19, 19, 19, 19, 19,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_ActiveSurface_CBTASProfile_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 8,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 14,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 18,
      HASH_VALUE_RANGE = 15,
      DUPLICATES = 0,
      WORDLIST_SIZE = 12
    };

  static const TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"done", &POA_ActiveSurface::CBTASProfile::done_skel, 0},
      {"_is_a", &POA_ActiveSurface::CBTASProfile::_is_a_skel, 0},
      {"",0,0},
      {"working", &POA_ActiveSurface::CBTASProfile::working_skel, 0},
      {"",0,0},
      {"negotiate", &POA_ActiveSurface::CBTASProfile::negotiate_skel, 0},
      {"_interface", &POA_ActiveSurface::CBTASProfile::_interface_skel, 0},
      {"",0,0},{"",0,0},{"",0,0},
      {"_repository_id", &POA_ActiveSurface::CBTASProfile::_repository_id_skel, 0},
      {"_component", &POA_ActiveSurface::CBTASProfile::_component_skel, 0},
      {"",0,0},{"",0,0},
      {"_non_existent", &POA_ActiveSurface::CBTASProfile::_non_existent_skel, 0},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname;

          if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}

static TAO_ActiveSurface_CBTASProfile_Perfect_Hash_OpTable tao_ActiveSurface_CBTASProfile_optable;

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ss.cpp:984

TAO::Collocation_Proxy_Broker *
ActiveSurface__TAO_CBTASProfile_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
ActiveSurface__TAO_CBTASProfile_Proxy_Broker_Factory_Initializer (size_t)
{
  ActiveSurface__TAO_CBTASProfile_Proxy_Broker_Factory_function_pointer = 
    ActiveSurface__TAO_CBTASProfile_Proxy_Broker_Factory_function;
  
  return 0;
}

static int
ActiveSurface__TAO_CBTASProfile_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  ActiveSurface__TAO_CBTASProfile_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (ActiveSurface__TAO_CBTASProfile_Proxy_Broker_Factory_Initializer)
    );

// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_ss.cpp:103

POA_ActiveSurface::CBTASProfile::CBTASProfile (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_ActiveSurface_CBTASProfile_optable;
}

POA_ActiveSurface::CBTASProfile::CBTASProfile (const CBTASProfile& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_ACS::OffShoot (rhs),
    POA_ACS::Callback (rhs)
{
}

POA_ActiveSurface::CBTASProfile::~CBTASProfile (void)
{
}
namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class working_CBTASProfile
    : public TAO::Upcall_Command
  {
  public:
    inline working_CBTASProfile (
      POA_ActiveSurface::CBTASProfile * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ActiveSurface::TASProfile>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::ActiveSurface::TASProfile> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::ACSErr::Completion>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::ACSErr::Completion> (
          this->operation_details_,
          this->args_,
          2);
        
      TAO::SArg_Traits< ::ACS::CBDescOut>::in_arg_type arg_3 =
        TAO::Portable_Server::get_in_arg< ::ACS::CBDescOut> (
          this->operation_details_,
          this->args_,
          3);
        
      this->servant_->working (
        arg_1
        , arg_2
        , arg_3);
    }
  
  private:
    POA_ActiveSurface::CBTASProfile * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from 
// be/be_visitor_operation/operation_ss.cpp:190

void POA_ActiveSurface::CBTASProfile::working_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::ActiveSurface::TASProfile>::in_arg_val _tao_value;
  TAO::SArg_Traits< ::ACSErr::Completion>::in_arg_val _tao_c;
  TAO::SArg_Traits< ::ACS::CBDescOut>::in_arg_val _tao_desc;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_value,
      &_tao_c,
      &_tao_desc
    };
  
  static size_t const nargs = 4;
  
  POA_ActiveSurface::CBTASProfile * const impl =
    static_cast<POA_ActiveSurface::CBTASProfile *> (servant);

  working_CBTASProfile command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class done_CBTASProfile
    : public TAO::Upcall_Command
  {
  public:
    inline done_CBTASProfile (
      POA_ActiveSurface::CBTASProfile * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ActiveSurface::TASProfile>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::ActiveSurface::TASProfile> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::ACSErr::Completion>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::ACSErr::Completion> (
          this->operation_details_,
          this->args_,
          2);
        
      TAO::SArg_Traits< ::ACS::CBDescOut>::in_arg_type arg_3 =
        TAO::Portable_Server::get_in_arg< ::ACS::CBDescOut> (
          this->operation_details_,
          this->args_,
          3);
        
      this->servant_->done (
        arg_1
        , arg_2
        , arg_3);
    }
  
  private:
    POA_ActiveSurface::CBTASProfile * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from 
// be/be_visitor_operation/operation_ss.cpp:190

void POA_ActiveSurface::CBTASProfile::done_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::ActiveSurface::TASProfile>::in_arg_val _tao_value;
  TAO::SArg_Traits< ::ACSErr::Completion>::in_arg_val _tao_c;
  TAO::SArg_Traits< ::ACS::CBDescOut>::in_arg_val _tao_desc;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_value,
      &_tao_c,
      &_tao_desc
    };
  
  static size_t const nargs = 4;
  
  POA_ActiveSurface::CBTASProfile * const impl =
    static_cast<POA_ActiveSurface::CBTASProfile *> (servant);

  done_CBTASProfile command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}



// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_ss.cpp:169

namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class _is_a_CBTASProfile_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _is_a_CBTASProfile_Upcall_Command (
      POA_ActiveSurface::CBTASProfile * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::CORBA::Char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Char *> (
          this->operation_details_,
          this->args_,
          1);
        
      retval =
        this->servant_-> _is_a (
          arg_1);
    }
  
  private:
    POA_ActiveSurface::CBTASProfile * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_ActiveSurface::CBTASProfile::_is_a_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Char *>::in_arg_val _tao_repository_id;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };
  
  static size_t const nargs = 2;
  
  POA_ActiveSurface::CBTASProfile * const impl =
    static_cast<POA_ActiveSurface::CBTASProfile *> (servant);
  
  _is_a_CBTASProfile_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class _non_existent_CBTASProfile_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _non_existent_CBTASProfile_Upcall_Command (
      POA_ActiveSurface::CBTASProfile * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _non_existent ();
    }
  
  private:
    POA_ActiveSurface::CBTASProfile * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_ActiveSurface::CBTASProfile::_non_existent_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_ActiveSurface::CBTASProfile * const impl =
    static_cast<POA_ActiveSurface::CBTASProfile *> (servant);
  
  _non_existent_CBTASProfile_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}
namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class _repository_id_CBTASProfile_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _repository_id_CBTASProfile_Upcall_Command (
      POA_ActiveSurface::CBTASProfile * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Char *>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Char *> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _repository_id ();
    }
  
  private:
    POA_ActiveSurface::CBTASProfile * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_ActiveSurface::CBTASProfile::_repository_id_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::Char *>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_ActiveSurface::CBTASProfile * const impl =
    static_cast<POA_ActiveSurface::CBTASProfile *> (servant);
  
  _repository_id_CBTASProfile_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_ss.cpp:508

void POA_ActiveSurface::CBTASProfile::_interface_skel (
    TAO_ServerRequest & server_request, 
    void * /* servant_upcall */,
    void * servant)
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (_tao_adapter == 0)
    {
      throw ::CORBA::INTF_REPOS (::CORBA::OMGVMCID | 1, ::CORBA::COMPLETED_NO);
    }
  
  POA_ActiveSurface::CBTASProfile * const impl =
    static_cast<POA_ActiveSurface::CBTASProfile *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval = impl->_get_interface ();
  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();
  
  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (_tao_out, _tao_retval);
  
  _tao_adapter->dispose (_tao_retval);
  
  if (_tao_result == false)
    {
      throw ::CORBA::MARSHAL ();
    }
}

namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class _get_component_CBTASProfile_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _get_component_CBTASProfile_Upcall_Command (
      POA_ActiveSurface::CBTASProfile * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _get_component ();
    }
  
  private:
    POA_ActiveSurface::CBTASProfile * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_ActiveSurface::CBTASProfile::_component_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_ActiveSurface::CBTASProfile * const impl =
    static_cast<POA_ActiveSurface::CBTASProfile *> (servant);
  
  _get_component_CBTASProfile_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

::CORBA::Boolean POA_ActiveSurface::CBTASProfile::_is_a (const char* value)
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:alma/ACS/OffShoot:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:alma/ACS/Callback:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:alma/ActiveSurface/CBTASProfile:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_ActiveSurface::CBTASProfile::_interface_repository_id (void) const
{
  return "IDL:alma/ActiveSurface/CBTASProfile:1.0";
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ss.cpp:926

void POA_ActiveSurface::CBTASProfile::_dispatch (TAO_ServerRequest & req, void * servant_upcall)
{
  this->synchronous_upcall_dispatch (req, servant_upcall, this);
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ss.cpp:852

ActiveSurface::CBTASProfile *
POA_ActiveSurface::CBTASProfile::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();
  
  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object_ptr ();
  
  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );
  
  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();
  
  typedef ::ActiveSurface::CBTASProfile STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        ActiveSurface__TAO_CBTASProfile_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// be/be_interface.cpp:1555

class TAO_ActiveSurface_AlarmTASProfile_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: /alma/ACS-8.2/TAO/ACE_wrappers/build/linux/bin/gperf -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_ActiveSurface_AlarmTASProfile_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_ActiveSurface_AlarmTASProfile_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19,  0,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19,  0,
     19, 19,  0,  0, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19,  0,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19,  5, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19,
#else
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19,  0, 19,  0, 19, 19,
      0,  0, 19, 19, 19, 19, 19, 19, 19, 19,
      0, 19, 19, 19, 19, 19,  5, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_ActiveSurface_AlarmTASProfile_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 8,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 14,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 18,
      HASH_VALUE_RANGE = 14,
      DUPLICATES = 0,
      WORDLIST_SIZE = 13
    };

  static const TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"_is_a", &POA_ActiveSurface::AlarmTASProfile::_is_a_skel, 0},
      {"",0,0},{"",0,0},{"",0,0},
      {"negotiate", &POA_ActiveSurface::AlarmTASProfile::negotiate_skel, 0},
      {"_interface", &POA_ActiveSurface::AlarmTASProfile::_interface_skel, 0},
      {"",0,0},
      {"alarm_raised", &POA_ActiveSurface::AlarmTASProfile::alarm_raised_skel, 0},
      {"alarm_cleared", &POA_ActiveSurface::AlarmTASProfile::alarm_cleared_skel, 0},
      {"_repository_id", &POA_ActiveSurface::AlarmTASProfile::_repository_id_skel, 0},
      {"_component", &POA_ActiveSurface::AlarmTASProfile::_component_skel, 0},
      {"",0,0},{"",0,0},
      {"_non_existent", &POA_ActiveSurface::AlarmTASProfile::_non_existent_skel, 0},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname;

          if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}

static TAO_ActiveSurface_AlarmTASProfile_Perfect_Hash_OpTable tao_ActiveSurface_AlarmTASProfile_optable;

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ss.cpp:984

TAO::Collocation_Proxy_Broker *
ActiveSurface__TAO_AlarmTASProfile_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
ActiveSurface__TAO_AlarmTASProfile_Proxy_Broker_Factory_Initializer (size_t)
{
  ActiveSurface__TAO_AlarmTASProfile_Proxy_Broker_Factory_function_pointer = 
    ActiveSurface__TAO_AlarmTASProfile_Proxy_Broker_Factory_function;
  
  return 0;
}

static int
ActiveSurface__TAO_AlarmTASProfile_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  ActiveSurface__TAO_AlarmTASProfile_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (ActiveSurface__TAO_AlarmTASProfile_Proxy_Broker_Factory_Initializer)
    );

// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_ss.cpp:103

POA_ActiveSurface::AlarmTASProfile::AlarmTASProfile (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_ActiveSurface_AlarmTASProfile_optable;
}

POA_ActiveSurface::AlarmTASProfile::AlarmTASProfile (const AlarmTASProfile& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_ACS::OffShoot (rhs),
    POA_ACS::Callback (rhs)
{
}

POA_ActiveSurface::AlarmTASProfile::~AlarmTASProfile (void)
{
}
namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class alarm_raised_AlarmTASProfile
    : public TAO::Upcall_Command
  {
  public:
    inline alarm_raised_AlarmTASProfile (
      POA_ActiveSurface::AlarmTASProfile * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ActiveSurface::TASProfile>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::ActiveSurface::TASProfile> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::ACSErr::Completion>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::ACSErr::Completion> (
          this->operation_details_,
          this->args_,
          2);
        
      TAO::SArg_Traits< ::ACS::CBDescOut>::in_arg_type arg_3 =
        TAO::Portable_Server::get_in_arg< ::ACS::CBDescOut> (
          this->operation_details_,
          this->args_,
          3);
        
      this->servant_->alarm_raised (
        arg_1
        , arg_2
        , arg_3);
    }
  
  private:
    POA_ActiveSurface::AlarmTASProfile * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from 
// be/be_visitor_operation/operation_ss.cpp:190

void POA_ActiveSurface::AlarmTASProfile::alarm_raised_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::ActiveSurface::TASProfile>::in_arg_val _tao_value;
  TAO::SArg_Traits< ::ACSErr::Completion>::in_arg_val _tao_c;
  TAO::SArg_Traits< ::ACS::CBDescOut>::in_arg_val _tao_desc;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_value,
      &_tao_c,
      &_tao_desc
    };
  
  static size_t const nargs = 4;
  
  POA_ActiveSurface::AlarmTASProfile * const impl =
    static_cast<POA_ActiveSurface::AlarmTASProfile *> (servant);

  alarm_raised_AlarmTASProfile command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class alarm_cleared_AlarmTASProfile
    : public TAO::Upcall_Command
  {
  public:
    inline alarm_cleared_AlarmTASProfile (
      POA_ActiveSurface::AlarmTASProfile * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ActiveSurface::TASProfile>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::ActiveSurface::TASProfile> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::ACSErr::Completion>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::ACSErr::Completion> (
          this->operation_details_,
          this->args_,
          2);
        
      TAO::SArg_Traits< ::ACS::CBDescOut>::in_arg_type arg_3 =
        TAO::Portable_Server::get_in_arg< ::ACS::CBDescOut> (
          this->operation_details_,
          this->args_,
          3);
        
      this->servant_->alarm_cleared (
        arg_1
        , arg_2
        , arg_3);
    }
  
  private:
    POA_ActiveSurface::AlarmTASProfile * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from 
// be/be_visitor_operation/operation_ss.cpp:190

void POA_ActiveSurface::AlarmTASProfile::alarm_cleared_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::ActiveSurface::TASProfile>::in_arg_val _tao_value;
  TAO::SArg_Traits< ::ACSErr::Completion>::in_arg_val _tao_c;
  TAO::SArg_Traits< ::ACS::CBDescOut>::in_arg_val _tao_desc;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_value,
      &_tao_c,
      &_tao_desc
    };
  
  static size_t const nargs = 4;
  
  POA_ActiveSurface::AlarmTASProfile * const impl =
    static_cast<POA_ActiveSurface::AlarmTASProfile *> (servant);

  alarm_cleared_AlarmTASProfile command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}



// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_ss.cpp:169

namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class _is_a_AlarmTASProfile_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _is_a_AlarmTASProfile_Upcall_Command (
      POA_ActiveSurface::AlarmTASProfile * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::CORBA::Char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Char *> (
          this->operation_details_,
          this->args_,
          1);
        
      retval =
        this->servant_-> _is_a (
          arg_1);
    }
  
  private:
    POA_ActiveSurface::AlarmTASProfile * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_ActiveSurface::AlarmTASProfile::_is_a_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Char *>::in_arg_val _tao_repository_id;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };
  
  static size_t const nargs = 2;
  
  POA_ActiveSurface::AlarmTASProfile * const impl =
    static_cast<POA_ActiveSurface::AlarmTASProfile *> (servant);
  
  _is_a_AlarmTASProfile_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class _non_existent_AlarmTASProfile_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _non_existent_AlarmTASProfile_Upcall_Command (
      POA_ActiveSurface::AlarmTASProfile * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _non_existent ();
    }
  
  private:
    POA_ActiveSurface::AlarmTASProfile * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_ActiveSurface::AlarmTASProfile::_non_existent_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_ActiveSurface::AlarmTASProfile * const impl =
    static_cast<POA_ActiveSurface::AlarmTASProfile *> (servant);
  
  _non_existent_AlarmTASProfile_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}
namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class _repository_id_AlarmTASProfile_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _repository_id_AlarmTASProfile_Upcall_Command (
      POA_ActiveSurface::AlarmTASProfile * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Char *>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Char *> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _repository_id ();
    }
  
  private:
    POA_ActiveSurface::AlarmTASProfile * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_ActiveSurface::AlarmTASProfile::_repository_id_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::Char *>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_ActiveSurface::AlarmTASProfile * const impl =
    static_cast<POA_ActiveSurface::AlarmTASProfile *> (servant);
  
  _repository_id_AlarmTASProfile_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_ss.cpp:508

void POA_ActiveSurface::AlarmTASProfile::_interface_skel (
    TAO_ServerRequest & server_request, 
    void * /* servant_upcall */,
    void * servant)
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (_tao_adapter == 0)
    {
      throw ::CORBA::INTF_REPOS (::CORBA::OMGVMCID | 1, ::CORBA::COMPLETED_NO);
    }
  
  POA_ActiveSurface::AlarmTASProfile * const impl =
    static_cast<POA_ActiveSurface::AlarmTASProfile *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval = impl->_get_interface ();
  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();
  
  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (_tao_out, _tao_retval);
  
  _tao_adapter->dispose (_tao_retval);
  
  if (_tao_result == false)
    {
      throw ::CORBA::MARSHAL ();
    }
}

namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class _get_component_AlarmTASProfile_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _get_component_AlarmTASProfile_Upcall_Command (
      POA_ActiveSurface::AlarmTASProfile * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _get_component ();
    }
  
  private:
    POA_ActiveSurface::AlarmTASProfile * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_ActiveSurface::AlarmTASProfile::_component_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_ActiveSurface::AlarmTASProfile * const impl =
    static_cast<POA_ActiveSurface::AlarmTASProfile *> (servant);
  
  _get_component_AlarmTASProfile_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

::CORBA::Boolean POA_ActiveSurface::AlarmTASProfile::_is_a (const char* value)
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:alma/ACS/OffShoot:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:alma/ACS/Callback:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:alma/ActiveSurface/AlarmTASProfile:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_ActiveSurface::AlarmTASProfile::_interface_repository_id (void) const
{
  return "IDL:alma/ActiveSurface/AlarmTASProfile:1.0";
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ss.cpp:926

void POA_ActiveSurface::AlarmTASProfile::_dispatch (TAO_ServerRequest & req, void * servant_upcall)
{
  this->synchronous_upcall_dispatch (req, servant_upcall, this);
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ss.cpp:852

ActiveSurface::AlarmTASProfile *
POA_ActiveSurface::AlarmTASProfile::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();
  
  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object_ptr ();
  
  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );
  
  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();
  
  typedef ::ActiveSurface::AlarmTASProfile STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        ActiveSurface__TAO_AlarmTASProfile_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// be/be_interface.cpp:1555

class TAO_ActiveSurface_PTASProfile_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: /alma/ACS-8.2/TAO/ACE_wrappers/build/linux/bin/gperf -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_ActiveSurface_PTASProfile_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_ActiveSurface_PTASProfile_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     50, 50, 50, 50, 50, 50, 50, 50, 50, 50,
     50, 50, 50, 50, 50, 50, 50, 50, 50, 50,
     50, 50, 50, 50, 50, 50, 50, 50, 50, 50,
     50, 50, 50, 50, 50, 50, 50, 50, 50, 50,
     50, 50, 50, 50, 50, 50, 50, 50, 50, 50,
     50, 50, 50, 50, 50, 50, 50, 50, 50, 50,
     50, 50, 50, 50, 50, 50, 50, 50, 50, 50,
     50, 50, 50, 50, 50, 50, 50, 50, 50, 50,
     50, 50, 50, 50, 50, 50, 50, 50, 50, 50,
     50, 50, 50, 50, 50, 50, 50, 50, 50, 50,
     50, 50, 50, 50, 50, 50, 50, 50, 50,  0,
     50, 50, 50, 50, 50, 50, 50, 50, 50, 50,
     50, 50, 50, 50, 50, 50, 50, 50, 50,  0,
     50, 15,  0,  0, 10,  0, 50, 50, 50, 50,
     50, 50, 50, 50, 50, 50, 50, 50, 50,  5,
     50, 50, 50, 10, 50, 50, 50, 50, 50, 50,
     50, 50, 15, 20, 50, 50, 50, 50,  0, 50,
     50, 50, 50, 50, 50, 50, 50, 50, 50, 50,
     50, 50, 50, 50, 50, 50, 50, 50, 50, 50,
     50, 50, 50, 50, 50, 50, 50, 50, 50, 50,
     50, 50, 50, 50, 50, 50, 50, 50, 50, 50,
     50, 50, 50, 50, 50, 50, 50, 50, 50, 50,
     50, 50, 50, 50, 50, 50, 50, 50, 50, 50,
     50, 50, 50, 50, 50, 50, 50, 50, 50, 50,
     50, 50, 50, 50, 50, 50, 50, 50, 50, 50,
     50, 50, 50, 50, 50, 50,
#else
     50, 50, 50, 50, 50, 50, 50, 50, 50, 50,
     50, 50, 50, 50, 50, 50, 50, 50, 50, 50,
     50, 50, 50, 50, 50, 50, 50, 50, 50, 50,
     50, 50, 50, 50, 50, 50, 50, 50, 50, 50,
     50, 50, 50, 50, 50, 50, 50, 50, 50, 50,
     50, 50, 50, 50, 50, 50, 50, 50, 50, 50,
     50, 50, 50, 50, 50, 50, 50, 50, 50, 50,
     50, 50, 50, 50, 50, 50, 50, 50, 50, 50,
     50, 50, 50, 50, 50, 50, 50, 50, 50, 50,
     50, 50, 50, 50, 50,  0, 50,  0, 50, 15,
      0,  0, 10,  0, 50, 50, 50, 50, 50, 50,
      5, 50, 50, 50, 10, 15, 20, 50, 50, 50,
     50,  0, 50, 50, 50, 50, 50, 50,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_ActiveSurface_PTASProfile_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 25,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 34,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 49,
      HASH_VALUE_RANGE = 45,
      DUPLICATES = 0,
      WORDLIST_SIZE = 30
    };

  static const TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"_is_a", &POA_ActiveSurface::PTASProfile::_is_a_skel, 0},
      {"",0,0},{"",0,0},{"",0,0},
      {"_get_name", &POA_ActiveSurface::PTASProfile::_get_name_skel, 0},
      {"_interface", &POA_ActiveSurface::PTASProfile::_interface_skel, 0},
      {"get_history", &POA_ActiveSurface::PTASProfile::get_history_skel, 0},
      {"",0,0},{"",0,0},
      {"_repository_id", &POA_ActiveSurface::PTASProfile::_repository_id_skel, 0},
      {"",0,0},{"",0,0},{"",0,0},
      {"_get_default_value", &POA_ActiveSurface::PTASProfile::_get_default_value_skel, 0},
      {"_get_condition", &POA_ActiveSurface::PTASProfile::_get_condition_skel, 0},
      {"_get_resolution", &POA_ActiveSurface::PTASProfile::_get_resolution_skel, 0},
      {"_get_description", &POA_ActiveSurface::PTASProfile::_get_description_skel, 0},
      {"",0,0},
      {"get_sync", &POA_ActiveSurface::PTASProfile::get_sync_skel, 0},
      {"get_async", &POA_ActiveSurface::PTASProfile::get_async_skel, 0},
      {"_get_units", &POA_ActiveSurface::PTASProfile::_get_units_skel, 0},
      {"get_characteristic_by_name", &POA_ActiveSurface::PTASProfile::get_characteristic_by_name_skel, 0},
      {"_get_statesDescription", &POA_ActiveSurface::PTASProfile::_get_statesDescription_skel, 0},
      {"",0,0},
      {"_get_allStates", &POA_ActiveSurface::PTASProfile::_get_allStates_skel, 0},
      {"_component", &POA_ActiveSurface::PTASProfile::_component_skel, 0},
      {"_get_format", &POA_ActiveSurface::PTASProfile::_get_format_skel, 0},
      {"_get_min_timer_trigger", &POA_ActiveSurface::PTASProfile::_get_min_timer_trigger_skel, 0},
      {"_non_existent", &POA_ActiveSurface::PTASProfile::_non_existent_skel, 0},
      {"_get_characteristic_component_name", &POA_ActiveSurface::PTASProfile::_get_characteristic_component_name_skel, 0},
      {"",0,0},
      {"_get_default_timer_trigger", &POA_ActiveSurface::PTASProfile::_get_default_timer_trigger_skel, 0},
      {"",0,0},
      {"get_all_characteristics", &POA_ActiveSurface::PTASProfile::get_all_characteristics_skel, 0},
      {"create_monitor", &POA_ActiveSurface::PTASProfile::create_monitor_skel, 0},
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"find_characteristic", &POA_ActiveSurface::PTASProfile::find_characteristic_skel, 0},
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"create_postponed_monitor", &POA_ActiveSurface::PTASProfile::create_postponed_monitor_skel, 0},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname;

          if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}

static TAO_ActiveSurface_PTASProfile_Perfect_Hash_OpTable tao_ActiveSurface_PTASProfile_optable;

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ss.cpp:984

TAO::Collocation_Proxy_Broker *
ActiveSurface__TAO_PTASProfile_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
ActiveSurface__TAO_PTASProfile_Proxy_Broker_Factory_Initializer (size_t)
{
  ActiveSurface__TAO_PTASProfile_Proxy_Broker_Factory_function_pointer = 
    ActiveSurface__TAO_PTASProfile_Proxy_Broker_Factory_function;
  
  return 0;
}

static int
ActiveSurface__TAO_PTASProfile_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  ActiveSurface__TAO_PTASProfile_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (ActiveSurface__TAO_PTASProfile_Proxy_Broker_Factory_Initializer)
    );

// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_ss.cpp:103

POA_ActiveSurface::PTASProfile::PTASProfile (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_ActiveSurface_PTASProfile_optable;
}

POA_ActiveSurface::PTASProfile::PTASProfile (const PTASProfile& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_ACS::CharacteristicModel (rhs),
    POA_ACS::OffShoot (rhs),
    POA_ACS::Property (rhs),
    POA_ACS::TypelessProperty (rhs)
{
}

POA_ActiveSurface::PTASProfile::~PTASProfile (void)
{
}
namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class get_sync_PTASProfile
    : public TAO::Upcall_Command
  {
  public:
    inline get_sync_PTASProfile (
      POA_ActiveSurface::PTASProfile * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ActiveSurface::TASProfile>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ActiveSurface::TASProfile> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::ACSErr::Completion>::out_arg_type arg_1 =
        TAO::Portable_Server::get_out_arg< ::ACSErr::Completion> (
          this->operation_details_,
          this->args_,
          1);
        
      retval =
        this->servant_->get_sync (
          arg_1);
    }
  
  private:
    POA_ActiveSurface::PTASProfile * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from 
// be/be_visitor_operation/operation_ss.cpp:190

void POA_ActiveSurface::PTASProfile::get_sync_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ActiveSurface::TASProfile>::ret_val retval;
  TAO::SArg_Traits< ::ACSErr::Completion>::out_arg_val _tao_c;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_c
    };
  
  static size_t const nargs = 2;
  
  POA_ActiveSurface::PTASProfile * const impl =
    static_cast<POA_ActiveSurface::PTASProfile *> (servant);

  get_sync_PTASProfile command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class get_async_PTASProfile
    : public TAO::Upcall_Command
  {
  public:
    inline get_async_PTASProfile (
      POA_ActiveSurface::PTASProfile * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACS::CBpattern>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::ACS::CBpattern> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::ACS::CBDescIn>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::ACS::CBDescIn> (
          this->operation_details_,
          this->args_,
          2);
        
      this->servant_->get_async (
        arg_1
        , arg_2);
    }
  
  private:
    POA_ActiveSurface::PTASProfile * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from 
// be/be_visitor_operation/operation_ss.cpp:190

void POA_ActiveSurface::PTASProfile::get_async_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::ACS::CBpattern>::in_arg_val _tao_cb;
  TAO::SArg_Traits< ::ACS::CBDescIn>::in_arg_val _tao_desc;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_cb,
      &_tao_desc
    };
  
  static size_t const nargs = 3;
  
  POA_ActiveSurface::PTASProfile * const impl =
    static_cast<POA_ActiveSurface::PTASProfile *> (servant);

  get_async_PTASProfile command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class get_history_PTASProfile
    : public TAO::Upcall_Command
  {
  public:
    inline get_history_PTASProfile (
      POA_ActiveSurface::PTASProfile * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Long>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Long> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::ActiveSurface::TASProfileSeq>::out_arg_type arg_2 =
        TAO::Portable_Server::get_out_arg< ::ActiveSurface::TASProfileSeq> (
          this->operation_details_,
          this->args_,
          2);
        
      TAO::SArg_Traits< ::ACS::TimeSeq>::out_arg_type arg_3 =
        TAO::Portable_Server::get_out_arg< ::ACS::TimeSeq> (
          this->operation_details_,
          this->args_,
          3);
        
      retval =
        this->servant_->get_history (
          arg_1
          , arg_2
          , arg_3);
    }
  
  private:
    POA_ActiveSurface::PTASProfile * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from 
// be/be_visitor_operation/operation_ss.cpp:190

void POA_ActiveSurface::PTASProfile::get_history_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::Long>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_n_last_values;
  TAO::SArg_Traits< ::ActiveSurface::TASProfileSeq>::out_arg_val _tao_vs;
  TAO::SArg_Traits< ::ACS::TimeSeq>::out_arg_val _tao_ts;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_n_last_values,
      &_tao_vs,
      &_tao_ts
    };
  
  static size_t const nargs = 4;
  
  POA_ActiveSurface::PTASProfile * const impl =
    static_cast<POA_ActiveSurface::PTASProfile *> (servant);

  get_history_PTASProfile command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class create_monitor_PTASProfile
    : public TAO::Upcall_Command
  {
  public:
    inline create_monitor_PTASProfile (
      POA_ActiveSurface::PTASProfile * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACS::Monitorpattern>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACS::Monitorpattern> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::ACS::CBpattern>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::ACS::CBpattern> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::ACS::CBDescIn>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::ACS::CBDescIn> (
          this->operation_details_,
          this->args_,
          2);
        
      retval =
        this->servant_->create_monitor (
          arg_1
          , arg_2);
    }
  
  private:
    POA_ActiveSurface::PTASProfile * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from 
// be/be_visitor_operation/operation_ss.cpp:190

void POA_ActiveSurface::PTASProfile::create_monitor_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACS::Monitorpattern>::ret_val retval;
  TAO::SArg_Traits< ::ACS::CBpattern>::in_arg_val _tao_cb;
  TAO::SArg_Traits< ::ACS::CBDescIn>::in_arg_val _tao_desc;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_cb,
      &_tao_desc
    };
  
  static size_t const nargs = 3;
  
  POA_ActiveSurface::PTASProfile * const impl =
    static_cast<POA_ActiveSurface::PTASProfile *> (servant);

  create_monitor_PTASProfile command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class create_postponed_monitor_PTASProfile
    : public TAO::Upcall_Command
  {
  public:
    inline create_postponed_monitor_PTASProfile (
      POA_ActiveSurface::PTASProfile * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACS::Monitor>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACS::Monitor> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::ACS::Time>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::ACS::Time> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::ACS::CBpattern>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::ACS::CBpattern> (
          this->operation_details_,
          this->args_,
          2);
        
      TAO::SArg_Traits< ::ACS::CBDescIn>::in_arg_type arg_3 =
        TAO::Portable_Server::get_in_arg< ::ACS::CBDescIn> (
          this->operation_details_,
          this->args_,
          3);
        
      retval =
        this->servant_->create_postponed_monitor (
          arg_1
          , arg_2
          , arg_3);
    }
  
  private:
    POA_ActiveSurface::PTASProfile * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from 
// be/be_visitor_operation/operation_ss.cpp:190

void POA_ActiveSurface::PTASProfile::create_postponed_monitor_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACS::Monitor>::ret_val retval;
  TAO::SArg_Traits< ::ACS::Time>::in_arg_val _tao_start_time;
  TAO::SArg_Traits< ::ACS::CBpattern>::in_arg_val _tao_cb;
  TAO::SArg_Traits< ::ACS::CBDescIn>::in_arg_val _tao_desc;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_start_time,
      &_tao_cb,
      &_tao_desc
    };
  
  static size_t const nargs = 4;
  
  POA_ActiveSurface::PTASProfile * const impl =
    static_cast<POA_ActiveSurface::PTASProfile *> (servant);

  create_postponed_monitor_PTASProfile command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class _get_default_timer_trigger_PTASProfile
    : public TAO::Upcall_Command
  {
  public:
    inline _get_default_timer_trigger_PTASProfile (
      POA_ActiveSurface::PTASProfile * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACS::TimeInterval>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACS::TimeInterval> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_->default_timer_trigger ();
    }
  
  private:
    POA_ActiveSurface::PTASProfile * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from 
// be/be_visitor_operation/operation_ss.cpp:190

void POA_ActiveSurface::PTASProfile::_get_default_timer_trigger_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACS::TimeInterval>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_ActiveSurface::PTASProfile * const impl =
    static_cast<POA_ActiveSurface::PTASProfile *> (servant);

  _get_default_timer_trigger_PTASProfile command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class _get_min_timer_trigger_PTASProfile
    : public TAO::Upcall_Command
  {
  public:
    inline _get_min_timer_trigger_PTASProfile (
      POA_ActiveSurface::PTASProfile * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACS::TimeInterval>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACS::TimeInterval> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_->min_timer_trigger ();
    }
  
  private:
    POA_ActiveSurface::PTASProfile * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from 
// be/be_visitor_operation/operation_ss.cpp:190

void POA_ActiveSurface::PTASProfile::_get_min_timer_trigger_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACS::TimeInterval>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_ActiveSurface::PTASProfile * const impl =
    static_cast<POA_ActiveSurface::PTASProfile *> (servant);

  _get_min_timer_trigger_PTASProfile command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class _get_default_value_PTASProfile
    : public TAO::Upcall_Command
  {
  public:
    inline _get_default_value_PTASProfile (
      POA_ActiveSurface::PTASProfile * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ActiveSurface::TASProfile>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ActiveSurface::TASProfile> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_->default_value ();
    }
  
  private:
    POA_ActiveSurface::PTASProfile * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from 
// be/be_visitor_operation/operation_ss.cpp:190

void POA_ActiveSurface::PTASProfile::_get_default_value_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ActiveSurface::TASProfile>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_ActiveSurface::PTASProfile * const impl =
    static_cast<POA_ActiveSurface::PTASProfile *> (servant);

  _get_default_value_PTASProfile command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class _get_statesDescription_PTASProfile
    : public TAO::Upcall_Command
  {
  public:
    inline _get_statesDescription_PTASProfile (
      POA_ActiveSurface::PTASProfile * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACS::stringSeq>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACS::stringSeq> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_->statesDescription ();
    }
  
  private:
    POA_ActiveSurface::PTASProfile * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from 
// be/be_visitor_operation/operation_ss.cpp:190

void POA_ActiveSurface::PTASProfile::_get_statesDescription_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACS::stringSeq>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_ActiveSurface::PTASProfile * const impl =
    static_cast<POA_ActiveSurface::PTASProfile *> (servant);

  _get_statesDescription_PTASProfile command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class _get_condition_PTASProfile
    : public TAO::Upcall_Command
  {
  public:
    inline _get_condition_PTASProfile (
      POA_ActiveSurface::PTASProfile * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACS::ConditionSeq>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACS::ConditionSeq> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_->condition ();
    }
  
  private:
    POA_ActiveSurface::PTASProfile * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from 
// be/be_visitor_operation/operation_ss.cpp:190

void POA_ActiveSurface::PTASProfile::_get_condition_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACS::ConditionSeq>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_ActiveSurface::PTASProfile * const impl =
    static_cast<POA_ActiveSurface::PTASProfile *> (servant);

  _get_condition_PTASProfile command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class _get_allStates_PTASProfile
    : public TAO::Upcall_Command
  {
  public:
    inline _get_allStates_PTASProfile (
      POA_ActiveSurface::PTASProfile * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ActiveSurface::TASProfileSeq>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ActiveSurface::TASProfileSeq> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_->allStates ();
    }
  
  private:
    POA_ActiveSurface::PTASProfile * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from 
// be/be_visitor_operation/operation_ss.cpp:190

void POA_ActiveSurface::PTASProfile::_get_allStates_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ActiveSurface::TASProfileSeq>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_ActiveSurface::PTASProfile * const impl =
    static_cast<POA_ActiveSurface::PTASProfile *> (servant);

  _get_allStates_PTASProfile command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}



// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_ss.cpp:169

namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class _is_a_PTASProfile_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _is_a_PTASProfile_Upcall_Command (
      POA_ActiveSurface::PTASProfile * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::CORBA::Char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Char *> (
          this->operation_details_,
          this->args_,
          1);
        
      retval =
        this->servant_-> _is_a (
          arg_1);
    }
  
  private:
    POA_ActiveSurface::PTASProfile * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_ActiveSurface::PTASProfile::_is_a_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Char *>::in_arg_val _tao_repository_id;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };
  
  static size_t const nargs = 2;
  
  POA_ActiveSurface::PTASProfile * const impl =
    static_cast<POA_ActiveSurface::PTASProfile *> (servant);
  
  _is_a_PTASProfile_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class _non_existent_PTASProfile_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _non_existent_PTASProfile_Upcall_Command (
      POA_ActiveSurface::PTASProfile * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _non_existent ();
    }
  
  private:
    POA_ActiveSurface::PTASProfile * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_ActiveSurface::PTASProfile::_non_existent_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_ActiveSurface::PTASProfile * const impl =
    static_cast<POA_ActiveSurface::PTASProfile *> (servant);
  
  _non_existent_PTASProfile_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}
namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class _repository_id_PTASProfile_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _repository_id_PTASProfile_Upcall_Command (
      POA_ActiveSurface::PTASProfile * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Char *>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Char *> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _repository_id ();
    }
  
  private:
    POA_ActiveSurface::PTASProfile * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_ActiveSurface::PTASProfile::_repository_id_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::Char *>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_ActiveSurface::PTASProfile * const impl =
    static_cast<POA_ActiveSurface::PTASProfile *> (servant);
  
  _repository_id_PTASProfile_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_ss.cpp:508

void POA_ActiveSurface::PTASProfile::_interface_skel (
    TAO_ServerRequest & server_request, 
    void * /* servant_upcall */,
    void * servant)
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (_tao_adapter == 0)
    {
      throw ::CORBA::INTF_REPOS (::CORBA::OMGVMCID | 1, ::CORBA::COMPLETED_NO);
    }
  
  POA_ActiveSurface::PTASProfile * const impl =
    static_cast<POA_ActiveSurface::PTASProfile *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval = impl->_get_interface ();
  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();
  
  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (_tao_out, _tao_retval);
  
  _tao_adapter->dispose (_tao_retval);
  
  if (_tao_result == false)
    {
      throw ::CORBA::MARSHAL ();
    }
}

namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class _get_component_PTASProfile_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _get_component_PTASProfile_Upcall_Command (
      POA_ActiveSurface::PTASProfile * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _get_component ();
    }
  
  private:
    POA_ActiveSurface::PTASProfile * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_ActiveSurface::PTASProfile::_component_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_ActiveSurface::PTASProfile * const impl =
    static_cast<POA_ActiveSurface::PTASProfile *> (servant);
  
  _get_component_PTASProfile_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

::CORBA::Boolean POA_ActiveSurface::PTASProfile::_is_a (const char* value)
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:alma/ACS/CharacteristicModel:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:alma/ACS/OffShoot:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:alma/ACS/Property:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:alma/ACS/TypelessProperty:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:alma/ActiveSurface/PTASProfile:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_ActiveSurface::PTASProfile::_interface_repository_id (void) const
{
  return "IDL:alma/ActiveSurface/PTASProfile:1.0";
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ss.cpp:926

void POA_ActiveSurface::PTASProfile::_dispatch (TAO_ServerRequest & req, void * servant_upcall)
{
  this->synchronous_upcall_dispatch (req, servant_upcall, this);
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ss.cpp:852

ActiveSurface::PTASProfile *
POA_ActiveSurface::PTASProfile::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();
  
  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object_ptr ();
  
  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );
  
  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();
  
  typedef ::ActiveSurface::PTASProfile STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        ActiveSurface__TAO_PTASProfile_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// be/be_interface.cpp:1555

class TAO_ActiveSurface_ROTASProfile_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: /alma/ACS-8.2/TAO/ACE_wrappers/build/linux/bin/gperf -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_ActiveSurface_ROTASProfile_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_ActiveSurface_ROTASProfile_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
     60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
     60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
     60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
     60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
     60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
     60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
     60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
     60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
     60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
     60, 60, 60, 60, 60, 60, 60, 60, 60,  0,
     60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
     60, 60, 60, 60, 60, 60, 60, 60, 60,  0,
     60, 30, 15,  0,  5,  0, 60, 60, 60, 60,
     60, 60, 60, 60, 60, 60, 60, 60, 10,  0,
     60, 60, 60,  5, 60, 60, 60, 60, 60, 60,
     60, 60, 10, 30, 60, 60, 60, 60,  0, 60,
     60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
     60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
     60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
     60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
     60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
     60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
     60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
     60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
     60, 60, 60, 60, 60, 60,
#else
     60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
     60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
     60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
     60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
     60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
     60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
     60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
     60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
     60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
     60, 60, 60, 60, 60,  0, 60,  0, 60, 30,
     15,  0,  5,  0, 60, 60, 60, 60, 60, 10,
      0, 60, 60, 60,  5, 10, 30, 60, 60, 60,
     60,  0, 60, 60, 60, 60, 60, 60,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_ActiveSurface_ROTASProfile_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 28,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 34,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 59,
      HASH_VALUE_RANGE = 55,
      DUPLICATES = 0,
      WORDLIST_SIZE = 33
    };

  static const TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"_is_a", &POA_ActiveSurface::ROTASProfile::_is_a_skel, 0},
      {"",0,0},{"",0,0},{"",0,0},
      {"_get_name", &POA_ActiveSurface::ROTASProfile::_get_name_skel, 0},
      {"_interface", &POA_ActiveSurface::ROTASProfile::_interface_skel, 0},
      {"get_history", &POA_ActiveSurface::ROTASProfile::get_history_skel, 0},
      {"",0,0},
      {"_get_alarm_on", &POA_ActiveSurface::ROTASProfile::_get_alarm_on_skel, 0},
      {"_get_condition", &POA_ActiveSurface::ROTASProfile::_get_condition_skel, 0},
      {"_get_resolution", &POA_ActiveSurface::ROTASProfile::_get_resolution_skel, 0},
      {"_get_description", &POA_ActiveSurface::ROTASProfile::_get_description_skel, 0},
      {"",0,0},
      {"_get_default_value", &POA_ActiveSurface::ROTASProfile::_get_default_value_skel, 0},
      {"_get_alarm_off", &POA_ActiveSurface::ROTASProfile::_get_alarm_off_skel, 0},
      {"_get_units", &POA_ActiveSurface::ROTASProfile::_get_units_skel, 0},
      {"",0,0},
      {"_get_statesDescription", &POA_ActiveSurface::ROTASProfile::_get_statesDescription_skel, 0},
      {"",0,0},
      {"_get_allStates", &POA_ActiveSurface::ROTASProfile::_get_allStates_skel, 0},
      {"",0,0},
      {"get_characteristic_by_name", &POA_ActiveSurface::ROTASProfile::get_characteristic_by_name_skel, 0},
      {"_get_min_timer_trigger", &POA_ActiveSurface::ROTASProfile::_get_min_timer_trigger_skel, 0},
      {"",0,0},
      {"_repository_id", &POA_ActiveSurface::ROTASProfile::_repository_id_skel, 0},
      {"",0,0},
      {"_get_default_timer_trigger", &POA_ActiveSurface::ROTASProfile::_get_default_timer_trigger_skel, 0},
      {"",0,0},
      {"get_all_characteristics", &POA_ActiveSurface::ROTASProfile::get_all_characteristics_skel, 0},
      {"_get_characteristic_component_name", &POA_ActiveSurface::ROTASProfile::_get_characteristic_component_name_skel, 0},
      {"",0,0},
      {"new_subscription_AlarmEnum", &POA_ActiveSurface::ROTASProfile::new_subscription_AlarmEnum_skel, 0},
      {"",0,0},
      {"get_sync", &POA_ActiveSurface::ROTASProfile::get_sync_skel, 0},
      {"get_async", &POA_ActiveSurface::ROTASProfile::get_async_skel, 0},
      {"_component", &POA_ActiveSurface::ROTASProfile::_component_skel, 0},
      {"_get_format", &POA_ActiveSurface::ROTASProfile::_get_format_skel, 0},
      {"",0,0},
      {"_non_existent", &POA_ActiveSurface::ROTASProfile::_non_existent_skel, 0},
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"create_monitor", &POA_ActiveSurface::ROTASProfile::create_monitor_skel, 0},
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"find_characteristic", &POA_ActiveSurface::ROTASProfile::find_characteristic_skel, 0},
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"create_postponed_monitor", &POA_ActiveSurface::ROTASProfile::create_postponed_monitor_skel, 0},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname;

          if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}

static TAO_ActiveSurface_ROTASProfile_Perfect_Hash_OpTable tao_ActiveSurface_ROTASProfile_optable;

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ss.cpp:984

TAO::Collocation_Proxy_Broker *
ActiveSurface__TAO_ROTASProfile_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
ActiveSurface__TAO_ROTASProfile_Proxy_Broker_Factory_Initializer (size_t)
{
  ActiveSurface__TAO_ROTASProfile_Proxy_Broker_Factory_function_pointer = 
    ActiveSurface__TAO_ROTASProfile_Proxy_Broker_Factory_function;
  
  return 0;
}

static int
ActiveSurface__TAO_ROTASProfile_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  ActiveSurface__TAO_ROTASProfile_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (ActiveSurface__TAO_ROTASProfile_Proxy_Broker_Factory_Initializer)
    );

// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_ss.cpp:103

POA_ActiveSurface::ROTASProfile::ROTASProfile (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_ActiveSurface_ROTASProfile_optable;
}

POA_ActiveSurface::ROTASProfile::ROTASProfile (const ROTASProfile& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_ACS::CharacteristicModel (rhs),
    POA_ACS::OffShoot (rhs),
    POA_ACS::Property (rhs),
    POA_ACS::TypelessProperty (rhs),
    POA_ActiveSurface::PTASProfile (rhs)
{
}

POA_ActiveSurface::ROTASProfile::~ROTASProfile (void)
{
}
namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class new_subscription_AlarmEnum_ROTASProfile
    : public TAO::Upcall_Command
  {
  public:
    inline new_subscription_AlarmEnum_ROTASProfile (
      POA_ActiveSurface::ROTASProfile * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACS::Subscription>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACS::Subscription> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::ACS::Alarmpattern>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::ACS::Alarmpattern> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::ACS::CBDescIn>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::ACS::CBDescIn> (
          this->operation_details_,
          this->args_,
          2);
        
      retval =
        this->servant_->new_subscription_AlarmEnum (
          arg_1
          , arg_2);
    }
  
  private:
    POA_ActiveSurface::ROTASProfile * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from 
// be/be_visitor_operation/operation_ss.cpp:190

void POA_ActiveSurface::ROTASProfile::new_subscription_AlarmEnum_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACS::Subscription>::ret_val retval;
  TAO::SArg_Traits< ::ACS::Alarmpattern>::in_arg_val _tao_cb;
  TAO::SArg_Traits< ::ACS::CBDescIn>::in_arg_val _tao_desc;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_cb,
      &_tao_desc
    };
  
  static size_t const nargs = 3;
  
  POA_ActiveSurface::ROTASProfile * const impl =
    static_cast<POA_ActiveSurface::ROTASProfile *> (servant);

  new_subscription_AlarmEnum_ROTASProfile command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class _get_alarm_on_ROTASProfile
    : public TAO::Upcall_Command
  {
  public:
    inline _get_alarm_on_ROTASProfile (
      POA_ActiveSurface::ROTASProfile * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ActiveSurface::TASProfileSeq>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ActiveSurface::TASProfileSeq> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_->alarm_on ();
    }
  
  private:
    POA_ActiveSurface::ROTASProfile * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from 
// be/be_visitor_operation/operation_ss.cpp:190

void POA_ActiveSurface::ROTASProfile::_get_alarm_on_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ActiveSurface::TASProfileSeq>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_ActiveSurface::ROTASProfile * const impl =
    static_cast<POA_ActiveSurface::ROTASProfile *> (servant);

  _get_alarm_on_ROTASProfile command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class _get_alarm_off_ROTASProfile
    : public TAO::Upcall_Command
  {
  public:
    inline _get_alarm_off_ROTASProfile (
      POA_ActiveSurface::ROTASProfile * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ActiveSurface::TASProfileSeq>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ActiveSurface::TASProfileSeq> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_->alarm_off ();
    }
  
  private:
    POA_ActiveSurface::ROTASProfile * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from 
// be/be_visitor_operation/operation_ss.cpp:190

void POA_ActiveSurface::ROTASProfile::_get_alarm_off_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ActiveSurface::TASProfileSeq>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_ActiveSurface::ROTASProfile * const impl =
    static_cast<POA_ActiveSurface::ROTASProfile *> (servant);

  _get_alarm_off_ROTASProfile command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}



// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_ss.cpp:169

namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class _is_a_ROTASProfile_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _is_a_ROTASProfile_Upcall_Command (
      POA_ActiveSurface::ROTASProfile * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::CORBA::Char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Char *> (
          this->operation_details_,
          this->args_,
          1);
        
      retval =
        this->servant_-> _is_a (
          arg_1);
    }
  
  private:
    POA_ActiveSurface::ROTASProfile * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_ActiveSurface::ROTASProfile::_is_a_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Char *>::in_arg_val _tao_repository_id;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };
  
  static size_t const nargs = 2;
  
  POA_ActiveSurface::ROTASProfile * const impl =
    static_cast<POA_ActiveSurface::ROTASProfile *> (servant);
  
  _is_a_ROTASProfile_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class _non_existent_ROTASProfile_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _non_existent_ROTASProfile_Upcall_Command (
      POA_ActiveSurface::ROTASProfile * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _non_existent ();
    }
  
  private:
    POA_ActiveSurface::ROTASProfile * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_ActiveSurface::ROTASProfile::_non_existent_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_ActiveSurface::ROTASProfile * const impl =
    static_cast<POA_ActiveSurface::ROTASProfile *> (servant);
  
  _non_existent_ROTASProfile_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}
namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class _repository_id_ROTASProfile_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _repository_id_ROTASProfile_Upcall_Command (
      POA_ActiveSurface::ROTASProfile * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Char *>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Char *> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _repository_id ();
    }
  
  private:
    POA_ActiveSurface::ROTASProfile * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_ActiveSurface::ROTASProfile::_repository_id_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::Char *>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_ActiveSurface::ROTASProfile * const impl =
    static_cast<POA_ActiveSurface::ROTASProfile *> (servant);
  
  _repository_id_ROTASProfile_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_ss.cpp:508

void POA_ActiveSurface::ROTASProfile::_interface_skel (
    TAO_ServerRequest & server_request, 
    void * /* servant_upcall */,
    void * servant)
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (_tao_adapter == 0)
    {
      throw ::CORBA::INTF_REPOS (::CORBA::OMGVMCID | 1, ::CORBA::COMPLETED_NO);
    }
  
  POA_ActiveSurface::ROTASProfile * const impl =
    static_cast<POA_ActiveSurface::ROTASProfile *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval = impl->_get_interface ();
  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();
  
  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (_tao_out, _tao_retval);
  
  _tao_adapter->dispose (_tao_retval);
  
  if (_tao_result == false)
    {
      throw ::CORBA::MARSHAL ();
    }
}

namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class _get_component_ROTASProfile_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _get_component_ROTASProfile_Upcall_Command (
      POA_ActiveSurface::ROTASProfile * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _get_component ();
    }
  
  private:
    POA_ActiveSurface::ROTASProfile * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_ActiveSurface::ROTASProfile::_component_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_ActiveSurface::ROTASProfile * const impl =
    static_cast<POA_ActiveSurface::ROTASProfile *> (servant);
  
  _get_component_ROTASProfile_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

::CORBA::Boolean POA_ActiveSurface::ROTASProfile::_is_a (const char* value)
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:alma/ACS/CharacteristicModel:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:alma/ACS/OffShoot:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:alma/ACS/Property:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:alma/ACS/TypelessProperty:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:alma/ActiveSurface/PTASProfile:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:alma/ActiveSurface/ROTASProfile:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_ActiveSurface::ROTASProfile::_interface_repository_id (void) const
{
  return "IDL:alma/ActiveSurface/ROTASProfile:1.0";
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ss.cpp:926

void POA_ActiveSurface::ROTASProfile::_dispatch (TAO_ServerRequest & req, void * servant_upcall)
{
  this->synchronous_upcall_dispatch (req, servant_upcall, this);
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ss.cpp:852

ActiveSurface::ROTASProfile *
POA_ActiveSurface::ROTASProfile::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();
  
  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object_ptr ();
  
  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );
  
  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();
  
  typedef ::ActiveSurface::ROTASProfile STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        ActiveSurface__TAO_ROTASProfile_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// be/be_interface.cpp:1555

class TAO_ActiveSurface_RWTASProfile_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: /alma/ACS-8.2/TAO/ACE_wrappers/build/linux/bin/gperf -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_ActiveSurface_RWTASProfile_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_ActiveSurface_RWTASProfile_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     62, 62, 62, 62, 62, 62, 62, 62, 62, 62,
     62, 62, 62, 62, 62, 62, 62, 62, 62, 62,
     62, 62, 62, 62, 62, 62, 62, 62, 62, 62,
     62, 62, 62, 62, 62, 62, 62, 62, 62, 62,
     62, 62, 62, 62, 62, 62, 62, 62, 62, 62,
     62, 62, 62, 62, 62, 62, 62, 62, 62, 62,
     62, 62, 62, 62, 62, 62, 62, 62, 62, 62,
     62, 62, 62, 62, 62, 62, 62, 62, 62, 62,
     62, 62, 62, 62, 62, 62, 62, 62, 62, 62,
     62, 62, 62, 62, 62, 62, 62, 62, 62, 62,
     62, 62, 62, 62, 62, 62, 62, 62, 62,  0,
     62, 62, 62, 62, 62, 62, 62, 62, 62, 62,
     62, 62, 62, 62, 62, 62, 62, 62, 62,  0,
     62,  0, 10, 10,  3, 25, 62, 62, 62, 62,
     62, 62, 62, 62, 62, 62, 62, 62, 62, 15,
     62, 62, 62, 25, 62, 62, 62, 62, 62, 62,
     62, 62,  0,  5, 62, 62, 62, 62,  0, 62,
     62, 62, 62, 62, 62, 62, 62, 62, 62, 62,
     62, 62, 62, 62, 62, 62, 62, 62, 62, 62,
     62, 62, 62, 62, 62, 62, 62, 62, 62, 62,
     62, 62, 62, 62, 62, 62, 62, 62, 62, 62,
     62, 62, 62, 62, 62, 62, 62, 62, 62, 62,
     62, 62, 62, 62, 62, 62, 62, 62, 62, 62,
     62, 62, 62, 62, 62, 62, 62, 62, 62, 62,
     62, 62, 62, 62, 62, 62, 62, 62, 62, 62,
     62, 62, 62, 62, 62, 62,
#else
     62, 62, 62, 62, 62, 62, 62, 62, 62, 62,
     62, 62, 62, 62, 62, 62, 62, 62, 62, 62,
     62, 62, 62, 62, 62, 62, 62, 62, 62, 62,
     62, 62, 62, 62, 62, 62, 62, 62, 62, 62,
     62, 62, 62, 62, 62, 62, 62, 62, 62, 62,
     62, 62, 62, 62, 62, 62, 62, 62, 62, 62,
     62, 62, 62, 62, 62, 62, 62, 62, 62, 62,
     62, 62, 62, 62, 62, 62, 62, 62, 62, 62,
     62, 62, 62, 62, 62, 62, 62, 62, 62, 62,
     62, 62, 62, 62, 62,  0, 62,  0, 62,  0,
     10, 10,  3, 25, 62, 62, 62, 62, 62, 62,
     15, 62, 62, 62, 25,  0,  5, 62, 62, 62,
     62,  0, 62, 62, 62, 62, 62, 62,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_ActiveSurface_RWTASProfile_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 28,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 34,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 61,
      HASH_VALUE_RANGE = 57,
      DUPLICATES = 0,
      WORDLIST_SIZE = 33
    };

  static const TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"_is_a", &POA_ActiveSurface::RWTASProfile::_is_a_skel, 0},
      {"",0,0},{"",0,0},
      {"set_sync", &POA_ActiveSurface::RWTASProfile::set_sync_skel, 0},
      {"set_async", &POA_ActiveSurface::RWTASProfile::set_async_skel, 0},
      {"_get_units", &POA_ActiveSurface::RWTASProfile::_get_units_skel, 0},
      {"",0,0},{"",0,0},{"",0,0},
      {"_get_allStates", &POA_ActiveSurface::RWTASProfile::_get_allStates_skel, 0},
      {"_component", &POA_ActiveSurface::RWTASProfile::_component_skel, 0},
      {"_get_format", &POA_ActiveSurface::RWTASProfile::_get_format_skel, 0},
      {"",0,0},
      {"_non_existent", &POA_ActiveSurface::RWTASProfile::_non_existent_skel, 0},
      {"_get_name", &POA_ActiveSurface::RWTASProfile::_get_name_skel, 0},
      {"_interface", &POA_ActiveSurface::RWTASProfile::_interface_skel, 0},
      {"",0,0},
      {"find_characteristic", &POA_ActiveSurface::RWTASProfile::find_characteristic_skel, 0},
      {"",0,0},
      {"_repository_id", &POA_ActiveSurface::RWTASProfile::_repository_id_skel, 0},
      {"",0,0},{"",0,0},{"",0,0},
      {"_get_default_value", &POA_ActiveSurface::RWTASProfile::_get_default_value_skel, 0},
      {"_get_condition", &POA_ActiveSurface::RWTASProfile::_get_condition_skel, 0},
      {"_get_resolution", &POA_ActiveSurface::RWTASProfile::_get_resolution_skel, 0},
      {"_get_description", &POA_ActiveSurface::RWTASProfile::_get_description_skel, 0},
      {"",0,0},
      {"get_sync", &POA_ActiveSurface::RWTASProfile::get_sync_skel, 0},
      {"get_async", &POA_ActiveSurface::RWTASProfile::get_async_skel, 0},
      {"",0,0},
      {"get_history", &POA_ActiveSurface::RWTASProfile::get_history_skel, 0},
      {"_get_statesDescription", &POA_ActiveSurface::RWTASProfile::_get_statesDescription_skel, 0},
      {"",0,0},
      {"create_monitor", &POA_ActiveSurface::RWTASProfile::create_monitor_skel, 0},
      {"set_nonblocking", &POA_ActiveSurface::RWTASProfile::set_nonblocking_skel, 0},
      {"",0,0},{"",0,0},{"",0,0},
      {"_get_characteristic_component_name", &POA_ActiveSurface::RWTASProfile::_get_characteristic_component_name_skel, 0},
      {"",0,0},{"",0,0},
      {"_get_min_timer_trigger", &POA_ActiveSurface::RWTASProfile::_get_min_timer_trigger_skel, 0},
      {"get_all_characteristics", &POA_ActiveSurface::RWTASProfile::get_all_characteristics_skel, 0},
      {"create_postponed_monitor", &POA_ActiveSurface::RWTASProfile::create_postponed_monitor_skel, 0},
      {"",0,0},
      {"_get_default_timer_trigger", &POA_ActiveSurface::RWTASProfile::_get_default_timer_trigger_skel, 0},
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"get_characteristic_by_name", &POA_ActiveSurface::RWTASProfile::get_characteristic_by_name_skel, 0},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname;

          if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}

static TAO_ActiveSurface_RWTASProfile_Perfect_Hash_OpTable tao_ActiveSurface_RWTASProfile_optable;

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ss.cpp:984

TAO::Collocation_Proxy_Broker *
ActiveSurface__TAO_RWTASProfile_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
ActiveSurface__TAO_RWTASProfile_Proxy_Broker_Factory_Initializer (size_t)
{
  ActiveSurface__TAO_RWTASProfile_Proxy_Broker_Factory_function_pointer = 
    ActiveSurface__TAO_RWTASProfile_Proxy_Broker_Factory_function;
  
  return 0;
}

static int
ActiveSurface__TAO_RWTASProfile_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  ActiveSurface__TAO_RWTASProfile_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (ActiveSurface__TAO_RWTASProfile_Proxy_Broker_Factory_Initializer)
    );

// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_ss.cpp:103

POA_ActiveSurface::RWTASProfile::RWTASProfile (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_ActiveSurface_RWTASProfile_optable;
}

POA_ActiveSurface::RWTASProfile::RWTASProfile (const RWTASProfile& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_ACS::CharacteristicModel (rhs),
    POA_ACS::OffShoot (rhs),
    POA_ACS::Property (rhs),
    POA_ACS::TypelessProperty (rhs),
    POA_ActiveSurface::PTASProfile (rhs)
{
}

POA_ActiveSurface::RWTASProfile::~RWTASProfile (void)
{
}
namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class set_sync_RWTASProfile
    : public TAO::Upcall_Command
  {
  public:
    inline set_sync_RWTASProfile (
      POA_ActiveSurface::RWTASProfile * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACSErr::Completion>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACSErr::Completion> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::ActiveSurface::TASProfile>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::ActiveSurface::TASProfile> (
          this->operation_details_,
          this->args_,
          1);
        
      retval =
        this->servant_->set_sync (
          arg_1);
    }
  
  private:
    POA_ActiveSurface::RWTASProfile * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from 
// be/be_visitor_operation/operation_ss.cpp:190

void POA_ActiveSurface::RWTASProfile::set_sync_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACSErr::Completion>::ret_val retval;
  TAO::SArg_Traits< ::ActiveSurface::TASProfile>::in_arg_val _tao_value;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_value
    };
  
  static size_t const nargs = 2;
  
  POA_ActiveSurface::RWTASProfile * const impl =
    static_cast<POA_ActiveSurface::RWTASProfile *> (servant);

  set_sync_RWTASProfile command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class set_async_RWTASProfile
    : public TAO::Upcall_Command
  {
  public:
    inline set_async_RWTASProfile (
      POA_ActiveSurface::RWTASProfile * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ActiveSurface::TASProfile>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::ActiveSurface::TASProfile> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::ACS::CBvoid>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::ACS::CBvoid> (
          this->operation_details_,
          this->args_,
          2);
        
      TAO::SArg_Traits< ::ACS::CBDescIn>::in_arg_type arg_3 =
        TAO::Portable_Server::get_in_arg< ::ACS::CBDescIn> (
          this->operation_details_,
          this->args_,
          3);
        
      this->servant_->set_async (
        arg_1
        , arg_2
        , arg_3);
    }
  
  private:
    POA_ActiveSurface::RWTASProfile * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from 
// be/be_visitor_operation/operation_ss.cpp:190

void POA_ActiveSurface::RWTASProfile::set_async_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::ActiveSurface::TASProfile>::in_arg_val _tao_value;
  TAO::SArg_Traits< ::ACS::CBvoid>::in_arg_val _tao_cb;
  TAO::SArg_Traits< ::ACS::CBDescIn>::in_arg_val _tao_desc;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_value,
      &_tao_cb,
      &_tao_desc
    };
  
  static size_t const nargs = 4;
  
  POA_ActiveSurface::RWTASProfile * const impl =
    static_cast<POA_ActiveSurface::RWTASProfile *> (servant);

  set_async_RWTASProfile command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class set_nonblocking_RWTASProfile
    : public TAO::Upcall_Command
  {
  public:
    inline set_nonblocking_RWTASProfile (
      POA_ActiveSurface::RWTASProfile * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ActiveSurface::TASProfile>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::ActiveSurface::TASProfile> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->set_nonblocking (
        arg_1);
    }
  
  private:
    POA_ActiveSurface::RWTASProfile * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from 
// be/be_visitor_operation/operation_ss.cpp:190

void POA_ActiveSurface::RWTASProfile::set_nonblocking_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::ActiveSurface::TASProfile>::in_arg_val _tao_value;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_value
    };
  
  static size_t const nargs = 2;
  
  POA_ActiveSurface::RWTASProfile * const impl =
    static_cast<POA_ActiveSurface::RWTASProfile *> (servant);

  set_nonblocking_RWTASProfile command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}



// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_ss.cpp:169

namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class _is_a_RWTASProfile_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _is_a_RWTASProfile_Upcall_Command (
      POA_ActiveSurface::RWTASProfile * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::CORBA::Char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Char *> (
          this->operation_details_,
          this->args_,
          1);
        
      retval =
        this->servant_-> _is_a (
          arg_1);
    }
  
  private:
    POA_ActiveSurface::RWTASProfile * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_ActiveSurface::RWTASProfile::_is_a_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Char *>::in_arg_val _tao_repository_id;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };
  
  static size_t const nargs = 2;
  
  POA_ActiveSurface::RWTASProfile * const impl =
    static_cast<POA_ActiveSurface::RWTASProfile *> (servant);
  
  _is_a_RWTASProfile_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class _non_existent_RWTASProfile_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _non_existent_RWTASProfile_Upcall_Command (
      POA_ActiveSurface::RWTASProfile * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _non_existent ();
    }
  
  private:
    POA_ActiveSurface::RWTASProfile * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_ActiveSurface::RWTASProfile::_non_existent_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_ActiveSurface::RWTASProfile * const impl =
    static_cast<POA_ActiveSurface::RWTASProfile *> (servant);
  
  _non_existent_RWTASProfile_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}
namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class _repository_id_RWTASProfile_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _repository_id_RWTASProfile_Upcall_Command (
      POA_ActiveSurface::RWTASProfile * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Char *>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Char *> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _repository_id ();
    }
  
  private:
    POA_ActiveSurface::RWTASProfile * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_ActiveSurface::RWTASProfile::_repository_id_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::Char *>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_ActiveSurface::RWTASProfile * const impl =
    static_cast<POA_ActiveSurface::RWTASProfile *> (servant);
  
  _repository_id_RWTASProfile_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_ss.cpp:508

void POA_ActiveSurface::RWTASProfile::_interface_skel (
    TAO_ServerRequest & server_request, 
    void * /* servant_upcall */,
    void * servant)
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (_tao_adapter == 0)
    {
      throw ::CORBA::INTF_REPOS (::CORBA::OMGVMCID | 1, ::CORBA::COMPLETED_NO);
    }
  
  POA_ActiveSurface::RWTASProfile * const impl =
    static_cast<POA_ActiveSurface::RWTASProfile *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval = impl->_get_interface ();
  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();
  
  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (_tao_out, _tao_retval);
  
  _tao_adapter->dispose (_tao_retval);
  
  if (_tao_result == false)
    {
      throw ::CORBA::MARSHAL ();
    }
}

namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class _get_component_RWTASProfile_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _get_component_RWTASProfile_Upcall_Command (
      POA_ActiveSurface::RWTASProfile * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _get_component ();
    }
  
  private:
    POA_ActiveSurface::RWTASProfile * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_ActiveSurface::RWTASProfile::_component_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_ActiveSurface::RWTASProfile * const impl =
    static_cast<POA_ActiveSurface::RWTASProfile *> (servant);
  
  _get_component_RWTASProfile_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

::CORBA::Boolean POA_ActiveSurface::RWTASProfile::_is_a (const char* value)
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:alma/ACS/CharacteristicModel:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:alma/ACS/OffShoot:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:alma/ACS/Property:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:alma/ACS/TypelessProperty:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:alma/ActiveSurface/PTASProfile:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:alma/ActiveSurface/RWTASProfile:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_ActiveSurface::RWTASProfile::_interface_repository_id (void) const
{
  return "IDL:alma/ActiveSurface/RWTASProfile:1.0";
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ss.cpp:926

void POA_ActiveSurface::RWTASProfile::_dispatch (TAO_ServerRequest & req, void * servant_upcall)
{
  this->synchronous_upcall_dispatch (req, servant_upcall, this);
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ss.cpp:852

ActiveSurface::RWTASProfile *
POA_ActiveSurface::RWTASProfile::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();
  
  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object_ptr ();
  
  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );
  
  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();
  
  typedef ::ActiveSurface::RWTASProfile STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        ActiveSurface__TAO_RWTASProfile_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// be/be_interface.cpp:1555

class TAO_ActiveSurface_NotoActiveSurfaceBoss_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: /alma/ACS-8.2/TAO/ACE_wrappers/build/linux/bin/gperf -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_ActiveSurface_NotoActiveSurfaceBoss_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_ActiveSurface_NotoActiveSurfaceBoss_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     70, 70, 70, 70, 70, 70, 70, 70, 70, 70,
     70, 70, 70, 70, 70, 70, 70, 70, 70, 70,
     70, 70, 70, 70, 70, 70, 70, 70, 70, 70,
     70, 70, 70, 70, 70, 70, 70, 70, 70, 70,
     70, 70, 70, 70, 70, 70, 70, 70, 70, 70,
     70, 70, 70, 70, 70, 70, 70, 70, 70, 70,
     70, 70, 70, 70, 70, 70, 70, 70, 70, 70,
     70, 70, 70, 70, 70, 70, 70, 70, 70, 70,
     70, 70, 70, 70, 70, 70, 70, 70, 70, 70,
     70, 70, 70, 70, 70, 70, 70, 70, 70, 70,
     70, 70, 70, 70, 70, 70, 70, 70, 70,  0,
     70, 70, 70, 70, 70, 70, 70, 70, 70, 70,
     70, 70, 70, 70, 70, 70, 70, 70, 70, 35,
      0, 20, 10,  0, 15,  5, 70, 70, 70, 70,
     70, 70, 70, 70, 70, 70, 10, 70,  0, 30,
     70, 25, 70, 10, 70, 70, 70, 70, 70, 70,
     70, 70,  5, 10, 35, 70, 40, 70, 70, 70,
     70, 70, 70, 70, 70, 70, 70, 70, 70, 70,
     70, 70, 70, 70, 70, 70, 70, 70, 70, 70,
     70, 70, 70, 70, 70, 70, 25, 70, 70, 70,
     70, 70, 70, 70, 70, 70, 70, 70, 70, 70,
     70, 70, 70, 70, 70, 70, 70, 70, 70, 70,
     70, 70, 70, 70, 70, 70, 70, 70, 70, 70,
     70, 70, 70, 70, 70, 70, 70, 70, 70, 70,
     70, 70, 70, 70, 70, 70, 70, 70, 70, 70,
     70, 70, 70, 70, 70, 70,
#else
     70, 70, 70, 70, 70, 70, 70, 70, 70, 70,
     70, 70, 70, 70, 70, 70, 70, 70, 70, 70,
     70, 70, 70, 70, 70, 70, 70, 70, 70, 70,
     70, 70, 70, 70, 70, 70, 70, 70, 70, 70,
     70, 70, 70, 70, 70, 70, 70, 70, 70, 70,
     70, 70, 70, 70, 70, 70, 70, 70, 70, 70,
     70, 70, 70, 70, 70, 70, 70, 70, 25, 70,
     70, 70, 70, 70, 70, 70, 70, 70, 70, 70,
     70, 70, 70, 70, 70, 70, 70, 70, 70, 70,
     70, 70, 70, 70, 70,  0, 70, 35,  0, 20,
     10,  0, 15,  5, 70, 70, 70, 10, 70,  0,
     30, 70, 25, 70, 10,  5, 10, 35, 70, 40,
     70, 70, 70, 70, 70, 70, 70, 70,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_ActiveSurface_NotoActiveSurfaceBoss_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 37,
      MIN_WORD_LENGTH = 2,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 69,
      HASH_VALUE_RANGE = 66,
      DUPLICATES = 0,
      WORDLIST_SIZE = 41
    };

  static const TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"move", &POA_ActiveSurface::NotoActiveSurfaceBoss::move_skel, 0},
      {"",0,0},
      {"bottom", &POA_ActiveSurface::NotoActiveSurfaceBoss::bottom_skel, 0},
      {"",0,0},{"",0,0},
      {"_get_name", &POA_ActiveSurface::NotoActiveSurfaceBoss::_get_name_skel, 0},
      {"_interface", &POA_ActiveSurface::NotoActiveSurfaceBoss::_interface_skel, 0},
      {"",0,0},{"",0,0},
      {"_get_pprofile", &POA_ActiveSurface::NotoActiveSurfaceBoss::_get_pprofile_skel, 0},
      {"",0,0},
      {"setProfile", &POA_ActiveSurface::NotoActiveSurfaceBoss::setProfile_skel, 0},
      {"_get_status", &POA_ActiveSurface::NotoActiveSurfaceBoss::_get_status_skel, 0},
      {"",0,0},
      {"_get_tracking", &POA_ActiveSurface::NotoActiveSurfaceBoss::_get_tracking_skel, 0},
      {"_get_componentState", &POA_ActiveSurface::NotoActiveSurfaceBoss::_get_componentState_skel, 0},
      {"_component", &POA_ActiveSurface::NotoActiveSurfaceBoss::_component_skel, 0},
      {"refPos", &POA_ActiveSurface::NotoActiveSurfaceBoss::refPos_skel, 0},
      {"_get_enabled", &POA_ActiveSurface::NotoActiveSurfaceBoss::_get_enabled_skel, 0},
      {"_non_existent", &POA_ActiveSurface::NotoActiveSurfaceBoss::_non_existent_skel, 0},
      {"_repository_id", &POA_ActiveSurface::NotoActiveSurfaceBoss::_repository_id_skel, 0},
      {"reset", &POA_ActiveSurface::NotoActiveSurfaceBoss::reset_skel, 0},
      {"setActuator", &POA_ActiveSurface::NotoActiveSurfaceBoss::setActuator_skel, 0},
      {"",0,0},{"",0,0},
      {"calibrate", &POA_ActiveSurface::NotoActiveSurfaceBoss::calibrate_skel, 0},
      {"descriptor", &POA_ActiveSurface::NotoActiveSurfaceBoss::descriptor_skel, 0},
      {"get_characteristic_by_name", &POA_ActiveSurface::NotoActiveSurfaceBoss::get_characteristic_by_name_skel, 0},
      {"",0,0},
      {"get_all_characteristics", &POA_ActiveSurface::NotoActiveSurfaceBoss::get_all_characteristics_skel, 0},
      {"stop", &POA_ActiveSurface::NotoActiveSurfaceBoss::stop_skel, 0},
      {"setup", &POA_ActiveSurface::NotoActiveSurfaceBoss::setup_skel, 0},
      {"calVer", &POA_ActiveSurface::NotoActiveSurfaceBoss::calVer_skel, 0},
      {"command", &POA_ActiveSurface::NotoActiveSurfaceBoss::command_skel, 0},
      {"top", &POA_ActiveSurface::NotoActiveSurfaceBoss::top_skel, 0},
      {"park", &POA_ActiveSurface::NotoActiveSurfaceBoss::park_skel, 0},
      {"_is_a", &POA_ActiveSurface::NotoActiveSurfaceBoss::_is_a_skel, 0},
      {"update", &POA_ActiveSurface::NotoActiveSurfaceBoss::update_skel, 0},
      {"",0,0},{"",0,0},
      {"down", &POA_ActiveSurface::NotoActiveSurfaceBoss::down_skel, 0},
      {"recoverUSD", &POA_ActiveSurface::NotoActiveSurfaceBoss::recoverUSD_skel, 0},
      {"",0,0},{"",0,0},{"",0,0},
      {"stow", &POA_ActiveSurface::NotoActiveSurfaceBoss::stow_skel, 0},
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"find_characteristic", &POA_ActiveSurface::NotoActiveSurfaceBoss::find_characteristic_skel, 0},
      {"asOff", &POA_ActiveSurface::NotoActiveSurfaceBoss::asOff_skel, 0},
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"correction", &POA_ActiveSurface::NotoActiveSurfaceBoss::correction_skel, 0},
      {"",0,0},
      {"up", &POA_ActiveSurface::NotoActiveSurfaceBoss::up_skel, 0},
      {"",0,0},
      {"usdStatus4GUIClient", &POA_ActiveSurface::NotoActiveSurfaceBoss::usdStatus4GUIClient_skel, 0},
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"asOn", &POA_ActiveSurface::NotoActiveSurfaceBoss::asOn_skel, 0},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname;

          if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}

static TAO_ActiveSurface_NotoActiveSurfaceBoss_Perfect_Hash_OpTable tao_ActiveSurface_NotoActiveSurfaceBoss_optable;

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ss.cpp:984

TAO::Collocation_Proxy_Broker *
ActiveSurface__TAO_NotoActiveSurfaceBoss_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
ActiveSurface__TAO_NotoActiveSurfaceBoss_Proxy_Broker_Factory_Initializer (size_t)
{
  ActiveSurface__TAO_NotoActiveSurfaceBoss_Proxy_Broker_Factory_function_pointer = 
    ActiveSurface__TAO_NotoActiveSurfaceBoss_Proxy_Broker_Factory_function;
  
  return 0;
}

static int
ActiveSurface__TAO_NotoActiveSurfaceBoss_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  ActiveSurface__TAO_NotoActiveSurfaceBoss_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (ActiveSurface__TAO_NotoActiveSurfaceBoss_Proxy_Broker_Factory_Initializer)
    );

// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_ss.cpp:103

POA_ActiveSurface::NotoActiveSurfaceBoss::NotoActiveSurfaceBoss (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_ActiveSurface_NotoActiveSurfaceBoss_optable;
}

POA_ActiveSurface::NotoActiveSurfaceBoss::NotoActiveSurfaceBoss (const NotoActiveSurfaceBoss& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_ACS::ACSComponent (rhs),
    POA_ACS::CharacteristicModel (rhs),
    POA_ACS::CharacteristicComponent (rhs),
    POA_Management::CommandInterpreter (rhs),
    POA_Management::Subsystem (rhs),
    POA_ActiveSurface::ActiveSurfaceBoss (rhs)
{
}

POA_ActiveSurface::NotoActiveSurfaceBoss::~NotoActiveSurfaceBoss (void)
{
}
namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class _get_enabled_NotoActiveSurfaceBoss
    : public TAO::Upcall_Command
  {
  public:
    inline _get_enabled_NotoActiveSurfaceBoss (
      POA_ActiveSurface::NotoActiveSurfaceBoss * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::Management::ROTBoolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::Management::ROTBoolean> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_->enabled ();
    }
  
  private:
    POA_ActiveSurface::NotoActiveSurfaceBoss * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from 
// be/be_visitor_operation/operation_ss.cpp:190

void POA_ActiveSurface::NotoActiveSurfaceBoss::_get_enabled_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::Management::ROTBoolean>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_ActiveSurface::NotoActiveSurfaceBoss * const impl =
    static_cast<POA_ActiveSurface::NotoActiveSurfaceBoss *> (servant);

  _get_enabled_NotoActiveSurfaceBoss command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class _get_pprofile_NotoActiveSurfaceBoss
    : public TAO::Upcall_Command
  {
  public:
    inline _get_pprofile_NotoActiveSurfaceBoss (
      POA_ActiveSurface::NotoActiveSurfaceBoss * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ActiveSurface::ROTASProfile>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ActiveSurface::ROTASProfile> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_->pprofile ();
    }
  
  private:
    POA_ActiveSurface::NotoActiveSurfaceBoss * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from 
// be/be_visitor_operation/operation_ss.cpp:190

void POA_ActiveSurface::NotoActiveSurfaceBoss::_get_pprofile_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ActiveSurface::ROTASProfile>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_ActiveSurface::NotoActiveSurfaceBoss * const impl =
    static_cast<POA_ActiveSurface::NotoActiveSurfaceBoss *> (servant);

  _get_pprofile_NotoActiveSurfaceBoss command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class _get_tracking_NotoActiveSurfaceBoss
    : public TAO::Upcall_Command
  {
  public:
    inline _get_tracking_NotoActiveSurfaceBoss (
      POA_ActiveSurface::NotoActiveSurfaceBoss * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::Management::ROTBoolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::Management::ROTBoolean> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_->tracking ();
    }
  
  private:
    POA_ActiveSurface::NotoActiveSurfaceBoss * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from 
// be/be_visitor_operation/operation_ss.cpp:190

void POA_ActiveSurface::NotoActiveSurfaceBoss::_get_tracking_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::Management::ROTBoolean>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_ActiveSurface::NotoActiveSurfaceBoss * const impl =
    static_cast<POA_ActiveSurface::NotoActiveSurfaceBoss *> (servant);

  _get_tracking_NotoActiveSurfaceBoss command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class stop_NotoActiveSurfaceBoss
    : public TAO::Upcall_Command
  {
  public:
    inline stop_NotoActiveSurfaceBoss (
      POA_ActiveSurface::NotoActiveSurfaceBoss * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
          this->operation_details_,
          this->args_,
          2);
        
      TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_3 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
          this->operation_details_,
          this->args_,
          3);
        
      this->servant_->stop (
        arg_1
        , arg_2
        , arg_3);
    }
  
  private:
    POA_ActiveSurface::NotoActiveSurfaceBoss * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from 
// be/be_visitor_operation/operation_ss.cpp:190

void POA_ActiveSurface::NotoActiveSurfaceBoss::stop_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      ComponentErrors::_tc_ComponentErrorsEx
    };
  static ::CORBA::ULong const nexceptions = 1;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_circle;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_actuator;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_radius;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_circle,
      &_tao_actuator,
      &_tao_radius
    };
  
  static size_t const nargs = 4;
  
  POA_ActiveSurface::NotoActiveSurfaceBoss * const impl =
    static_cast<POA_ActiveSurface::NotoActiveSurfaceBoss *> (servant);

  stop_NotoActiveSurfaceBoss command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class stow_NotoActiveSurfaceBoss
    : public TAO::Upcall_Command
  {
  public:
    inline stow_NotoActiveSurfaceBoss (
      POA_ActiveSurface::NotoActiveSurfaceBoss * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
          this->operation_details_,
          this->args_,
          2);
        
      TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_3 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
          this->operation_details_,
          this->args_,
          3);
        
      this->servant_->stow (
        arg_1
        , arg_2
        , arg_3);
    }
  
  private:
    POA_ActiveSurface::NotoActiveSurfaceBoss * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from 
// be/be_visitor_operation/operation_ss.cpp:190

void POA_ActiveSurface::NotoActiveSurfaceBoss::stow_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      ComponentErrors::_tc_ComponentErrorsEx
    };
  static ::CORBA::ULong const nexceptions = 1;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_circle;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_actuator;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_radius;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_circle,
      &_tao_actuator,
      &_tao_radius
    };
  
  static size_t const nargs = 4;
  
  POA_ActiveSurface::NotoActiveSurfaceBoss * const impl =
    static_cast<POA_ActiveSurface::NotoActiveSurfaceBoss *> (servant);

  stow_NotoActiveSurfaceBoss command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class refPos_NotoActiveSurfaceBoss
    : public TAO::Upcall_Command
  {
  public:
    inline refPos_NotoActiveSurfaceBoss (
      POA_ActiveSurface::NotoActiveSurfaceBoss * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
          this->operation_details_,
          this->args_,
          2);
        
      TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_3 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
          this->operation_details_,
          this->args_,
          3);
        
      this->servant_->refPos (
        arg_1
        , arg_2
        , arg_3);
    }
  
  private:
    POA_ActiveSurface::NotoActiveSurfaceBoss * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from 
// be/be_visitor_operation/operation_ss.cpp:190

void POA_ActiveSurface::NotoActiveSurfaceBoss::refPos_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      ComponentErrors::_tc_ComponentErrorsEx
    };
  static ::CORBA::ULong const nexceptions = 1;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_circle;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_actuator;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_radius;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_circle,
      &_tao_actuator,
      &_tao_radius
    };
  
  static size_t const nargs = 4;
  
  POA_ActiveSurface::NotoActiveSurfaceBoss * const impl =
    static_cast<POA_ActiveSurface::NotoActiveSurfaceBoss *> (servant);

  refPos_NotoActiveSurfaceBoss command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class update_NotoActiveSurfaceBoss
    : public TAO::Upcall_Command
  {
  public:
    inline update_NotoActiveSurfaceBoss (
      POA_ActiveSurface::NotoActiveSurfaceBoss * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Double>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Double> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->update (
        arg_1);
    }
  
  private:
    POA_ActiveSurface::NotoActiveSurfaceBoss * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from 
// be/be_visitor_operation/operation_ss.cpp:190

void POA_ActiveSurface::NotoActiveSurfaceBoss::update_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      ComponentErrors::_tc_ComponentErrorsEx
    };
  static ::CORBA::ULong const nexceptions = 1;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Double>::in_arg_val _tao_elevation;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_elevation
    };
  
  static size_t const nargs = 2;
  
  POA_ActiveSurface::NotoActiveSurfaceBoss * const impl =
    static_cast<POA_ActiveSurface::NotoActiveSurfaceBoss *> (servant);

  update_NotoActiveSurfaceBoss command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class move_NotoActiveSurfaceBoss
    : public TAO::Upcall_Command
  {
  public:
    inline move_NotoActiveSurfaceBoss (
      POA_ActiveSurface::NotoActiveSurfaceBoss * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
          this->operation_details_,
          this->args_,
          2);
        
      TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_3 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
          this->operation_details_,
          this->args_,
          3);
        
      TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_4 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
          this->operation_details_,
          this->args_,
          4);
        
      this->servant_->move (
        arg_1
        , arg_2
        , arg_3
        , arg_4);
    }
  
  private:
    POA_ActiveSurface::NotoActiveSurfaceBoss * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from 
// be/be_visitor_operation/operation_ss.cpp:190

void POA_ActiveSurface::NotoActiveSurfaceBoss::move_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      ComponentErrors::_tc_ComponentErrorsEx
    };
  static ::CORBA::ULong const nexceptions = 1;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_circle;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_actuator;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_radius;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_incr;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_circle,
      &_tao_actuator,
      &_tao_radius,
      &_tao_incr
    };
  
  static size_t const nargs = 5;
  
  POA_ActiveSurface::NotoActiveSurfaceBoss * const impl =
    static_cast<POA_ActiveSurface::NotoActiveSurfaceBoss *> (servant);

  move_NotoActiveSurfaceBoss command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class correction_NotoActiveSurfaceBoss
    : public TAO::Upcall_Command
  {
  public:
    inline correction_NotoActiveSurfaceBoss (
      POA_ActiveSurface::NotoActiveSurfaceBoss * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
          this->operation_details_,
          this->args_,
          2);
        
      TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_3 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
          this->operation_details_,
          this->args_,
          3);
        
      TAO::SArg_Traits< ::CORBA::Double>::in_arg_type arg_4 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Double> (
          this->operation_details_,
          this->args_,
          4);
        
      this->servant_->correction (
        arg_1
        , arg_2
        , arg_3
        , arg_4);
    }
  
  private:
    POA_ActiveSurface::NotoActiveSurfaceBoss * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from 
// be/be_visitor_operation/operation_ss.cpp:190

void POA_ActiveSurface::NotoActiveSurfaceBoss::correction_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      ComponentErrors::_tc_ComponentErrorsEx
    };
  static ::CORBA::ULong const nexceptions = 1;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_circle;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_actuator;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_radius;
  TAO::SArg_Traits< ::CORBA::Double>::in_arg_val _tao_correction;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_circle,
      &_tao_actuator,
      &_tao_radius,
      &_tao_correction
    };
  
  static size_t const nargs = 5;
  
  POA_ActiveSurface::NotoActiveSurfaceBoss * const impl =
    static_cast<POA_ActiveSurface::NotoActiveSurfaceBoss *> (servant);

  correction_NotoActiveSurfaceBoss command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class setProfile_NotoActiveSurfaceBoss
    : public TAO::Upcall_Command
  {
  public:
    inline setProfile_NotoActiveSurfaceBoss (
      POA_ActiveSurface::NotoActiveSurfaceBoss * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ActiveSurface::TASProfile>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::ActiveSurface::TASProfile> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->setProfile (
        arg_1);
    }
  
  private:
    POA_ActiveSurface::NotoActiveSurfaceBoss * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from 
// be/be_visitor_operation/operation_ss.cpp:190

void POA_ActiveSurface::NotoActiveSurfaceBoss::setProfile_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      ComponentErrors::_tc_ComponentErrorsEx
    };
  static ::CORBA::ULong const nexceptions = 1;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::ActiveSurface::TASProfile>::in_arg_val _tao_profile;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_profile
    };
  
  static size_t const nargs = 2;
  
  POA_ActiveSurface::NotoActiveSurfaceBoss * const impl =
    static_cast<POA_ActiveSurface::NotoActiveSurfaceBoss *> (servant);

  setProfile_NotoActiveSurfaceBoss command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class usdStatus4GUIClient_NotoActiveSurfaceBoss
    : public TAO::Upcall_Command
  {
  public:
    inline usdStatus4GUIClient_NotoActiveSurfaceBoss (
      POA_ActiveSurface::NotoActiveSurfaceBoss * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
          this->operation_details_,
          this->args_,
          2);
        
      TAO::SArg_Traits< ::CORBA::Long>::out_arg_type arg_3 =
        TAO::Portable_Server::get_out_arg< ::CORBA::Long> (
          this->operation_details_,
          this->args_,
          3);
        
      this->servant_->usdStatus4GUIClient (
        arg_1
        , arg_2
        , arg_3);
    }
  
  private:
    POA_ActiveSurface::NotoActiveSurfaceBoss * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from 
// be/be_visitor_operation/operation_ss.cpp:190

void POA_ActiveSurface::NotoActiveSurfaceBoss::usdStatus4GUIClient_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      ComponentErrors::_tc_ComponentErrorsEx
    };
  static ::CORBA::ULong const nexceptions = 1;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_circle;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_actuator;
  TAO::SArg_Traits< ::CORBA::Long>::out_arg_val _tao_status;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_circle,
      &_tao_actuator,
      &_tao_status
    };
  
  static size_t const nargs = 4;
  
  POA_ActiveSurface::NotoActiveSurfaceBoss * const impl =
    static_cast<POA_ActiveSurface::NotoActiveSurfaceBoss *> (servant);

  usdStatus4GUIClient_NotoActiveSurfaceBoss command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class setActuator_NotoActiveSurfaceBoss
    : public TAO::Upcall_Command
  {
  public:
    inline setActuator_NotoActiveSurfaceBoss (
      POA_ActiveSurface::NotoActiveSurfaceBoss * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
          this->operation_details_,
          this->args_,
          2);
        
      TAO::SArg_Traits< ::CORBA::Long>::out_arg_type arg_3 =
        TAO::Portable_Server::get_out_arg< ::CORBA::Long> (
          this->operation_details_,
          this->args_,
          3);
        
      TAO::SArg_Traits< ::CORBA::Long>::out_arg_type arg_4 =
        TAO::Portable_Server::get_out_arg< ::CORBA::Long> (
          this->operation_details_,
          this->args_,
          4);
        
      TAO::SArg_Traits< ::CORBA::Long>::out_arg_type arg_5 =
        TAO::Portable_Server::get_out_arg< ::CORBA::Long> (
          this->operation_details_,
          this->args_,
          5);
        
      TAO::SArg_Traits< ::CORBA::Long>::out_arg_type arg_6 =
        TAO::Portable_Server::get_out_arg< ::CORBA::Long> (
          this->operation_details_,
          this->args_,
          6);
        
      TAO::SArg_Traits< ::CORBA::Long>::out_arg_type arg_7 =
        TAO::Portable_Server::get_out_arg< ::CORBA::Long> (
          this->operation_details_,
          this->args_,
          7);
        
      TAO::SArg_Traits< ::CORBA::Long>::out_arg_type arg_8 =
        TAO::Portable_Server::get_out_arg< ::CORBA::Long> (
          this->operation_details_,
          this->args_,
          8);
        
      this->servant_->setActuator (
        arg_1
        , arg_2
        , arg_3
        , arg_4
        , arg_5
        , arg_6
        , arg_7
        , arg_8);
    }
  
  private:
    POA_ActiveSurface::NotoActiveSurfaceBoss * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from 
// be/be_visitor_operation/operation_ss.cpp:190

void POA_ActiveSurface::NotoActiveSurfaceBoss::setActuator_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      ComponentErrors::_tc_ComponentErrorsEx
    };
  static ::CORBA::ULong const nexceptions = 1;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_circle;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_actuator;
  TAO::SArg_Traits< ::CORBA::Long>::out_arg_val _tao_actPos;
  TAO::SArg_Traits< ::CORBA::Long>::out_arg_val _tao_cmdPos;
  TAO::SArg_Traits< ::CORBA::Long>::out_arg_val _tao_Fmin;
  TAO::SArg_Traits< ::CORBA::Long>::out_arg_val _tao_Fmax;
  TAO::SArg_Traits< ::CORBA::Long>::out_arg_val _tao_acc;
  TAO::SArg_Traits< ::CORBA::Long>::out_arg_val _tao_delay;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_circle,
      &_tao_actuator,
      &_tao_actPos,
      &_tao_cmdPos,
      &_tao_Fmin,
      &_tao_Fmax,
      &_tao_acc,
      &_tao_delay
    };
  
  static size_t const nargs = 9;
  
  POA_ActiveSurface::NotoActiveSurfaceBoss * const impl =
    static_cast<POA_ActiveSurface::NotoActiveSurfaceBoss *> (servant);

  setActuator_NotoActiveSurfaceBoss command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class up_NotoActiveSurfaceBoss
    : public TAO::Upcall_Command
  {
  public:
    inline up_NotoActiveSurfaceBoss (
      POA_ActiveSurface::NotoActiveSurfaceBoss * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
          this->operation_details_,
          this->args_,
          2);
        
      TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_3 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
          this->operation_details_,
          this->args_,
          3);
        
      this->servant_->up (
        arg_1
        , arg_2
        , arg_3);
    }
  
  private:
    POA_ActiveSurface::NotoActiveSurfaceBoss * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from 
// be/be_visitor_operation/operation_ss.cpp:190

void POA_ActiveSurface::NotoActiveSurfaceBoss::up_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      ComponentErrors::_tc_ComponentErrorsEx
    };
  static ::CORBA::ULong const nexceptions = 1;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_circle;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_actuator;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_radius;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_circle,
      &_tao_actuator,
      &_tao_radius
    };
  
  static size_t const nargs = 4;
  
  POA_ActiveSurface::NotoActiveSurfaceBoss * const impl =
    static_cast<POA_ActiveSurface::NotoActiveSurfaceBoss *> (servant);

  up_NotoActiveSurfaceBoss command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class down_NotoActiveSurfaceBoss
    : public TAO::Upcall_Command
  {
  public:
    inline down_NotoActiveSurfaceBoss (
      POA_ActiveSurface::NotoActiveSurfaceBoss * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
          this->operation_details_,
          this->args_,
          2);
        
      TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_3 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
          this->operation_details_,
          this->args_,
          3);
        
      this->servant_->down (
        arg_1
        , arg_2
        , arg_3);
    }
  
  private:
    POA_ActiveSurface::NotoActiveSurfaceBoss * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from 
// be/be_visitor_operation/operation_ss.cpp:190

void POA_ActiveSurface::NotoActiveSurfaceBoss::down_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      ComponentErrors::_tc_ComponentErrorsEx
    };
  static ::CORBA::ULong const nexceptions = 1;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_circle;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_actuator;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_radius;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_circle,
      &_tao_actuator,
      &_tao_radius
    };
  
  static size_t const nargs = 4;
  
  POA_ActiveSurface::NotoActiveSurfaceBoss * const impl =
    static_cast<POA_ActiveSurface::NotoActiveSurfaceBoss *> (servant);

  down_NotoActiveSurfaceBoss command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class bottom_NotoActiveSurfaceBoss
    : public TAO::Upcall_Command
  {
  public:
    inline bottom_NotoActiveSurfaceBoss (
      POA_ActiveSurface::NotoActiveSurfaceBoss * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
          this->operation_details_,
          this->args_,
          2);
        
      TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_3 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
          this->operation_details_,
          this->args_,
          3);
        
      this->servant_->bottom (
        arg_1
        , arg_2
        , arg_3);
    }
  
  private:
    POA_ActiveSurface::NotoActiveSurfaceBoss * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from 
// be/be_visitor_operation/operation_ss.cpp:190

void POA_ActiveSurface::NotoActiveSurfaceBoss::bottom_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      ComponentErrors::_tc_ComponentErrorsEx
    };
  static ::CORBA::ULong const nexceptions = 1;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_circle;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_actuator;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_radius;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_circle,
      &_tao_actuator,
      &_tao_radius
    };
  
  static size_t const nargs = 4;
  
  POA_ActiveSurface::NotoActiveSurfaceBoss * const impl =
    static_cast<POA_ActiveSurface::NotoActiveSurfaceBoss *> (servant);

  bottom_NotoActiveSurfaceBoss command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class top_NotoActiveSurfaceBoss
    : public TAO::Upcall_Command
  {
  public:
    inline top_NotoActiveSurfaceBoss (
      POA_ActiveSurface::NotoActiveSurfaceBoss * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
          this->operation_details_,
          this->args_,
          2);
        
      TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_3 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
          this->operation_details_,
          this->args_,
          3);
        
      this->servant_->top (
        arg_1
        , arg_2
        , arg_3);
    }
  
  private:
    POA_ActiveSurface::NotoActiveSurfaceBoss * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from 
// be/be_visitor_operation/operation_ss.cpp:190

void POA_ActiveSurface::NotoActiveSurfaceBoss::top_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      ComponentErrors::_tc_ComponentErrorsEx
    };
  static ::CORBA::ULong const nexceptions = 1;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_circle;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_actuator;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_radius;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_circle,
      &_tao_actuator,
      &_tao_radius
    };
  
  static size_t const nargs = 4;
  
  POA_ActiveSurface::NotoActiveSurfaceBoss * const impl =
    static_cast<POA_ActiveSurface::NotoActiveSurfaceBoss *> (servant);

  top_NotoActiveSurfaceBoss command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class reset_NotoActiveSurfaceBoss
    : public TAO::Upcall_Command
  {
  public:
    inline reset_NotoActiveSurfaceBoss (
      POA_ActiveSurface::NotoActiveSurfaceBoss * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
          this->operation_details_,
          this->args_,
          2);
        
      TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_3 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
          this->operation_details_,
          this->args_,
          3);
        
      this->servant_->reset (
        arg_1
        , arg_2
        , arg_3);
    }
  
  private:
    POA_ActiveSurface::NotoActiveSurfaceBoss * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from 
// be/be_visitor_operation/operation_ss.cpp:190

void POA_ActiveSurface::NotoActiveSurfaceBoss::reset_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      ComponentErrors::_tc_ComponentErrorsEx
    };
  static ::CORBA::ULong const nexceptions = 1;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_circle;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_actuator;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_radius;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_circle,
      &_tao_actuator,
      &_tao_radius
    };
  
  static size_t const nargs = 4;
  
  POA_ActiveSurface::NotoActiveSurfaceBoss * const impl =
    static_cast<POA_ActiveSurface::NotoActiveSurfaceBoss *> (servant);

  reset_NotoActiveSurfaceBoss command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class recoverUSD_NotoActiveSurfaceBoss
    : public TAO::Upcall_Command
  {
  public:
    inline recoverUSD_NotoActiveSurfaceBoss (
      POA_ActiveSurface::NotoActiveSurfaceBoss * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
          this->operation_details_,
          this->args_,
          2);
        
      this->servant_->recoverUSD (
        arg_1
        , arg_2);
    }
  
  private:
    POA_ActiveSurface::NotoActiveSurfaceBoss * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from 
// be/be_visitor_operation/operation_ss.cpp:190

void POA_ActiveSurface::NotoActiveSurfaceBoss::recoverUSD_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      ComponentErrors::_tc_ComponentErrorsEx
    };
  static ::CORBA::ULong const nexceptions = 1;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_circle;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_actuator;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_circle,
      &_tao_actuator
    };
  
  static size_t const nargs = 3;
  
  POA_ActiveSurface::NotoActiveSurfaceBoss * const impl =
    static_cast<POA_ActiveSurface::NotoActiveSurfaceBoss *> (servant);

  recoverUSD_NotoActiveSurfaceBoss command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class calibrate_NotoActiveSurfaceBoss
    : public TAO::Upcall_Command
  {
  public:
    inline calibrate_NotoActiveSurfaceBoss (
      POA_ActiveSurface::NotoActiveSurfaceBoss * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
          this->operation_details_,
          this->args_,
          2);
        
      TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_3 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
          this->operation_details_,
          this->args_,
          3);
        
      this->servant_->calibrate (
        arg_1
        , arg_2
        , arg_3);
    }
  
  private:
    POA_ActiveSurface::NotoActiveSurfaceBoss * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from 
// be/be_visitor_operation/operation_ss.cpp:190

void POA_ActiveSurface::NotoActiveSurfaceBoss::calibrate_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_circle;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_actuator;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_radius;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_circle,
      &_tao_actuator,
      &_tao_radius
    };
  
  static size_t const nargs = 4;
  
  POA_ActiveSurface::NotoActiveSurfaceBoss * const impl =
    static_cast<POA_ActiveSurface::NotoActiveSurfaceBoss *> (servant);

  calibrate_NotoActiveSurfaceBoss command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class calVer_NotoActiveSurfaceBoss
    : public TAO::Upcall_Command
  {
  public:
    inline calVer_NotoActiveSurfaceBoss (
      POA_ActiveSurface::NotoActiveSurfaceBoss * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
          this->operation_details_,
          this->args_,
          2);
        
      TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_3 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
          this->operation_details_,
          this->args_,
          3);
        
      this->servant_->calVer (
        arg_1
        , arg_2
        , arg_3);
    }
  
  private:
    POA_ActiveSurface::NotoActiveSurfaceBoss * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from 
// be/be_visitor_operation/operation_ss.cpp:190

void POA_ActiveSurface::NotoActiveSurfaceBoss::calVer_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const exceptions[] = 
    {
      ComponentErrors::_tc_ComponentErrorsEx
    };
  static ::CORBA::ULong const nexceptions = 1;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_circle;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_actuator;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_radius;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_circle,
      &_tao_actuator,
      &_tao_radius
    };
  
  static size_t const nargs = 4;
  
  POA_ActiveSurface::NotoActiveSurfaceBoss * const impl =
    static_cast<POA_ActiveSurface::NotoActiveSurfaceBoss *> (servant);

  calVer_NotoActiveSurfaceBoss command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}



// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_ss.cpp:169

namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class _is_a_NotoActiveSurfaceBoss_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _is_a_NotoActiveSurfaceBoss_Upcall_Command (
      POA_ActiveSurface::NotoActiveSurfaceBoss * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::CORBA::Char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Char *> (
          this->operation_details_,
          this->args_,
          1);
        
      retval =
        this->servant_-> _is_a (
          arg_1);
    }
  
  private:
    POA_ActiveSurface::NotoActiveSurfaceBoss * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_ActiveSurface::NotoActiveSurfaceBoss::_is_a_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Char *>::in_arg_val _tao_repository_id;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };
  
  static size_t const nargs = 2;
  
  POA_ActiveSurface::NotoActiveSurfaceBoss * const impl =
    static_cast<POA_ActiveSurface::NotoActiveSurfaceBoss *> (servant);
  
  _is_a_NotoActiveSurfaceBoss_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class _non_existent_NotoActiveSurfaceBoss_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _non_existent_NotoActiveSurfaceBoss_Upcall_Command (
      POA_ActiveSurface::NotoActiveSurfaceBoss * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _non_existent ();
    }
  
  private:
    POA_ActiveSurface::NotoActiveSurfaceBoss * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_ActiveSurface::NotoActiveSurfaceBoss::_non_existent_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_ActiveSurface::NotoActiveSurfaceBoss * const impl =
    static_cast<POA_ActiveSurface::NotoActiveSurfaceBoss *> (servant);
  
  _non_existent_NotoActiveSurfaceBoss_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}
namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class _repository_id_NotoActiveSurfaceBoss_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _repository_id_NotoActiveSurfaceBoss_Upcall_Command (
      POA_ActiveSurface::NotoActiveSurfaceBoss * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Char *>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Char *> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _repository_id ();
    }
  
  private:
    POA_ActiveSurface::NotoActiveSurfaceBoss * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_ActiveSurface::NotoActiveSurfaceBoss::_repository_id_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::Char *>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_ActiveSurface::NotoActiveSurfaceBoss * const impl =
    static_cast<POA_ActiveSurface::NotoActiveSurfaceBoss *> (servant);
  
  _repository_id_NotoActiveSurfaceBoss_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_ss.cpp:508

void POA_ActiveSurface::NotoActiveSurfaceBoss::_interface_skel (
    TAO_ServerRequest & server_request, 
    void * /* servant_upcall */,
    void * servant)
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (_tao_adapter == 0)
    {
      throw ::CORBA::INTF_REPOS (::CORBA::OMGVMCID | 1, ::CORBA::COMPLETED_NO);
    }
  
  POA_ActiveSurface::NotoActiveSurfaceBoss * const impl =
    static_cast<POA_ActiveSurface::NotoActiveSurfaceBoss *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval = impl->_get_interface ();
  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();
  
  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (_tao_out, _tao_retval);
  
  _tao_adapter->dispose (_tao_retval);
  
  if (_tao_result == false)
    {
      throw ::CORBA::MARSHAL ();
    }
}

namespace POA_ActiveSurface
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class _get_component_NotoActiveSurfaceBoss_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _get_component_NotoActiveSurfaceBoss_Upcall_Command (
      POA_ActiveSurface::NotoActiveSurfaceBoss * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _get_component ();
    }
  
  private:
    POA_ActiveSurface::NotoActiveSurfaceBoss * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_ActiveSurface::NotoActiveSurfaceBoss::_component_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_ActiveSurface::NotoActiveSurfaceBoss * const impl =
    static_cast<POA_ActiveSurface::NotoActiveSurfaceBoss *> (servant);
  
  _get_component_NotoActiveSurfaceBoss_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

::CORBA::Boolean POA_ActiveSurface::NotoActiveSurfaceBoss::_is_a (const char* value)
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:alma/ACS/ACSComponent:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:alma/ACS/CharacteristicModel:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:alma/ACS/CharacteristicComponent:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:alma/Management/CommandInterpreter:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:alma/Management/Subsystem:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:alma/ActiveSurface/ActiveSurfaceBoss:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:alma/ActiveSurface/NotoActiveSurfaceBoss:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_ActiveSurface::NotoActiveSurfaceBoss::_interface_repository_id (void) const
{
  return "IDL:alma/ActiveSurface/NotoActiveSurfaceBoss:1.0";
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ss.cpp:926

void POA_ActiveSurface::NotoActiveSurfaceBoss::_dispatch (TAO_ServerRequest & req, void * servant_upcall)
{
  this->synchronous_upcall_dispatch (req, servant_upcall, this);
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ss.cpp:852

ActiveSurface::NotoActiveSurfaceBoss *
POA_ActiveSurface::NotoActiveSurfaceBoss::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();
  
  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object_ptr ();
  
  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );
  
  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();
  
  typedef ::ActiveSurface::NotoActiveSurfaceBoss STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        ActiveSurface__TAO_NotoActiveSurfaceBoss_Proxy_Broker_Factory_function_pointer
      );
}

#endif /* ifndef */

